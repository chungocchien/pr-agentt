{
  "pr_agent.agent.pr_agent.PRAgent": {
    "id": "pr_agent.agent.pr_agent.PRAgent",
    "name": "PRAgent",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/agent/pr_agent.py",
    "relative_path": "pr_agent/agent/pr_agent.py",
    "depends_on": [
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.update_settings_from_args",
      "pr_agent.tools.pr_reviewer.PRReviewer",
      "pr_agent.cli.run",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "class PRAgent:\n    def __init__(self, ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n        self.ai_handler = ai_handler  # will be initialized in run_action\n\n    async def handle_request(self, pr_url, request, notify=None) -> bool:\n        # First, apply repo specific settings if exists\n        apply_repo_settings(pr_url)\n\n        # Then, apply user specific settings if exists\n        if isinstance(request, str):\n            request = request.replace(\"'\", \"\\\\'\")\n            lexer = shlex.shlex(request, posix=True)\n            lexer.whitespace_split = True\n            action, *args = list(lexer)\n        else:\n            action, *args = request\n\n        # validate args\n        is_valid, arg = CliArgs.validate_user_args(args)\n        if not is_valid:\n            get_logger().error(\n                f\"CLI argument for param '{arg}' is forbidden. Use instead a configuration file.\"\n            )\n            return False\n\n        # Update settings from args\n        args = update_settings_from_args(args)\n\n        # Append the response language in the extra instructions\n        response_language = get_settings().config.get('response_language', 'en-us')\n        if response_language.lower() != 'en-us':\n            get_logger().info(f'User has set the response language to: {response_language}')\n            for key in get_settings():\n                setting = get_settings().get(key)\n                if str(type(setting)) == \"<class 'dynaconf.utils.boxing.DynaBox'>\":\n                    if hasattr(setting, 'extra_instructions'):\n                        current_extra_instructions = setting.extra_instructions\n                        if current_extra_instructions:\n                            setting.extra_instructions = current_extra_instructions+ f\"\\n======\\n\\nIn addition, Your response MUST be written in the language corresponding to local code: {response_language}. This is crucial.\"\n                        else:\n                            setting.extra_instructions = f\"Your response MUST be written in the language corresponding to locale code: '{response_language}'. This is crucial.\"\n\n        action = action.lstrip(\"/\").lower()\n        if action not in command2class:\n            get_logger().warning(f\"Unknown command: {action}\")\n            return False\n        with get_logger().contextualize(command=action, pr_url=pr_url):\n            get_logger().info(\"PR-Agent request handler started\", analytics=True)\n            if action == \"answer\":\n                if notify:\n                    notify()\n                await PRReviewer(pr_url, is_answer=True, args=args, ai_handler=self.ai_handler).run()\n            elif action == \"auto_review\":\n                await PRReviewer(pr_url, is_auto=True, args=args, ai_handler=self.ai_handler).run()\n            elif action in command2class:\n                if notify:\n                    notify()\n\n                await command2class[action](pr_url, ai_handler=self.ai_handler, args=args).run()\n            else:\n                return False\n            return True",
    "start_line": 50,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRAgent",
    "component_id": "pr_agent.agent.pr_agent.PRAgent"
  },
  "pr_agent.algo.ai_handlers.base_ai_handler.BaseAiHandler": {
    "id": "pr_agent.algo.ai_handlers.base_ai_handler.BaseAiHandler",
    "name": "BaseAiHandler",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/ai_handlers/base_ai_handler.py",
    "relative_path": "pr_agent/algo/ai_handlers/base_ai_handler.py",
    "depends_on": [],
    "source_code": "class BaseAiHandler(ABC):\n    \"\"\"\n    This class defines the interface for an AI handler to be used by the PR Agents.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self):\n        pass\n\n    @property\n    @abstractmethod\n    def deployment_id(self):\n        pass\n\n    @abstractmethod\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2, img_path: str = None):\n        \"\"\"\n        This method should be implemented to return a chat completion from the AI model.\n        Args:\n            model (str): the name of the model to use for the chat completion\n            system (str): the system message string to use for the chat completion\n            user (str): the user message string to use for the chat completion\n            temperature (float): the temperature to use for the chat completion\n        \"\"\"\n        pass",
    "start_line": 4,
    "end_line": 28,
    "has_docstring": true,
    "docstring": "This class defines the interface for an AI handler to be used by the PR Agents.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ABC"
    ],
    "class_name": null,
    "display_name": "class BaseAiHandler",
    "component_id": "pr_agent.algo.ai_handlers.base_ai_handler.BaseAiHandler"
  },
  "pr_agent.algo.ai_handlers.langchain_ai_handler.LangChainOpenAIHandler": {
    "id": "pr_agent.algo.ai_handlers.langchain_ai_handler.LangChainOpenAIHandler",
    "name": "LangChainOpenAIHandler",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/ai_handlers/langchain_ai_handler.py",
    "relative_path": "pr_agent/algo/ai_handlers/langchain_ai_handler.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class LangChainOpenAIHandler(BaseAiHandler):\n    def __init__(self):\n        # Initialize OpenAIHandler specific attributes here\n        super().__init__()\n        self.azure = get_settings().get(\"OPENAI.API_TYPE\", \"\").lower() == \"azure\"\n\n        # Create a default unused chat object to trigger early validation\n        self._create_chat(self.deployment_id)\n\n    def chat(self, messages: list, model: str, temperature: float):\n        chat = self._create_chat(self.deployment_id)\n        return chat.invoke(input=messages, model=model, temperature=temperature)\n\n    @property\n    def deployment_id(self):\n        \"\"\"\n        Returns the deployment ID for the OpenAI API.\n        \"\"\"\n        return get_settings().get(\"OPENAI.DEPLOYMENT_ID\", None)\n\n    @retry(exceptions=(APIError, Timeout, AttributeError, RateLimitError),\n           tries=OPENAI_RETRIES, delay=2, backoff=2, jitter=(1, 3))\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2):\n        try:\n            messages = [SystemMessage(content=system), HumanMessage(content=user)]\n\n            # get a chat completion from the formatted messages\n            resp = self.chat(messages, model=model, temperature=temperature)\n            finish_reason = \"completed\"\n            return resp.content, finish_reason\n\n        except (Exception) as e:\n            get_logger().error(\"Unknown error during OpenAI inference: \", e)\n            raise e\n\n    def _create_chat(self, deployment_id=None):\n        try:\n            if self.azure:\n                # using a partial function so we can set the deployment_id later to support fallback_deployments\n                # but still need to access the other settings now so we can raise a proper exception if they're missing\n                return AzureChatOpenAI(\n                    openai_api_key=get_settings().openai.key,\n                    openai_api_version=get_settings().openai.api_version,\n                    azure_deployment=deployment_id,\n                    azure_endpoint=get_settings().openai.api_base,\n                )\n            else:\n                # for llms that compatible with openai, should use custom api base\n                openai_api_base = get_settings().get(\"OPENAI.API_BASE\", None)\n                if openai_api_base is None or len(openai_api_base) == 0:\n                    return ChatOpenAI(openai_api_key=get_settings().openai.key)\n                else:\n                    return ChatOpenAI(openai_api_key=get_settings().openai.key, openai_api_base=openai_api_base)\n        except AttributeError as e:\n            if getattr(e, \"name\"):\n                raise ValueError(f\"OpenAI {e.name} is required\") from e\n            else:\n                raise e",
    "start_line": 19,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseAiHandler"
    ],
    "class_name": null,
    "display_name": "class LangChainOpenAIHandler",
    "component_id": "pr_agent.algo.ai_handlers.langchain_ai_handler.LangChainOpenAIHandler"
  },
  "pr_agent.algo.ai_handlers.litellm_ai_handler.LiteLLMAIHandler": {
    "id": "pr_agent.algo.ai_handlers.litellm_ai_handler.LiteLLMAIHandler",
    "name": "LiteLLMAIHandler",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/ai_handlers/litellm_ai_handler.py",
    "relative_path": "pr_agent/algo/ai_handlers/litellm_ai_handler.py",
    "depends_on": [
      "pr_agent.algo.utils.get_version",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class LiteLLMAIHandler(BaseAiHandler):\n    \"\"\"\n    This class handles interactions with the OpenAI API for chat completions.\n    It initializes the API key and other settings from a configuration file,\n    and provides a method for performing chat completions using the OpenAI ChatCompletion API.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the OpenAI API key and other settings from a configuration file.\n        Raises a ValueError if the OpenAI key is missing.\n        \"\"\"\n        self.azure = False\n        self.api_base = None\n        self.repetition_penalty = None\n        if get_settings().get(\"OPENAI.KEY\", None):\n            openai.api_key = get_settings().openai.key\n            litellm.openai_key = get_settings().openai.key\n        elif 'OPENAI_API_KEY' not in os.environ:\n            litellm.api_key = \"dummy_key\"\n        if get_settings().get(\"aws.AWS_ACCESS_KEY_ID\"):\n            assert get_settings().aws.AWS_SECRET_ACCESS_KEY and get_settings().aws.AWS_REGION_NAME, \"AWS credentials are incomplete\"\n            os.environ[\"AWS_ACCESS_KEY_ID\"] = get_settings().aws.AWS_ACCESS_KEY_ID\n            os.environ[\"AWS_SECRET_ACCESS_KEY\"] = get_settings().aws.AWS_SECRET_ACCESS_KEY\n            os.environ[\"AWS_REGION_NAME\"] = get_settings().aws.AWS_REGION_NAME\n        if get_settings().get(\"LITELLM.DROP_PARAMS\", None):\n            litellm.drop_params = get_settings().litellm.drop_params\n        if get_settings().get(\"LITELLM.SUCCESS_CALLBACK\", None):\n            litellm.success_callback = get_settings().litellm.success_callback\n        if get_settings().get(\"LITELLM.FAILURE_CALLBACK\", None):\n            litellm.failure_callback = get_settings().litellm.failure_callback\n        if get_settings().get(\"LITELLM.SERVICE_CALLBACK\", None):\n            litellm.service_callback = get_settings().litellm.service_callback\n        if get_settings().get(\"OPENAI.ORG\", None):\n            litellm.organization = get_settings().openai.org\n        if get_settings().get(\"OPENAI.API_TYPE\", None):\n            if get_settings().openai.api_type == \"azure\":\n                self.azure = True\n                litellm.azure_key = get_settings().openai.key\n        if get_settings().get(\"OPENAI.API_VERSION\", None):\n            litellm.api_version = get_settings().openai.api_version\n        if get_settings().get(\"OPENAI.API_BASE\", None):\n            litellm.api_base = get_settings().openai.api_base\n        if get_settings().get(\"ANTHROPIC.KEY\", None):\n            litellm.anthropic_key = get_settings().anthropic.key\n        if get_settings().get(\"COHERE.KEY\", None):\n            litellm.cohere_key = get_settings().cohere.key\n        if get_settings().get(\"GROQ.KEY\", None):\n            litellm.api_key = get_settings().groq.key\n        if get_settings().get(\"REPLICATE.KEY\", None):\n            litellm.replicate_key = get_settings().replicate.key\n        if get_settings().get(\"HUGGINGFACE.KEY\", None):\n            litellm.huggingface_key = get_settings().huggingface.key\n        if get_settings().get(\"HUGGINGFACE.API_BASE\", None) and 'huggingface' in get_settings().config.model:\n            litellm.api_base = get_settings().huggingface.api_base\n            self.api_base = get_settings().huggingface.api_base\n        if get_settings().get(\"OLLAMA.API_BASE\", None):\n            litellm.api_base = get_settings().ollama.api_base\n            self.api_base = get_settings().ollama.api_base\n        if get_settings().get(\"HUGGINGFACE.REPETITION_PENALTY\", None):\n            self.repetition_penalty = float(get_settings().huggingface.repetition_penalty)\n        if get_settings().get(\"VERTEXAI.VERTEX_PROJECT\", None):\n            litellm.vertex_project = get_settings().vertexai.vertex_project\n            litellm.vertex_location = get_settings().get(\n                \"VERTEXAI.VERTEX_LOCATION\", None\n            )\n        # Google AI Studio\n        # SEE https://docs.litellm.ai/docs/providers/gemini\n        if get_settings().get(\"GOOGLE_AI_STUDIO.GEMINI_API_KEY\", None):\n          os.environ[\"GEMINI_API_KEY\"] = get_settings().google_ai_studio.gemini_api_key\n\n        # Support deepseek models\n        if get_settings().get(\"DEEPSEEK.KEY\", None):\n            os.environ['DEEPSEEK_API_KEY'] = get_settings().get(\"DEEPSEEK.KEY\")\n\n        # Support deepinfra models\n        if get_settings().get(\"DEEPINFRA.KEY\", None):\n            os.environ['DEEPINFRA_API_KEY'] = get_settings().get(\"DEEPINFRA.KEY\")\n\n        # Models that only use user meessage\n        self.user_message_only_models = USER_MESSAGE_ONLY_MODELS\n\n        # Model that doesn't support temperature argument\n        self.no_support_temperature_models = NO_SUPPORT_TEMPERATURE_MODELS\n\n        # Models that support reasoning effort\n        self.support_reasoning_models = SUPPORT_REASONING_EFFORT_MODELS\n\n        # Models that support extended thinking\n        self.claude_extended_thinking_models = CLAUDE_EXTENDED_THINKING_MODELS\n\n    def prepare_logs(self, response, system, user, resp, finish_reason):\n        response_log = response.dict().copy()\n        response_log['system'] = system\n        response_log['user'] = user\n        response_log['output'] = resp\n        response_log['finish_reason'] = finish_reason\n        if hasattr(self, 'main_pr_language'):\n            response_log['main_pr_language'] = self.main_pr_language\n        else:\n            response_log['main_pr_language'] = 'unknown'\n        return response_log\n\n    def _configure_claude_extended_thinking(self, model: str, kwargs: dict) -> dict:\n        \"\"\"\n        Configure Claude extended thinking parameters if applicable.\n\n        Args:\n            model (str): The AI model being used\n            kwargs (dict): The keyword arguments for the model call\n\n        Returns:\n            dict: Updated kwargs with extended thinking configuration\n        \"\"\"\n        extended_thinking_budget_tokens = get_settings().config.get(\"extended_thinking_budget_tokens\", 2048)\n        extended_thinking_max_output_tokens = get_settings().config.get(\"extended_thinking_max_output_tokens\", 4096)\n\n        # Validate extended thinking parameters\n        if not isinstance(extended_thinking_budget_tokens, int) or extended_thinking_budget_tokens <= 0:\n            raise ValueError(f\"extended_thinking_budget_tokens must be a positive integer, got {extended_thinking_budget_tokens}\")\n        if not isinstance(extended_thinking_max_output_tokens, int) or extended_thinking_max_output_tokens <= 0:\n            raise ValueError(f\"extended_thinking_max_output_tokens must be a positive integer, got {extended_thinking_max_output_tokens}\")\n        if extended_thinking_max_output_tokens < extended_thinking_budget_tokens:\n            raise ValueError(f\"extended_thinking_max_output_tokens ({extended_thinking_max_output_tokens}) must be greater than or equal to extended_thinking_budget_tokens ({extended_thinking_budget_tokens})\")\n\n        kwargs[\"thinking\"] = {\n            \"type\": \"enabled\",\n            \"budget_tokens\": extended_thinking_budget_tokens\n        }\n        if get_settings().config.verbosity_level >= 2:\n            get_logger().info(f\"Adding max output tokens {extended_thinking_max_output_tokens} to model {model}, extended thinking budget tokens: {extended_thinking_budget_tokens}\")\n        kwargs[\"max_tokens\"] = extended_thinking_max_output_tokens\n\n        # temperature may only be set to 1 when thinking is enabled\n        if get_settings().config.verbosity_level >= 2:\n            get_logger().info(\"Temperature may only be set to 1 when thinking is enabled with claude models.\")\n        kwargs[\"temperature\"] = 1\n\n        return kwargs\n\n    def add_litellm_callbacks(selfs, kwargs) -> dict:\n        captured_extra = []\n\n        def capture_logs(message):\n            # Parsing the log message and context\n            record = message.record\n            log_entry = {}\n            if record.get('extra', None).get('command', None) is not None:\n                log_entry.update({\"command\": record['extra'][\"command\"]})\n            if record.get('extra', {}).get('pr_url', None) is not None:\n                log_entry.update({\"pr_url\": record['extra'][\"pr_url\"]})\n\n            # Append the log entry to the captured_logs list\n            captured_extra.append(log_entry)\n\n        # Adding the custom sink to Loguru\n        handler_id = get_logger().add(capture_logs)\n        get_logger().debug(\"Capturing logs for litellm callbacks\")\n        get_logger().remove(handler_id)\n\n        context = captured_extra[0] if len(captured_extra) > 0 else None\n\n        command = context.get(\"command\", \"unknown\")\n        pr_url = context.get(\"pr_url\", \"unknown\")\n        git_provider = get_settings().config.git_provider\n\n        metadata = dict()\n        callbacks = litellm.success_callback + litellm.failure_callback + litellm.service_callback\n        if \"langfuse\" in callbacks:\n            metadata.update({\n                \"trace_name\": command,\n                \"tags\": [git_provider, command, f'version:{get_version()}'],\n                \"trace_metadata\": {\n                    \"command\": command,\n                    \"pr_url\": pr_url,\n                },\n            })\n        if \"langsmith\" in callbacks:\n            metadata.update({\n                \"run_name\": command,\n                \"tags\": [git_provider, command, f'version:{get_version()}'],\n                \"extra\": {\n                    \"metadata\": {\n                        \"command\": command,\n                        \"pr_url\": pr_url,\n                    }\n                },\n            })\n\n        # Adding the captured logs to the kwargs\n        kwargs[\"metadata\"] = metadata\n\n        return kwargs\n\n    @property\n    def deployment_id(self):\n        \"\"\"\n        Returns the deployment ID for the OpenAI API.\n        \"\"\"\n        return get_settings().get(\"OPENAI.DEPLOYMENT_ID\", None)\n\n    @retry(\n        retry=retry_if_exception_type((openai.APIError, openai.APIConnectionError, openai.APITimeoutError)), # No retry on RateLimitError\n        stop=stop_after_attempt(OPENAI_RETRIES)\n    )\n    async def chat_completion(self, model: str, system: str, user: str, temperature: float = 0.2, img_path: str = None):\n        try:\n            resp, finish_reason = None, None\n            deployment_id = self.deployment_id\n            if self.azure:\n                model = 'azure/' + model\n            if 'claude' in model and not system:\n                system = \"No system prompt provided\"\n                get_logger().warning(\n                    \"Empty system prompt for claude model. Adding a newline character to prevent OpenAI API error.\")\n            messages = [{\"role\": \"system\", \"content\": system}, {\"role\": \"user\", \"content\": user}]\n\n            if img_path:\n                try:\n                    # check if the image link is alive\n                    r = requests.head(img_path, allow_redirects=True)\n                    if r.status_code == 404:\n                        error_msg = f\"The image link is not [alive](img_path).\\nPlease repost the original image as a comment, and send the question again with 'quote reply' (see [instructions](https://pr-agent-docs.codium.ai/tools/ask/#ask-on-images-using-the-pr-code-as-context)).\"\n                        get_logger().error(error_msg)\n                        return f\"{error_msg}\", \"error\"\n                except Exception as e:\n                    get_logger().error(f\"Error fetching image: {img_path}\", e)\n                    return f\"Error fetching image: {img_path}\", \"error\"\n                messages[1][\"content\"] = [{\"type\": \"text\", \"text\": messages[1][\"content\"]},\n                                          {\"type\": \"image_url\", \"image_url\": {\"url\": img_path}}]\n\n            # Currently, some models do not support a separate system and user prompts\n            if model in self.user_message_only_models or get_settings().config.custom_reasoning_model:\n                user = f\"{system}\\n\\n\\n{user}\"\n                system = \"\"\n                get_logger().info(f\"Using model {model}, combining system and user prompts\")\n                messages = [{\"role\": \"user\", \"content\": user}]\n                kwargs = {\n                    \"model\": model,\n                    \"deployment_id\": deployment_id,\n                    \"messages\": messages,\n                    \"timeout\": get_settings().config.ai_timeout,\n                    \"api_base\": self.api_base,\n                }\n            else:\n                kwargs = {\n                    \"model\": model,\n                    \"deployment_id\": deployment_id,\n                    \"messages\": messages,\n                    \"timeout\": get_settings().config.ai_timeout,\n                    \"api_base\": self.api_base,\n                }\n\n            # Add temperature only if model supports it\n            if model not in self.no_support_temperature_models and not get_settings().config.custom_reasoning_model:\n                # get_logger().info(f\"Adding temperature with value {temperature} to model {model}.\")\n                kwargs[\"temperature\"] = temperature\n\n            # Add reasoning_effort if model supports it\n            if (model in self.support_reasoning_models):\n                supported_reasoning_efforts = [ReasoningEffort.HIGH.value, ReasoningEffort.MEDIUM.value, ReasoningEffort.LOW.value]\n                reasoning_effort = get_settings().config.reasoning_effort if (get_settings().config.reasoning_effort in supported_reasoning_efforts) else ReasoningEffort.MEDIUM.value\n                get_logger().info(f\"Adding reasoning_effort with value {reasoning_effort} to model {model}.\")\n                kwargs[\"reasoning_effort\"] = reasoning_effort\n\n            # https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking\n            if (model in self.claude_extended_thinking_models) and get_settings().config.get(\"enable_claude_extended_thinking\", False):\n                kwargs = self._configure_claude_extended_thinking(model, kwargs)\n\n            if get_settings().litellm.get(\"enable_callbacks\", False):\n                kwargs = self.add_litellm_callbacks(kwargs)\n\n            seed = get_settings().config.get(\"seed\", -1)\n            if temperature > 0 and seed >= 0:\n                raise ValueError(f\"Seed ({seed}) is not supported with temperature ({temperature}) > 0\")\n            elif seed >= 0:\n                get_logger().info(f\"Using fixed seed of {seed}\")\n                kwargs[\"seed\"] = seed\n\n            if self.repetition_penalty:\n                kwargs[\"repetition_penalty\"] = self.repetition_penalty\n\n            #Added support for extra_headers while using litellm to call underlying model, via a api management gateway, would allow for passing custom headers for security and authorization\n            if get_settings().get(\"LITELLM.EXTRA_HEADERS\", None):\n                try:\n                    litellm_extra_headers = json.loads(get_settings().litellm.extra_headers)\n                    if not isinstance(litellm_extra_headers, dict):\n                        raise ValueError(\"LITELLM.EXTRA_HEADERS must be a JSON object\")\n                except json.JSONDecodeError as e:\n                    raise ValueError(f\"LITELLM.EXTRA_HEADERS contains invalid JSON: {str(e)}\")\n                kwargs[\"extra_headers\"] = litellm_extra_headers\n\n            get_logger().debug(\"Prompts\", artifact={\"system\": system, \"user\": user})\n\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"\\nSystem prompt:\\n{system}\")\n                get_logger().info(f\"\\nUser prompt:\\n{user}\")\n\n            response = await acompletion(**kwargs)\n        except (openai.APIError, openai.APITimeoutError) as e:\n            get_logger().warning(f\"Error during LLM inference: {e}\")\n            raise\n        except (openai.RateLimitError) as e:\n            get_logger().error(f\"Rate limit error during LLM inference: {e}\")\n            raise\n        except (Exception) as e:\n            get_logger().warning(f\"Unknown error during LLM inference: {e}\")\n            raise openai.APIError from e\n        if response is None or len(response[\"choices\"]) == 0:\n            raise openai.APIError\n        else:\n            resp = response[\"choices\"][0]['message']['content']\n            finish_reason = response[\"choices\"][0][\"finish_reason\"]\n            get_logger().debug(f\"\\nAI response:\\n{resp}\")\n\n            # log the full response for debugging\n            response_log = self.prepare_logs(response, system, user, resp, finish_reason)\n            get_logger().debug(\"Full_response\", artifact=response_log)\n\n            # for CLI debugging\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"\\nAI response:\\n{resp}\")\n\n        return resp, finish_reason",
    "start_line": 19,
    "end_line": 342,
    "has_docstring": true,
    "docstring": "This class handles interactions with the OpenAI API for chat completions.\nIt initializes the API key and other settings from a configuration file,\nand provides a method for performing chat completions using the OpenAI ChatCompletion API.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseAiHandler"
    ],
    "class_name": null,
    "display_name": "class LiteLLMAIHandler",
    "component_id": "pr_agent.algo.ai_handlers.litellm_ai_handler.LiteLLMAIHandler"
  },
  "pr_agent.algo.ai_handlers.openai_ai_handler.OpenAIHandler": {
    "id": "pr_agent.algo.ai_handlers.openai_ai_handler.OpenAIHandler",
    "name": "OpenAIHandler",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/ai_handlers/openai_ai_handler.py",
    "relative_path": "pr_agent/algo/ai_handlers/openai_ai_handler.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class OpenAIHandler(BaseAiHandler):\n    def __init__(self):\n        # Initialize OpenAIHandler specific attributes here\n        try:\n            super().__init__()\n            environ[\"OPENAI_API_KEY\"] = get_settings().ic_code.key\n            if get_settings().get(\"OPENAI.ORG\", None):\n                openai.organization = get_settings().openai.org\n            if get_settings().get(\"OPENAI.API_TYPE\", None):\n                if get_settings().openai.api_type == \"azure\":\n                    self.azure = True\n                    openai.azure_key = get_settings().openai.key\n            if get_settings().get(\"OPENAI.API_VERSION\", None):\n                openai.api_version = get_settings().openai.api_version\n            if get_settings().get(\"OPENAI.API_BASE\", None):\n                environ[\"OPENAI_BASE_URL\"] = get_settings().openai.api_base\n\n        except AttributeError as e:\n            raise ValueError(\"OpenAI key is required\") from e\n\n    @property\n    def deployment_id(self):\n        \"\"\"\n        Returns the deployment ID for the OpenAI API.\n        \"\"\"\n        return get_settings().get(\"OPENAI.DEPLOYMENT_ID\", None)\n\n    @retry(exceptions=(APIError, Timeout, AttributeError, RateLimitError),\n           tries=OPENAI_RETRIES, delay=2, backoff=2, jitter=(1, 3))\n    async def chat_completion(self, model: str, system: str, user: str, \n                              temperature: float = 0.2):\n        try:\n            get_logger().info(\"System: \", system)\n            get_logger().info(\"User: \", user)\n            messages = [{\"role\": \"user\", \"content\": system + \"\\n\" + user}]\n            client = AsyncOpenAI(\n                api_key=get_settings().ic_code.key,\n                base_url=get_settings().ic_code.base_url\n            )\n            \n            \n            chat_completion = await client.chat.completions.create(\n                model='ic_coding_assistant',\n                messages=messages,\n                temperature=temperature,\n                max_tokens=8000\n            )\n            \n            resp = chat_completion.choices[0].message.content\n            \n            finish_reason = chat_completion.choices[0].finish_reason\n            usage = chat_completion.usage\n            get_logger().info(\"AI response\", response=resp, messages=messages, finish_reason=finish_reason,\n                              model=model, usage=usage)\n            return resp, finish_reason\n        except (APIError, Timeout) as e:\n            get_logger().error(\"Error during OpenAI inference: \", e)\n            raise\n        except (RateLimitError) as e:\n            get_logger().error(\"Rate limit error during OpenAI inference: \", e)\n            raise\n        except (Exception) as e:\n            get_logger().error(\"Unknown error during OpenAI inference: \", e)\n            raise",
    "start_line": 14,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseAiHandler"
    ],
    "class_name": null,
    "display_name": "class OpenAIHandler",
    "component_id": "pr_agent.algo.ai_handlers.openai_ai_handler.OpenAIHandler"
  },
  "pr_agent.algo.cli_args.CliArgs": {
    "id": "pr_agent.algo.cli_args.CliArgs",
    "name": "CliArgs",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/cli_args.py",
    "relative_path": "pr_agent/algo/cli_args.py",
    "depends_on": [],
    "source_code": "class CliArgs:\n    @staticmethod\n    def validate_user_args(args: list) -> (bool, str):\n        try:\n            if not args:\n                return True, \"\"\n\n            # decode forbidden args\n            # b64encode('word'.encode()).decode()\n            _encoded_args = 'c2hhcmVkX3NlY3JldA==:dXNlcg==:c3lzdGVt:ZW5hYmxlX2NvbW1lbnRfYXBwcm92YWw=:ZW5hYmxlX21hbnVhbF9hcHByb3ZhbA==:ZW5hYmxlX2F1dG9fYXBwcm92YWw=:YXBwcm92ZV9wcl9vbl9zZWxmX3Jldmlldw==:YmFzZV91cmw=:dXJs:YXBwX25hbWU=:c2VjcmV0X3Byb3ZpZGVy:Z2l0X3Byb3ZpZGVy:c2tpcF9rZXlz:b3BlbmFpLmtleQ==:QU5BTFlUSUNTX0ZPTERFUg==:dXJp:YXBwX2lk:d2ViaG9va19zZWNyZXQ=:YmVhcmVyX3Rva2Vu:UEVSU09OQUxfQUNDRVNTX1RPS0VO:b3ZlcnJpZGVfZGVwbG95bWVudF90eXBl:cHJpdmF0ZV9rZXk=:bG9jYWxfY2FjaGVfcGF0aA==:ZW5hYmxlX2xvY2FsX2NhY2hl:amlyYV9iYXNlX3VybA==:YXBpX2Jhc2U=:YXBpX3R5cGU=:YXBpX3ZlcnNpb24=:c2tpcF9rZXlz'\n\n            forbidden_cli_args = []\n            for e in _encoded_args.split(':'):\n                forbidden_cli_args.append(b64decode(e).decode())\n\n            # lowercase all forbidden args\n            for i, _ in enumerate(forbidden_cli_args):\n                forbidden_cli_args[i] = forbidden_cli_args[i].lower()\n                if '.' not in forbidden_cli_args[i]:\n                    forbidden_cli_args[i] = '.' + forbidden_cli_args[i]\n\n            for arg in args:\n                if arg.startswith('--'):\n                    arg_word = arg.lower()\n                    arg_word = arg_word.replace('__', '.')  # replace double underscore with dot, e.g. --openai__key -> --openai.key\n                    for forbidden_arg_word in forbidden_cli_args:\n                        if forbidden_arg_word in arg_word:\n                            return False, forbidden_arg_word\n            return True, \"\"\n        except Exception as e:\n            return False, str(e)",
    "start_line": 4,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CliArgs",
    "component_id": "pr_agent.algo.cli_args.CliArgs"
  },
  "pr_agent.algo.file_filter.filter_ignored": {
    "id": "pr_agent.algo.file_filter.filter_ignored",
    "name": "filter_ignored",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/file_filter.py",
    "relative_path": "pr_agent/algo/file_filter.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def filter_ignored(files, platform = 'github'):\n    \"\"\"\n    Filter out files that match the ignore patterns.\n    \"\"\"\n\n    try:\n        # load regex patterns, and translate glob patterns to regex\n        patterns = get_settings().ignore.regex\n        if isinstance(patterns, str):\n            patterns = [patterns]\n        glob_setting = get_settings().ignore.glob\n        if isinstance(glob_setting, str):  # --ignore.glob=[.*utils.py], --ignore.glob=.*utils.py\n            glob_setting = glob_setting.strip('[]').split(\",\")\n        patterns += [fnmatch.translate(glob) for glob in glob_setting]\n\n        # compile all valid patterns\n        compiled_patterns = []\n        for r in patterns:\n            try:\n                compiled_patterns.append(re.compile(r))\n            except re.error:\n                pass\n\n        # keep filenames that _don't_ match the ignore regex\n        if files and isinstance(files, list):\n            for r in compiled_patterns:\n                if platform == 'github':\n                    files = [f for f in files if (f.filename and not r.match(f.filename))]\n                elif platform == 'bitbucket':\n                    # files = [f for f in files if (f.new.path and not r.match(f.new.path))]\n                    files_o = []\n                    for f in files:\n                        if hasattr(f, 'new'):\n                            if f.new and f.new.path and not r.match(f.new.path):\n                                files_o.append(f)\n                                continue\n                        if hasattr(f, 'old'):\n                            if f.old and f.old.path and not r.match(f.old.path):\n                                files_o.append(f)\n                                continue\n                    files = files_o\n                elif platform == 'gitlab' or platform == 'vnpt_scm':\n                    # files = [f for f in files if (f['new_path'] and not r.match(f['new_path']))]\n                    files_o = []\n                    for f in files:\n                        if 'new_path' in f and f['new_path'] and not r.match(f['new_path']):\n                            files_o.append(f)\n                            continue\n                        if 'old_path' in f and f['old_path'] and not r.match(f['old_path']):\n                            files_o.append(f)\n                            continue\n                    files = files_o\n                elif platform == 'azure':\n                    files = [f for f in files if not r.match(f)]\n\n    except Exception as e:\n        print(f\"Could not filter file list: {e}\")\n\n    return files",
    "start_line": 7,
    "end_line": 65,
    "has_docstring": true,
    "docstring": "Filter out files that match the ignore patterns.",
    "parameters": [
      "files",
      "platform"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function filter_ignored",
    "component_id": "pr_agent.algo.file_filter.filter_ignored"
  },
  "pr_agent.algo.git_patch_processing.extend_patch": {
    "id": "pr_agent.algo.git_patch_processing.extend_patch",
    "name": "extend_patch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.git_patch_processing.should_skip_patch",
      "pr_agent.algo.git_patch_processing.decode_if_bytes",
      "pr_agent.algo.git_patch_processing.process_patch_lines"
    ],
    "source_code": "def extend_patch(original_file_str, patch_str, patch_extra_lines_before=0,\n                 patch_extra_lines_after=0, filename: str = \"\", new_file_str=\"\") -> str:\n    if not patch_str or (patch_extra_lines_before == 0 and patch_extra_lines_after == 0) or not original_file_str:\n        return patch_str\n\n    original_file_str = decode_if_bytes(original_file_str)\n    new_file_str = decode_if_bytes(new_file_str)\n    if not original_file_str:\n        return patch_str\n\n    if should_skip_patch(filename):\n        return patch_str\n\n    try:\n        extended_patch_str = process_patch_lines(patch_str, original_file_str,\n                                                 patch_extra_lines_before, patch_extra_lines_after, new_file_str)\n    except Exception as e:\n        get_logger().warning(f\"Failed to extend patch: {e}\", artifact={\"traceback\": traceback.format_exc()})\n        return patch_str\n\n    return extended_patch_str",
    "start_line": 11,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "original_file_str",
      "patch_str",
      "patch_extra_lines_before",
      "patch_extra_lines_after",
      "filename",
      "new_file_str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extend_patch",
    "component_id": "pr_agent.algo.git_patch_processing.extend_patch"
  },
  "pr_agent.algo.git_patch_processing.decode_if_bytes": {
    "id": "pr_agent.algo.git_patch_processing.decode_if_bytes",
    "name": "decode_if_bytes",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [],
    "source_code": "def decode_if_bytes(original_file_str):\n    if isinstance(original_file_str, (bytes, bytearray)):\n        try:\n            return original_file_str.decode('utf-8')\n        except UnicodeDecodeError:\n            encodings_to_try = ['iso-8859-1', 'latin-1', 'ascii', 'utf-16']\n            for encoding in encodings_to_try:\n                try:\n                    return original_file_str.decode(encoding)\n                except UnicodeDecodeError:\n                    continue\n            return \"\"\n    return original_file_str",
    "start_line": 34,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "original_file_str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function decode_if_bytes",
    "component_id": "pr_agent.algo.git_patch_processing.decode_if_bytes"
  },
  "pr_agent.algo.git_patch_processing.should_skip_patch": {
    "id": "pr_agent.algo.git_patch_processing.should_skip_patch",
    "name": "should_skip_patch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def should_skip_patch(filename):\n    patch_extension_skip_types = get_settings().config.patch_extension_skip_types\n    if patch_extension_skip_types and filename:\n        return any(filename.endswith(skip_type) for skip_type in patch_extension_skip_types)\n    return False",
    "start_line": 49,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function should_skip_patch",
    "component_id": "pr_agent.algo.git_patch_processing.should_skip_patch"
  },
  "pr_agent.algo.git_patch_processing.process_patch_lines": {
    "id": "pr_agent.algo.git_patch_processing.process_patch_lines",
    "name": "process_patch_lines",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.algo.git_patch_processing.extract_hunk_headers",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.git_patch_processing.check_if_hunk_lines_matches_to_file"
    ],
    "source_code": "def process_patch_lines(patch_str, original_file_str, patch_extra_lines_before, patch_extra_lines_after, new_file_str=\"\"):\n    allow_dynamic_context = get_settings().config.allow_dynamic_context\n    patch_extra_lines_before_dynamic = get_settings().config.max_extra_lines_before_dynamic_context\n\n    file_original_lines = original_file_str.splitlines()\n    file_new_lines = new_file_str.splitlines() if new_file_str else []\n    len_original_lines = len(file_original_lines)\n    patch_lines = patch_str.splitlines()\n    extended_patch_lines = []\n\n    is_valid_hunk = True\n    start1, size1, start2, size2 = -1, -1, -1, -1\n    RE_HUNK_HEADER = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n    try:\n        for i,line in enumerate(patch_lines):\n            if line.startswith('@@'):\n                match = RE_HUNK_HEADER.match(line)\n                # identify hunk header\n                if match:\n                    # finish processing previous hunk\n                    if is_valid_hunk and (start1 != -1 and patch_extra_lines_after > 0):\n                        delta_lines_original = [f' {line}' for line in file_original_lines[start1 + size1 - 1:start1 + size1 - 1 + patch_extra_lines_after]]\n                        extended_patch_lines.extend(delta_lines_original)\n\n                    section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n\n                    is_valid_hunk = check_if_hunk_lines_matches_to_file(i, file_original_lines, patch_lines, start1)\n\n                    if is_valid_hunk and (patch_extra_lines_before > 0 or patch_extra_lines_after > 0):\n                        def _calc_context_limits(patch_lines_before):\n                            extended_start1 = max(1, start1 - patch_lines_before)\n                            extended_size1 = size1 + (start1 - extended_start1) + patch_extra_lines_after\n                            extended_start2 = max(1, start2 - patch_lines_before)\n                            extended_size2 = size2 + (start2 - extended_start2) + patch_extra_lines_after\n                            if extended_start1 - 1 + extended_size1 > len_original_lines:\n                                # we cannot extend beyond the original file\n                                delta_cap = extended_start1 - 1 + extended_size1 - len_original_lines\n                                extended_size1 = max(extended_size1 - delta_cap, size1)\n                                extended_size2 = max(extended_size2 - delta_cap, size2)\n                            return extended_start1, extended_size1, extended_start2, extended_size2\n\n                        if allow_dynamic_context and file_new_lines:\n                            extended_start1, extended_size1, extended_start2, extended_size2 = \\\n                                _calc_context_limits(patch_extra_lines_before_dynamic)\n\n                            lines_before_original = file_original_lines[extended_start1 - 1:start1 - 1]\n                            lines_before_new = file_new_lines[extended_start2 - 1:start2 - 1]\n                            found_header = False\n                            if lines_before_original == lines_before_new: # Making sure no changes from a previous hunk\n                                for i, line, in enumerate(lines_before_original):\n                                    if section_header in line:\n                                        found_header = True\n                                        # Update start and size in one line each\n                                        extended_start1, extended_start2 = extended_start1 + i, extended_start2 + i\n                                        extended_size1, extended_size2 = extended_size1 - i, extended_size2 - i\n                                        # get_logger().debug(f\"Found section header in line {i} before the hunk\")\n                                        section_header = ''\n                                        break\n                            else:\n                                get_logger().debug(f\"Extra lines before hunk are different in original and new file - dynamic context\",\n                                                   artifact={\"lines_before_original\": lines_before_original,\n                                                             \"lines_before_new\": lines_before_new})\n\n                            if not found_header:\n                                # get_logger().debug(f\"Section header not found in the extra lines before the hunk\")\n                                extended_start1, extended_size1, extended_start2, extended_size2 = \\\n                                    _calc_context_limits(patch_extra_lines_before)\n                        else:\n                            extended_start1, extended_size1, extended_start2, extended_size2 = \\\n                                _calc_context_limits(patch_extra_lines_before)\n\n                        # check if extra lines before hunk are different in original and new file\n                        delta_lines_original = [f' {line}' for line in file_original_lines[extended_start1 - 1:start1 - 1]]\n                        if file_new_lines:\n                            delta_lines_new = [f' {line}' for line in file_new_lines[extended_start2 - 1:start2 - 1]]\n                            if delta_lines_original != delta_lines_new:\n                                get_logger().debug(f\"Extra lines before hunk are different in original and new file\",\n                                                   artifact={\"delta_lines_original\": delta_lines_original,\n                                                             \"delta_lines_new\": delta_lines_new})\n                                extended_start1 = start1\n                                extended_size1 = size1\n                                extended_start2 = start2\n                                extended_size2 = size2\n                                delta_lines_original = []\n\n                        #  logic to remove section header if its in the extra delta lines (in dynamic context, this is also done)\n                        if section_header and not allow_dynamic_context:\n                            for line in delta_lines_original:\n                                if section_header in line:\n                                    section_header = ''  # remove section header if it is in the extra delta lines\n                                    break\n                    else:\n                        extended_start1 = start1\n                        extended_size1 = size1\n                        extended_start2 = start2\n                        extended_size2 = size2\n                        delta_lines_original = []\n                    extended_patch_lines.append('')\n                    extended_patch_lines.append(\n                        f'@@ -{extended_start1},{extended_size1} '\n                        f'+{extended_start2},{extended_size2} @@ {section_header}')\n                    extended_patch_lines.extend(delta_lines_original)  # one to zero based\n                    continue\n            extended_patch_lines.append(line)\n    except Exception as e:\n        get_logger().warning(f\"Failed to extend patch: {e}\", artifact={\"traceback\": traceback.format_exc()})\n        return patch_str\n\n    # finish processing last hunk\n    if start1 != -1 and patch_extra_lines_after > 0 and is_valid_hunk:\n        delta_lines_original = file_original_lines[start1 + size1 - 1:start1 + size1 - 1 + patch_extra_lines_after]\n        # add space at the beginning of each extra line\n        delta_lines_original = [f' {line}' for line in delta_lines_original]\n        extended_patch_lines.extend(delta_lines_original)\n\n    extended_patch_str = '\\n'.join(extended_patch_lines)\n    return extended_patch_str",
    "start_line": 56,
    "end_line": 173,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "patch_str",
      "original_file_str",
      "patch_extra_lines_before",
      "patch_extra_lines_after",
      "new_file_str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_patch_lines",
    "component_id": "pr_agent.algo.git_patch_processing.process_patch_lines"
  },
  "pr_agent.algo.git_patch_processing._calc_context_limits": {
    "id": "pr_agent.algo.git_patch_processing._calc_context_limits",
    "name": "_calc_context_limits",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [],
    "source_code": "                        def _calc_context_limits(patch_lines_before):\n                            extended_start1 = max(1, start1 - patch_lines_before)\n                            extended_size1 = size1 + (start1 - extended_start1) + patch_extra_lines_after\n                            extended_start2 = max(1, start2 - patch_lines_before)\n                            extended_size2 = size2 + (start2 - extended_start2) + patch_extra_lines_after\n                            if extended_start1 - 1 + extended_size1 > len_original_lines:\n                                # we cannot extend beyond the original file\n                                delta_cap = extended_start1 - 1 + extended_size1 - len_original_lines\n                                extended_size1 = max(extended_size1 - delta_cap, size1)\n                                extended_size2 = max(extended_size2 - delta_cap, size2)\n                            return extended_start1, extended_size1, extended_start2, extended_size2",
    "start_line": 86,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "patch_lines_before"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _calc_context_limits",
    "component_id": "pr_agent.algo.git_patch_processing._calc_context_limits"
  },
  "pr_agent.algo.git_patch_processing.check_if_hunk_lines_matches_to_file": {
    "id": "pr_agent.algo.git_patch_processing.check_if_hunk_lines_matches_to_file",
    "name": "check_if_hunk_lines_matches_to_file",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def check_if_hunk_lines_matches_to_file(i, original_lines, patch_lines, start1):\n    \"\"\"\n    Check if the hunk lines match the original file content. We saw cases where the hunk header line doesn't match the original file content, and then\n    extending the hunk with extra lines before the hunk header can cause the hunk to be invalid.\n    \"\"\"\n    is_valid_hunk = True\n    try:\n        if i + 1 < len(patch_lines) and patch_lines[i + 1][0] == ' ': # an existing line in the file\n            if patch_lines[i + 1].strip() != original_lines[start1 - 1].strip():\n                # check if different encoding is needed\n                original_line = original_lines[start1 - 1].strip()\n                for encoding in ['iso-8859-1', 'latin-1', 'ascii', 'utf-16']:\n                    try:\n                        if original_line.encode(encoding).decode().strip() == patch_lines[i + 1].strip():\n                            get_logger().info(f\"Detected different encoding in hunk header line {start1}, needed encoding: {encoding}\")\n                            return False # we still want to avoid extending the hunk. But we don't want to log an error\n                    except:\n                        pass\n\n                is_valid_hunk = False\n                get_logger().info(\n                    f\"Invalid hunk in PR, line {start1} in hunk header doesn't match the original file content\")\n    except:\n        pass\n    return is_valid_hunk",
    "start_line": 175,
    "end_line": 199,
    "has_docstring": true,
    "docstring": "Check if the hunk lines match the original file content. We saw cases where the hunk header line doesn't match the original file content, and then\nextending the hunk with extra lines before the hunk header can cause the hunk to be invalid.",
    "parameters": [
      "i",
      "original_lines",
      "patch_lines",
      "start1"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function check_if_hunk_lines_matches_to_file",
    "component_id": "pr_agent.algo.git_patch_processing.check_if_hunk_lines_matches_to_file"
  },
  "pr_agent.algo.git_patch_processing.extract_hunk_headers": {
    "id": "pr_agent.algo.git_patch_processing.extract_hunk_headers",
    "name": "extract_hunk_headers",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [],
    "source_code": "def extract_hunk_headers(match):\n    res = list(match.groups())\n    for i in range(len(res)):\n        if res[i] is None:\n            res[i] = 0\n    try:\n        start1, size1, start2, size2 = map(int, res[:4])\n    except:  # '@@ -0,0 +1 @@' case\n        start1, size1, size2 = map(int, res[:3])\n        start2 = 0\n    section_header = res[4]\n    return section_header, size1, size2, start1, start2",
    "start_line": 202,
    "end_line": 213,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "match"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_hunk_headers",
    "component_id": "pr_agent.algo.git_patch_processing.extract_hunk_headers"
  },
  "pr_agent.algo.git_patch_processing.omit_deletion_hunks": {
    "id": "pr_agent.algo.git_patch_processing.omit_deletion_hunks",
    "name": "omit_deletion_hunks",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [],
    "source_code": "def omit_deletion_hunks(patch_lines) -> str:\n    \"\"\"\n    Omit deletion hunks from the patch and return the modified patch.\n    Args:\n    - patch_lines: a list of strings representing the lines of the patch\n    Returns:\n    - A string representing the modified patch with deletion hunks omitted\n    \"\"\"\n\n    temp_hunk = []\n    added_patched = []\n    add_hunk = False\n    inside_hunk = False\n    RE_HUNK_HEADER = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))?\\ @@[ ]?(.*)\")\n\n    for line in patch_lines:\n        if line.startswith('@@'):\n            match = RE_HUNK_HEADER.match(line)\n            if match:\n                # finish previous hunk\n                if inside_hunk and add_hunk:\n                    added_patched.extend(temp_hunk)\n                    temp_hunk = []\n                    add_hunk = False\n                temp_hunk.append(line)\n                inside_hunk = True\n        else:\n            temp_hunk.append(line)\n            if line:\n                edit_type = line[0]\n                if edit_type == '+':\n                    add_hunk = True\n    if inside_hunk and add_hunk:\n        added_patched.extend(temp_hunk)\n\n    return '\\n'.join(added_patched)",
    "start_line": 216,
    "end_line": 252,
    "has_docstring": true,
    "docstring": "Omit deletion hunks from the patch and return the modified patch.\nArgs:\n- patch_lines: a list of strings representing the lines of the patch\nReturns:\n- A string representing the modified patch with deletion hunks omitted",
    "parameters": [
      "patch_lines"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function omit_deletion_hunks",
    "component_id": "pr_agent.algo.git_patch_processing.omit_deletion_hunks"
  },
  "pr_agent.algo.git_patch_processing.handle_patch_deletions": {
    "id": "pr_agent.algo.git_patch_processing.handle_patch_deletions",
    "name": "handle_patch_deletions",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.git_patch_processing.omit_deletion_hunks",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def handle_patch_deletions(patch: str, original_file_content_str: str,\n                           new_file_content_str: str, file_name: str, edit_type: EDIT_TYPE = EDIT_TYPE.UNKNOWN) -> str:\n    \"\"\"\n    Handle entire file or deletion patches.\n\n    This function takes a patch, original file content, new file content, and file name as input.\n    It handles entire file or deletion patches and returns the modified patch with deletion hunks omitted.\n\n    Args:\n        patch (str): The patch to be handled.\n        original_file_content_str (str): The original content of the file.\n        new_file_content_str (str): The new content of the file.\n        file_name (str): The name of the file.\n\n    Returns:\n        str: The modified patch with deletion hunks omitted.\n\n    \"\"\"\n    if not new_file_content_str and (edit_type == EDIT_TYPE.DELETED or edit_type == EDIT_TYPE.UNKNOWN):\n        # logic for handling deleted files - don't show patch, just show that the file was deleted\n        if get_settings().config.verbosity_level > 0:\n            get_logger().info(f\"Processing file: {file_name}, minimizing deletion file\")\n        patch = None # file was deleted\n    else:\n        patch_lines = patch.splitlines()\n        patch_new = omit_deletion_hunks(patch_lines)\n        if patch != patch_new:\n            if get_settings().config.verbosity_level > 0:\n                get_logger().info(f\"Processing file: {file_name}, hunks were deleted\")\n            patch = patch_new\n    return patch",
    "start_line": 255,
    "end_line": 285,
    "has_docstring": true,
    "docstring": "Handle entire file or deletion patches.\n\nThis function takes a patch, original file content, new file content, and file name as input.\nIt handles entire file or deletion patches and returns the modified patch with deletion hunks omitted.\n\nArgs:\n    patch (str): The patch to be handled.\n    original_file_content_str (str): The original content of the file.\n    new_file_content_str (str): The new content of the file.\n    file_name (str): The name of the file.\n\nReturns:\n    str: The modified patch with deletion hunks omitted.",
    "parameters": [
      "patch",
      "original_file_content_str",
      "new_file_content_str",
      "file_name",
      "edit_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_patch_deletions",
    "component_id": "pr_agent.algo.git_patch_processing.handle_patch_deletions"
  },
  "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers": {
    "id": "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers",
    "name": "decouple_and_convert_to_hunks_with_lines_numbers",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.algo.git_patch_processing.extract_hunk_headers"
    ],
    "source_code": "def decouple_and_convert_to_hunks_with_lines_numbers(patch: str, file) -> str:\n    \"\"\"\n    Convert a given patch string into a string with line numbers for each hunk, indicating the new and old content of\n    the file.\n\n    Args:\n        patch (str): The patch string to be converted.\n        file: An object containing the filename of the file being patched.\n\n    Returns:\n        str: A string with line numbers for each hunk, indicating the new and old content of the file.\n\n    example output:\n## src/file.ts\n__new hunk__\n881        line1\n882        line2\n883        line3\n887 +      line4\n888 +      line5\n889        line6\n890        line7\n...\n__old hunk__\n        line1\n        line2\n-       line3\n-       line4\n        line5\n        line6\n           ...\n    \"\"\"\n\n    # Add a header for the file\n    if file:\n        # if the file was deleted, return a message indicating that the file was deleted\n        if hasattr(file, 'edit_type') and file.edit_type == EDIT_TYPE.DELETED:\n            return f\"\\n\\n## File '{file.filename.strip()}' was deleted\\n\"\n\n        patch_with_lines_str = f\"\\n\\n## File: '{file.filename.strip()}'\\n\"\n    else:\n        patch_with_lines_str = \"\"\n\n    patch_lines = patch.splitlines()\n    RE_HUNK_HEADER = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n    new_content_lines = []\n    old_content_lines = []\n    match = None\n    start1, size1, start2, size2 = -1, -1, -1, -1\n    prev_header_line = []\n    header_line = []\n    for line_i, line in enumerate(patch_lines):\n        if 'no newline at end of file' in line.lower():\n            continue\n\n        if line.startswith('@@'):\n            header_line = line\n            match = RE_HUNK_HEADER.match(line)\n            if match and (new_content_lines or old_content_lines):  # found a new hunk, split the previous lines\n                if prev_header_line:\n                    patch_with_lines_str += f'\\n{prev_header_line}\\n'\n                is_plus_lines = is_minus_lines = False\n                if new_content_lines:\n                    is_plus_lines = any([line.startswith('+') for line in new_content_lines])\n                if old_content_lines:\n                    is_minus_lines = any([line.startswith('-') for line in old_content_lines])\n                if is_plus_lines or is_minus_lines: # notice 'True' here - we always present __new hunk__ for section, otherwise LLM gets confused\n                    patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__new hunk__\\n'\n                    for i, line_new in enumerate(new_content_lines):\n                        patch_with_lines_str += f\"{start2 + i} {line_new}\\n\"\n                if is_minus_lines:\n                    patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__old hunk__\\n'\n                    for line_old in old_content_lines:\n                        patch_with_lines_str += f\"{line_old}\\n\"\n                new_content_lines = []\n                old_content_lines = []\n            if match:\n                prev_header_line = header_line\n\n            section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n\n        elif line.startswith('+'):\n            new_content_lines.append(line)\n        elif line.startswith('-'):\n            old_content_lines.append(line)\n        else:\n            if not line and line_i: # if this line is empty and the next line is a hunk header, skip it\n                if line_i + 1 < len(patch_lines) and patch_lines[line_i + 1].startswith('@@'):\n                    continue\n                elif line_i + 1 == len(patch_lines):\n                    continue\n            new_content_lines.append(line)\n            old_content_lines.append(line)\n\n    # finishing last hunk\n    if match and new_content_lines:\n        patch_with_lines_str += f'\\n{header_line}\\n'\n        is_plus_lines = is_minus_lines = False\n        if new_content_lines:\n            is_plus_lines = any([line.startswith('+') for line in new_content_lines])\n        if old_content_lines:\n            is_minus_lines = any([line.startswith('-') for line in old_content_lines])\n        if is_plus_lines or is_minus_lines:  # notice 'True' here - we always present __new hunk__ for section, otherwise LLM gets confused\n            patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__new hunk__\\n'\n            for i, line_new in enumerate(new_content_lines):\n                patch_with_lines_str += f\"{start2 + i} {line_new}\\n\"\n        if is_minus_lines:\n            patch_with_lines_str = patch_with_lines_str.rstrip() + '\\n__old hunk__\\n'\n            for line_old in old_content_lines:\n                patch_with_lines_str += f\"{line_old}\\n\"\n\n    return patch_with_lines_str.rstrip()",
    "start_line": 288,
    "end_line": 400,
    "has_docstring": true,
    "docstring": "    Convert a given patch string into a string with line numbers for each hunk, indicating the new and old content of\n    the file.\n\n    Args:\n        patch (str): The patch string to be converted.\n        file: An object containing the filename of the file being patched.\n\n    Returns:\n        str: A string with line numbers for each hunk, indicating the new and old content of the file.\n\n    example output:\n## src/file.ts\n__new hunk__\n881        line1\n882        line2\n883        line3\n887 +      line4\n888 +      line5\n889        line6\n890        line7\n...\n__old hunk__\n        line1\n        line2\n-       line3\n-       line4\n        line5\n        line6\n           ...\n    ",
    "parameters": [
      "patch",
      "file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function decouple_and_convert_to_hunks_with_lines_numbers",
    "component_id": "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers"
  },
  "pr_agent.algo.git_patch_processing.extract_hunk_lines_from_patch": {
    "id": "pr_agent.algo.git_patch_processing.extract_hunk_lines_from_patch",
    "name": "extract_hunk_lines_from_patch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/git_patch_processing.py",
    "relative_path": "pr_agent/algo/git_patch_processing.py",
    "depends_on": [
      "pr_agent.algo.git_patch_processing.extract_hunk_headers",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def extract_hunk_lines_from_patch(patch: str, file_name, line_start, line_end, side, remove_trailing_chars: bool = True) -> tuple[str, str]:\n    try:\n        patch_with_lines_str = f\"\\n\\n## File: '{file_name.strip()}'\\n\\n\"\n        selected_lines = \"\"\n        patch_lines = patch.splitlines()\n        RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n        match = None\n        start1, size1, start2, size2 = -1, -1, -1, -1\n        skip_hunk = False\n        selected_lines_num = 0\n        for line in patch_lines:\n            if 'no newline at end of file' in line.lower():\n                continue\n\n            if line.startswith('@@'):\n                skip_hunk = False\n                selected_lines_num = 0\n                header_line = line\n\n                match = RE_HUNK_HEADER.match(line)\n\n                section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n\n                # check if line range is in this hunk\n                if side.lower() == 'left':\n                    # check if line range is in this hunk\n                    if not (start1 <= line_start <= start1 + size1):\n                        skip_hunk = True\n                        continue\n                elif side.lower() == 'right':\n                    if not (start2 <= line_start <= start2 + size2):\n                        skip_hunk = True\n                        continue\n                patch_with_lines_str += f'\\n{header_line}\\n'\n\n            elif not skip_hunk:\n                if side.lower() == 'right' and line_start <= start2 + selected_lines_num <= line_end:\n                    selected_lines += line + '\\n'\n                if side.lower() == 'left' and start1 <= selected_lines_num + start1 <= line_end:\n                    selected_lines += line + '\\n'\n                patch_with_lines_str += line + '\\n'\n                if not line.startswith('-'): # currently we don't support /ask line for deleted lines\n                    selected_lines_num += 1\n    except Exception as e:\n        get_logger().error(f\"Failed to extract hunk lines from patch: {e}\", artifact={\"traceback\": traceback.format_exc()})\n        return \"\", \"\"\n\n    if remove_trailing_chars:\n        patch_with_lines_str = patch_with_lines_str.rstrip()\n        selected_lines = selected_lines.rstrip()\n\n    return patch_with_lines_str, selected_lines",
    "start_line": 403,
    "end_line": 455,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "patch",
      "file_name",
      "line_start",
      "line_end",
      "side",
      "remove_trailing_chars"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_hunk_lines_from_patch",
    "component_id": "pr_agent.algo.git_patch_processing.extract_hunk_lines_from_patch"
  },
  "pr_agent.algo.language_handler.filter_bad_extensions": {
    "id": "pr_agent.algo.language_handler.filter_bad_extensions",
    "name": "filter_bad_extensions",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/language_handler.py",
    "relative_path": "pr_agent/algo/language_handler.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "def filter_bad_extensions(files):\n    # Bad Extensions, source: https://github.com/EleutherAI/github-downloader/blob/345e7c4cbb9e0dc8a0615fd995a08bf9d73b3fe6/download_repo_text.py  # noqa: E501\n    bad_extensions = get_settings().bad_extensions.default\n    if get_settings().config.use_extra_bad_extensions:\n        bad_extensions += get_settings().bad_extensions.extra\n    return [f for f in files if f.filename is not None and is_valid_file(f.filename, bad_extensions)]",
    "start_line": 7,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function filter_bad_extensions",
    "component_id": "pr_agent.algo.language_handler.filter_bad_extensions"
  },
  "pr_agent.algo.language_handler.is_valid_file": {
    "id": "pr_agent.algo.language_handler.is_valid_file",
    "name": "is_valid_file",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/language_handler.py",
    "relative_path": "pr_agent/algo/language_handler.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def is_valid_file(filename:str, bad_extensions=None) -> bool:\n    if not filename:\n        return False\n    if not bad_extensions:\n        bad_extensions = get_settings().bad_extensions.default\n        if get_settings().config.use_extra_bad_extensions:\n            bad_extensions += get_settings().bad_extensions.extra\n\n    auto_generated_files = ['package-lock.json', 'yarn.lock', 'composer.lock', 'Gemfile.lock', 'poetry.lock']\n    for forbidden_file in auto_generated_files:\n        if filename.endswith(forbidden_file):\n            return False\n\n    return filename.split('.')[-1] not in bad_extensions",
    "start_line": 15,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "filename",
      "bad_extensions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_valid_file",
    "component_id": "pr_agent.algo.language_handler.is_valid_file"
  },
  "pr_agent.algo.language_handler.sort_files_by_main_languages": {
    "id": "pr_agent.algo.language_handler.sort_files_by_main_languages",
    "name": "sort_files_by_main_languages",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/language_handler.py",
    "relative_path": "pr_agent/algo/language_handler.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.language_handler.filter_bad_extensions"
    ],
    "source_code": "def sort_files_by_main_languages(languages: Dict, files: list):\n    \"\"\"\n    Sort files by their main language, put the files that are in the main language first and the rest files after\n    \"\"\"\n    # sort languages by their size\n    languages_sorted_list = [k for k, v in sorted(languages.items(), key=lambda item: item[1], reverse=True)]\n    # languages_sorted = sorted(languages, key=lambda x: x[1], reverse=True)\n    # get all extensions for the languages\n    main_extensions = []\n    language_extension_map_org = get_settings().language_extension_map_org\n    language_extension_map = {k.lower(): v for k, v in language_extension_map_org.items()}\n    for language in languages_sorted_list:\n        if language.lower() in language_extension_map:\n            main_extensions.append(language_extension_map[language.lower()])\n        else:\n            main_extensions.append([])\n\n    # filter out files bad extensions\n    files_filtered = filter_bad_extensions(files)\n\n    # sort files by their extension, put the files that are in the main extension first\n    # and the rest files after, map languages_sorted to their respective files\n    files_sorted = []\n    rest_files = {}\n\n    # if no languages detected, put all files in the \"Other\" category\n    if not languages:\n        files_sorted = [({\"language\": \"Other\", \"files\": list(files_filtered)})]\n        return files_sorted\n\n    main_extensions_flat = []\n    for ext in main_extensions:\n        main_extensions_flat.extend(ext)\n\n    for extensions, lang in zip(main_extensions, languages_sorted_list):  # noqa: B905\n        tmp = []\n        for file in files_filtered:\n            extension_str = f\".{file.filename.split('.')[-1]}\"\n            if extension_str in extensions:\n                tmp.append(file)\n            else:\n                if (file.filename not in rest_files) and (extension_str not in main_extensions_flat):\n                    rest_files[file.filename] = file\n        if len(tmp) > 0:\n            files_sorted.append({\"language\": lang, \"files\": tmp})\n    files_sorted.append({\"language\": \"Other\", \"files\": list(rest_files.values())})\n    return files_sorted",
    "start_line": 31,
    "end_line": 77,
    "has_docstring": true,
    "docstring": "Sort files by their main language, put the files that are in the main language first and the rest files after",
    "parameters": [
      "languages",
      "files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sort_files_by_main_languages",
    "component_id": "pr_agent.algo.language_handler.sort_files_by_main_languages"
  },
  "pr_agent.algo.pr_processing.cap_and_log_extra_lines": {
    "id": "pr_agent.algo.pr_processing.cap_and_log_extra_lines",
    "name": "cap_and_log_extra_lines",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def cap_and_log_extra_lines(value, direction) -> int:\n    if value > MAX_EXTRA_LINES:\n        get_logger().warning(f\"patch_extra_lines_{direction} was {value}, capping to {MAX_EXTRA_LINES}\")\n        return MAX_EXTRA_LINES\n    return value",
    "start_line": 31,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value",
      "direction"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cap_and_log_extra_lines",
    "component_id": "pr_agent.algo.pr_processing.cap_and_log_extra_lines"
  },
  "pr_agent.algo.pr_processing.get_pr_diff": {
    "id": "pr_agent.algo.pr_processing.get_pr_diff",
    "name": "get_pr_diff",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.algo.pr_processing.pr_generate_extended_diff",
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.algo.language_handler.sort_files_by_main_languages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.algo.pr_processing.cap_and_log_extra_lines",
      "pr_agent.algo.pr_processing.pr_generate_compressed_diff",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def get_pr_diff(git_provider: GitProvider, token_handler: TokenHandler,\n                model: str,\n                add_line_numbers_to_hunks: bool = False,\n                disable_extra_lines: bool = False,\n                large_pr_handling=False,\n                return_remaining_files=False):\n    if disable_extra_lines:\n        PATCH_EXTRA_LINES_BEFORE = 0\n        PATCH_EXTRA_LINES_AFTER = 0\n    else:\n        PATCH_EXTRA_LINES_BEFORE = get_settings().config.patch_extra_lines_before\n        PATCH_EXTRA_LINES_AFTER = get_settings().config.patch_extra_lines_after\n        PATCH_EXTRA_LINES_BEFORE = cap_and_log_extra_lines(PATCH_EXTRA_LINES_BEFORE, \"before\")\n        PATCH_EXTRA_LINES_AFTER = cap_and_log_extra_lines(PATCH_EXTRA_LINES_AFTER, \"after\")\n\n    try:\n        diff_files = git_provider.get_diff_files()\n    except RateLimitExceededException as e:\n        get_logger().error(f\"Rate limit exceeded for git provider API. original message {e}\")\n        raise\n\n    # get pr languages\n    pr_languages = sort_files_by_main_languages(git_provider.get_languages(), diff_files)\n    if pr_languages:\n        try:\n            get_logger().info(f\"PR main language: {pr_languages[0]['language']}\")\n        except Exception as e:\n            pass\n\n    # generate a standard diff string, with patch extension\n    patches_extended, total_tokens, patches_extended_tokens = pr_generate_extended_diff(\n        pr_languages, token_handler, add_line_numbers_to_hunks,\n        patch_extra_lines_before=PATCH_EXTRA_LINES_BEFORE, patch_extra_lines_after=PATCH_EXTRA_LINES_AFTER)\n\n    # if we are under the limit, return the full diff\n    if total_tokens + OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD < get_max_tokens(model):\n        get_logger().info(f\"Tokens: {total_tokens}, total tokens under limit: {get_max_tokens(model)}, \"\n                          f\"returning full diff.\")\n        return \"\\n\".join(patches_extended)\n\n    # if we are over the limit, start pruning (If we got here, we will not extend the patches with extra lines)\n    get_logger().info(f\"Tokens: {total_tokens}, total tokens over limit: {get_max_tokens(model)}, \"\n                      f\"pruning diff.\")\n    patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list = \\\n        pr_generate_compressed_diff(pr_languages, token_handler, model, add_line_numbers_to_hunks, large_pr_handling)\n\n    if large_pr_handling and len(patches_compressed_list) > 1:\n        get_logger().info(f\"Large PR handling mode, and found {len(patches_compressed_list)} patches with original diff.\")\n        return \"\" # return empty string, as we want to generate multiple patches with a different prompt\n\n    # return the first patch\n    patches_compressed = patches_compressed_list[0]\n    total_tokens_new = total_tokens_list[0]\n    files_in_patch = files_in_patches_list[0]\n\n    # Insert additional information about added, modified, and deleted files if there is enough space\n    max_tokens = get_max_tokens(model) - OUTPUT_BUFFER_TOKENS_HARD_THRESHOLD\n    curr_token = total_tokens_new  # == token_handler.count_tokens(final_diff)+token_handler.prompt_tokens\n    final_diff = \"\\n\".join(patches_compressed)\n    delta_tokens = 10\n    added_list_str = modified_list_str = deleted_list_str = \"\"\n    unprocessed_files = []\n    # generate the added, modified, and deleted files lists\n    if (max_tokens - curr_token) > delta_tokens:\n        for filename, file_values in file_dict.items():\n            if filename in files_in_patch:\n                continue\n            if file_values['edit_type'] == EDIT_TYPE.ADDED:\n                unprocessed_files.append(filename)\n                if not added_list_str:\n                    added_list_str = ADDED_FILES_ + f\"\\n{filename}\"\n                else:\n                    added_list_str = added_list_str + f\"\\n{filename}\"\n            elif file_values['edit_type'] in [EDIT_TYPE.MODIFIED, EDIT_TYPE.RENAMED]:\n                unprocessed_files.append(filename)\n                if not modified_list_str:\n                    modified_list_str = MORE_MODIFIED_FILES_ + f\"\\n{filename}\"\n                else:\n                    modified_list_str = modified_list_str + f\"\\n{filename}\"\n            elif file_values['edit_type'] == EDIT_TYPE.DELETED:\n                # unprocessed_files.append(filename) # not needed here, because the file was deleted, so no need to process it\n                if not deleted_list_str:\n                    deleted_list_str = DELETED_FILES_ + f\"\\n{filename}\"\n                else:\n                    deleted_list_str = deleted_list_str + f\"\\n{filename}\"\n\n    # prune the added, modified, and deleted files lists, and add them to the final diff\n    added_list_str = clip_tokens(added_list_str, max_tokens - curr_token)\n    if added_list_str:\n        final_diff = final_diff + \"\\n\\n\" + added_list_str\n        curr_token += token_handler.count_tokens(added_list_str) + 2\n    modified_list_str = clip_tokens(modified_list_str, max_tokens - curr_token)\n    if modified_list_str:\n        final_diff = final_diff + \"\\n\\n\" + modified_list_str\n        curr_token += token_handler.count_tokens(modified_list_str) + 2\n    deleted_list_str = clip_tokens(deleted_list_str, max_tokens - curr_token)\n    if deleted_list_str:\n        final_diff = final_diff + \"\\n\\n\" + deleted_list_str\n\n    get_logger().debug(f\"After pruning, added_list_str: {added_list_str}, modified_list_str: {modified_list_str}, \"\n                       f\"deleted_list_str: {deleted_list_str}\")\n    if not return_remaining_files:\n        return final_diff\n    else:\n        return final_diff, remaining_files_list",
    "start_line": 38,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "git_provider",
      "token_handler",
      "model",
      "add_line_numbers_to_hunks",
      "disable_extra_lines",
      "large_pr_handling",
      "return_remaining_files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_diff",
    "component_id": "pr_agent.algo.pr_processing.get_pr_diff"
  },
  "pr_agent.algo.pr_processing.get_pr_diff_multiple_patchs": {
    "id": "pr_agent.algo.pr_processing.get_pr_diff_multiple_patchs",
    "name": "get_pr_diff_multiple_patchs",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.algo.language_handler.sort_files_by_main_languages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.algo.pr_processing.pr_generate_compressed_diff",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def get_pr_diff_multiple_patchs(git_provider: GitProvider, token_handler: TokenHandler, model: str,\n                add_line_numbers_to_hunks: bool = False, disable_extra_lines: bool = False):\n    try:\n        diff_files = git_provider.get_diff_files()\n    except RateLimitExceededException as e:\n        get_logger().error(f\"Rate limit exceeded for git provider API. original message {e}\")\n        raise\n\n    # get pr languages\n    pr_languages = sort_files_by_main_languages(git_provider.get_languages(), diff_files)\n    if pr_languages:\n        try:\n            get_logger().info(f\"PR main language: {pr_languages[0]['language']}\")\n        except Exception as e:\n            pass\n\n    patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list = \\\n        pr_generate_compressed_diff(pr_languages, token_handler, model, add_line_numbers_to_hunks, large_pr_handling=True)\n\n    return patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list",
    "start_line": 145,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "git_provider",
      "token_handler",
      "model",
      "add_line_numbers_to_hunks",
      "disable_extra_lines"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_diff_multiple_patchs",
    "component_id": "pr_agent.algo.pr_processing.get_pr_diff_multiple_patchs"
  },
  "pr_agent.algo.pr_processing.pr_generate_extended_diff": {
    "id": "pr_agent.algo.pr_processing.pr_generate_extended_diff",
    "name": "pr_generate_extended_diff",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.algo.git_patch_processing.extend_patch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.pr_processing.add_ai_summary_top_patch",
      "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def pr_generate_extended_diff(pr_languages: list,\n                              token_handler: TokenHandler,\n                              add_line_numbers_to_hunks: bool,\n                              patch_extra_lines_before: int = 0,\n                              patch_extra_lines_after: int = 0) -> Tuple[list, int, list]:\n    total_tokens = token_handler.prompt_tokens  # initial tokens\n    patches_extended = []\n    patches_extended_tokens = []\n    for lang in pr_languages:\n        for file in lang['files']:\n            original_file_content_str = file.base_file\n            new_file_content_str = file.head_file\n            patch = file.patch\n            if not patch:\n                continue\n\n            # extend each patch with extra lines of context\n            extended_patch = extend_patch(original_file_content_str, patch,\n                                          patch_extra_lines_before, patch_extra_lines_after, file.filename,\n                                          new_file_str=new_file_content_str)\n            if not extended_patch:\n                get_logger().warning(f\"Failed to extend patch for file: {file.filename}\")\n                continue\n\n            if add_line_numbers_to_hunks:\n                full_extended_patch = decouple_and_convert_to_hunks_with_lines_numbers(extended_patch, file)\n            else:\n                extended_patch = extended_patch.replace('\\n@@ ', '\\n\\n@@ ') # add extra line before each hunk\n                full_extended_patch = f\"\\n\\n## File: '{file.filename.strip()}'\\n\\n{extended_patch.strip()}\\n\"\n\n            # add AI-summary metadata to the patch\n            if file.ai_file_summary and get_settings().get(\"config.enable_ai_metadata\", False):\n                full_extended_patch = add_ai_summary_top_patch(file, full_extended_patch)\n\n            patch_tokens = token_handler.count_tokens(full_extended_patch)\n            file.tokens = patch_tokens\n            total_tokens += patch_tokens\n            patches_extended_tokens.append(patch_tokens)\n            patches_extended.append(full_extended_patch)\n\n    return patches_extended, total_tokens, patches_extended_tokens",
    "start_line": 167,
    "end_line": 207,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_languages",
      "token_handler",
      "add_line_numbers_to_hunks",
      "patch_extra_lines_before",
      "patch_extra_lines_after"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pr_generate_extended_diff",
    "component_id": "pr_agent.algo.pr_processing.pr_generate_extended_diff"
  },
  "pr_agent.algo.pr_processing.pr_generate_compressed_diff": {
    "id": "pr_agent.algo.pr_processing.pr_generate_compressed_diff",
    "name": "pr_generate_compressed_diff",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.algo.git_patch_processing.handle_patch_deletions",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers",
      "pr_agent.algo.pr_processing.generate_full_patch",
      "pr_agent.algo.utils.get_max_tokens"
    ],
    "source_code": "def pr_generate_compressed_diff(top_langs: list, token_handler: TokenHandler, model: str,\n                                convert_hunks_to_line_numbers: bool,\n                                large_pr_handling: bool) -> Tuple[list, list, list, list, dict, list]:\n    deleted_files_list = []\n\n    # sort each one of the languages in top_langs by the number of tokens in the diff\n    sorted_files = []\n    for lang in top_langs:\n        sorted_files.extend(sorted(lang['files'], key=lambda x: x.tokens, reverse=True))\n\n    # generate patches for each file, and count tokens\n    file_dict = {}\n    for file in sorted_files:\n        original_file_content_str = file.base_file\n        new_file_content_str = file.head_file\n        patch = file.patch\n        if not patch:\n            continue\n\n        # removing delete-only hunks\n        patch = handle_patch_deletions(patch, original_file_content_str,\n                                       new_file_content_str, file.filename, file.edit_type)\n        if patch is None:\n            if file.filename not in deleted_files_list:\n                deleted_files_list.append(file.filename)\n            continue\n\n        if convert_hunks_to_line_numbers:\n            patch = decouple_and_convert_to_hunks_with_lines_numbers(patch, file)\n\n        ## add AI-summary metadata to the patch (disabled, since we are in the compressed diff)\n        # if file.ai_file_summary and get_settings().config.get('config.is_auto_command', False):\n        #     patch = add_ai_summary_top_patch(file, patch)\n\n        new_patch_tokens = token_handler.count_tokens(patch)\n        file_dict[file.filename] = {'patch': patch, 'tokens': new_patch_tokens, 'edit_type': file.edit_type}\n\n    max_tokens_model = get_max_tokens(model)\n\n    # first iteration\n    files_in_patches_list = []\n    remaining_files_list =  [file.filename for file in sorted_files]\n    patches_list =[]\n    total_tokens_list = []\n    total_tokens, patches, remaining_files_list, files_in_patch_list = generate_full_patch(convert_hunks_to_line_numbers, file_dict,\n                                       max_tokens_model, remaining_files_list, token_handler)\n    patches_list.append(patches)\n    total_tokens_list.append(total_tokens)\n    files_in_patches_list.append(files_in_patch_list)\n\n    # additional iterations (if needed)\n    if large_pr_handling:\n        NUMBER_OF_ALLOWED_ITERATIONS = get_settings().pr_description.max_ai_calls - 1 # one more call is to summarize\n        for i in range(NUMBER_OF_ALLOWED_ITERATIONS-1):\n            if remaining_files_list:\n                total_tokens, patches, remaining_files_list, files_in_patch_list = generate_full_patch(convert_hunks_to_line_numbers,\n                                                                                 file_dict,\n                                                                                  max_tokens_model,\n                                                                                  remaining_files_list, token_handler)\n                if patches:\n                    patches_list.append(patches)\n                    total_tokens_list.append(total_tokens)\n                    files_in_patches_list.append(files_in_patch_list)\n            else:\n                break\n\n    return patches_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict, files_in_patches_list",
    "start_line": 210,
    "end_line": 276,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "top_langs",
      "token_handler",
      "model",
      "convert_hunks_to_line_numbers",
      "large_pr_handling"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pr_generate_compressed_diff",
    "component_id": "pr_agent.algo.pr_processing.pr_generate_compressed_diff"
  },
  "pr_agent.algo.pr_processing.generate_full_patch": {
    "id": "pr_agent.algo.pr_processing.generate_full_patch",
    "name": "generate_full_patch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def generate_full_patch(convert_hunks_to_line_numbers, file_dict, max_tokens_model,remaining_files_list_prev, token_handler):\n    total_tokens = token_handler.prompt_tokens # initial tokens\n    patches = []\n    remaining_files_list_new = []\n    files_in_patch_list = []\n    for filename, data in file_dict.items():\n        if filename not in remaining_files_list_prev:\n            continue\n\n        patch = data['patch']\n        new_patch_tokens = data['tokens']\n        edit_type = data['edit_type']\n\n        # Hard Stop, no more tokens\n        if total_tokens > max_tokens_model - OUTPUT_BUFFER_TOKENS_HARD_THRESHOLD:\n            get_logger().warning(f\"File was fully skipped, no more tokens: {filename}.\")\n            continue\n\n        # If the patch is too large, just show the file name\n        if total_tokens + new_patch_tokens > max_tokens_model - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD:\n            # Current logic is to skip the patch if it's too large\n            # TODO: Option for alternative logic to remove hunks from the patch to reduce the number of tokens\n            #  until we meet the requirements\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().warning(f\"Patch too large, skipping it: '{filename}'\")\n            remaining_files_list_new.append(filename)\n            continue\n\n        if patch:\n            if not convert_hunks_to_line_numbers:\n                patch_final = f\"\\n\\n## File: '{filename.strip()}'\\n\\n{patch.strip()}\\n\"\n            else:\n                patch_final = \"\\n\\n\" + patch.strip()\n            patches.append(patch_final)\n            total_tokens += token_handler.count_tokens(patch_final)\n            files_in_patch_list.append(filename)\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Tokens: {total_tokens}, last filename: {filename}\")\n    return total_tokens, patches, remaining_files_list_new, files_in_patch_list",
    "start_line": 279,
    "end_line": 317,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "convert_hunks_to_line_numbers",
      "file_dict",
      "max_tokens_model",
      "remaining_files_list_prev",
      "token_handler"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_full_patch",
    "component_id": "pr_agent.algo.pr_processing.generate_full_patch"
  },
  "pr_agent.algo.pr_processing.retry_with_fallback_models": {
    "id": "pr_agent.algo.pr_processing.retry_with_fallback_models",
    "name": "retry_with_fallback_models",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.algo.pr_processing._get_all_deployments",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.pr_processing._get_all_models"
    ],
    "source_code": "async def retry_with_fallback_models(f: Callable, model_type: ModelType = ModelType.REGULAR):\n    all_models = _get_all_models(model_type)\n    all_deployments = _get_all_deployments(all_models)\n    # try each (model, deployment_id) pair until one is successful, otherwise raise exception\n    for i, (model, deployment_id) in enumerate(zip(all_models, all_deployments)):\n        try:\n            get_logger().debug(\n                f\"Generating prediction with {model}\"\n                f\"{(' from deployment ' + deployment_id) if deployment_id else ''}\"\n            )\n            get_settings().set(\"openai.deployment_id\", deployment_id)\n            return await f(model)\n        except:\n            get_logger().warning(\n                f\"Failed to generate prediction with {model}\"\n            )\n            if i == len(all_models) - 1:  # If it's the last iteration\n                raise Exception(f\"Failed to generate prediction with any model of {all_models}\")",
    "start_line": 320,
    "end_line": 337,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "f",
      "model_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function retry_with_fallback_models",
    "component_id": "pr_agent.algo.pr_processing.retry_with_fallback_models"
  },
  "pr_agent.algo.pr_processing._get_all_models": {
    "id": "pr_agent.algo.pr_processing._get_all_models",
    "name": "_get_all_models",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.algo.utils.get_weak_model",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def _get_all_models(model_type: ModelType = ModelType.REGULAR) -> List[str]:\n    if model_type == ModelType.WEAK:\n        model = get_weak_model()\n    else:\n        model = get_settings().config.model\n    fallback_models = get_settings().config.fallback_models\n    if not isinstance(fallback_models, list):\n        fallback_models = [m.strip() for m in fallback_models.split(\",\")]\n    all_models = [model] + fallback_models\n    return all_models",
    "start_line": 340,
    "end_line": 349,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "model_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _get_all_models",
    "component_id": "pr_agent.algo.pr_processing._get_all_models"
  },
  "pr_agent.algo.pr_processing._get_all_deployments": {
    "id": "pr_agent.algo.pr_processing._get_all_deployments",
    "name": "_get_all_deployments",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def _get_all_deployments(all_models: List[str]) -> List[str]:\n    deployment_id = get_settings().get(\"openai.deployment_id\", None)\n    fallback_deployments = get_settings().get(\"openai.fallback_deployments\", [])\n    if not isinstance(fallback_deployments, list) and fallback_deployments:\n        fallback_deployments = [d.strip() for d in fallback_deployments.split(\",\")]\n    if fallback_deployments:\n        all_deployments = [deployment_id] + fallback_deployments\n        if len(all_deployments) < len(all_models):\n            raise ValueError(f\"The number of deployments ({len(all_deployments)}) \"\n                             f\"is less than the number of models ({len(all_models)})\")\n    else:\n        all_deployments = [deployment_id] * len(all_models)\n    return all_deployments",
    "start_line": 352,
    "end_line": 364,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "all_models"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _get_all_deployments",
    "component_id": "pr_agent.algo.pr_processing._get_all_deployments"
  },
  "pr_agent.algo.pr_processing.get_pr_multi_diffs": {
    "id": "pr_agent.algo.pr_processing.get_pr_multi_diffs",
    "name": "get_pr_multi_diffs",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.algo.pr_processing.pr_generate_extended_diff",
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.algo.language_handler.sort_files_by_main_languages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.algo.pr_processing.cap_and_log_extra_lines",
      "pr_agent.algo.git_patch_processing.handle_patch_deletions",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.algo.pr_processing.add_ai_summary_top_patch",
      "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def get_pr_multi_diffs(git_provider: GitProvider,\n                       token_handler: TokenHandler,\n                       model: str,\n                       max_calls: int = 5,\n                       add_line_numbers: bool = True) -> List[str]:\n    \"\"\"\n    Retrieves the diff files from a Git provider, sorts them by main language, and generates patches for each file.\n    The patches are split into multiple groups based on the maximum number of tokens allowed for the given model.\n\n    Args:\n        git_provider (GitProvider): An object that provides access to Git provider APIs.\n        token_handler (TokenHandler): An object that handles tokens in the context of a pull request.\n        model (str): The name of the model.\n        max_calls (int, optional): The maximum number of calls to retrieve diff files. Defaults to 5.\n\n    Returns:\n        List[str]: A list of final diff strings, split into multiple groups based on the maximum number of tokens allowed for the given model.\n\n    Raises:\n        RateLimitExceededException: If the rate limit for the Git provider API is exceeded.\n    \"\"\"\n    try:\n        diff_files = git_provider.get_diff_files()\n    except RateLimitExceededException as e:\n        get_logger().error(f\"Rate limit exceeded for git provider API. original message {e}\")\n        raise\n\n    # Sort files by main language\n    pr_languages = sort_files_by_main_languages(git_provider.get_languages(), diff_files)\n\n    # Sort files within each language group by tokens in descending order\n    sorted_files = []\n    for lang in pr_languages:\n        sorted_files.extend(sorted(lang['files'], key=lambda x: x.tokens, reverse=True))\n\n    # Get the maximum number of extra lines before and after the patch\n    PATCH_EXTRA_LINES_BEFORE = get_settings().config.patch_extra_lines_before\n    PATCH_EXTRA_LINES_AFTER = get_settings().config.patch_extra_lines_after\n    PATCH_EXTRA_LINES_BEFORE = cap_and_log_extra_lines(PATCH_EXTRA_LINES_BEFORE, \"before\")\n    PATCH_EXTRA_LINES_AFTER = cap_and_log_extra_lines(PATCH_EXTRA_LINES_AFTER, \"after\")\n\n    # try first a single run with standard diff string, with patch extension, and no deletions\n    patches_extended, total_tokens, patches_extended_tokens = pr_generate_extended_diff(\n        pr_languages, token_handler,\n        add_line_numbers_to_hunks=add_line_numbers,\n        patch_extra_lines_before=PATCH_EXTRA_LINES_BEFORE,\n        patch_extra_lines_after=PATCH_EXTRA_LINES_AFTER)\n\n    # if we are under the limit, return the full diff\n    if total_tokens + OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD < get_max_tokens(model):\n        return [\"\\n\".join(patches_extended)] if patches_extended else []\n\n    patches = []\n    final_diff_list = []\n    total_tokens = token_handler.prompt_tokens\n    call_number = 1\n    for file in sorted_files:\n        if call_number > max_calls:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Reached max calls ({max_calls})\")\n            break\n\n        original_file_content_str = file.base_file\n        new_file_content_str = file.head_file\n        patch = file.patch\n        if not patch:\n            continue\n\n        # Remove delete-only hunks\n        patch = handle_patch_deletions(patch, original_file_content_str, new_file_content_str, file.filename, file.edit_type)\n        if patch is None:\n            continue\n\n        # Add line numbers and metadata to the patch\n        if add_line_numbers:\n            patch = decouple_and_convert_to_hunks_with_lines_numbers(patch, file)\n        else:\n            patch = f\"\\n\\n## File: '{file.filename.strip()}'\\n\\n{patch.strip()}\\n\"\n\n        # add AI-summary metadata to the patch\n        if file.ai_file_summary and get_settings().get(\"config.enable_ai_metadata\", False):\n            patch = add_ai_summary_top_patch(file, patch)\n        new_patch_tokens = token_handler.count_tokens(patch)\n\n        if patch and (token_handler.prompt_tokens + new_patch_tokens) > get_max_tokens(\n                model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD:\n            if get_settings().config.get('large_patch_policy', 'skip') == 'skip':\n                get_logger().warning(f\"Patch too large, skipping: {file.filename}\")\n                continue\n            elif get_settings().config.get('large_patch_policy') == 'clip':\n                delta_tokens = get_max_tokens(model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD - token_handler.prompt_tokens\n                patch_clipped = clip_tokens(patch, delta_tokens, delete_last_line=True, num_input_tokens=new_patch_tokens)\n                new_patch_tokens = token_handler.count_tokens(patch_clipped)\n                if patch_clipped and (token_handler.prompt_tokens + new_patch_tokens) > get_max_tokens(\n                        model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD:\n                    get_logger().warning(f\"Patch too large, skipping: {file.filename}\")\n                    continue\n                else:\n                    get_logger().info(f\"Clipped large patch for file: {file.filename}\")\n                    patch = patch_clipped\n            else:\n                get_logger().warning(f\"Patch too large, skipping: {file.filename}\")\n                continue\n\n        if patch and (total_tokens + new_patch_tokens > get_max_tokens(model) - OUTPUT_BUFFER_TOKENS_SOFT_THRESHOLD):\n            final_diff = \"\\n\".join(patches)\n            final_diff_list.append(final_diff)\n            patches = []\n            total_tokens = token_handler.prompt_tokens\n            call_number += 1\n            if call_number > max_calls: # avoid creating new patches\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"Reached max calls ({max_calls})\")\n                break\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Call number: {call_number}\")\n\n        if patch:\n            patches.append(patch)\n            total_tokens += new_patch_tokens\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Tokens: {total_tokens}, last filename: {file.filename}\")\n\n    # Add the last chunk\n    if patches:\n        final_diff = \"\\n\".join(patches)\n        final_diff_list.append(final_diff.strip())\n\n    return final_diff_list",
    "start_line": 367,
    "end_line": 495,
    "has_docstring": true,
    "docstring": "Retrieves the diff files from a Git provider, sorts them by main language, and generates patches for each file.\nThe patches are split into multiple groups based on the maximum number of tokens allowed for the given model.\n\nArgs:\n    git_provider (GitProvider): An object that provides access to Git provider APIs.\n    token_handler (TokenHandler): An object that handles tokens in the context of a pull request.\n    model (str): The name of the model.\n    max_calls (int, optional): The maximum number of calls to retrieve diff files. Defaults to 5.\n\nReturns:\n    List[str]: A list of final diff strings, split into multiple groups based on the maximum number of tokens allowed for the given model.\n\nRaises:\n    RateLimitExceededException: If the rate limit for the Git provider API is exceeded.",
    "parameters": [
      "git_provider",
      "token_handler",
      "model",
      "max_calls",
      "add_line_numbers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_multi_diffs",
    "component_id": "pr_agent.algo.pr_processing.get_pr_multi_diffs"
  },
  "pr_agent.algo.pr_processing.add_ai_metadata_to_diff_files": {
    "id": "pr_agent.algo.pr_processing.add_ai_metadata_to_diff_files",
    "name": "add_ai_metadata_to_diff_files",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def add_ai_metadata_to_diff_files(git_provider, pr_description_files):\n    \"\"\"\n    Adds AI metadata to the diff files based on the PR description files (FilePatchInfo.ai_file_summary).\n    \"\"\"\n    try:\n        if not pr_description_files:\n            get_logger().warning(f\"PR description files are empty.\")\n            return\n        available_files = {pr_file['full_file_name'].strip(): pr_file for pr_file in pr_description_files}\n        diff_files = git_provider.get_diff_files()\n        found_any_match = False\n        for file in diff_files:\n            filename = file.filename.strip()\n            if filename in available_files:\n                file.ai_file_summary = available_files[filename]\n                found_any_match = True\n        if not found_any_match:\n            get_logger().error(f\"Failed to find any matching files between PR description and diff files.\",\n                               artifact={\"pr_description_files\": pr_description_files})\n    except Exception as e:\n        get_logger().error(f\"Failed to add AI metadata to diff files: {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})",
    "start_line": 498,
    "end_line": 519,
    "has_docstring": true,
    "docstring": "Adds AI metadata to the diff files based on the PR description files (FilePatchInfo.ai_file_summary).",
    "parameters": [
      "git_provider",
      "pr_description_files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_ai_metadata_to_diff_files",
    "component_id": "pr_agent.algo.pr_processing.add_ai_metadata_to_diff_files"
  },
  "pr_agent.algo.pr_processing.add_ai_summary_top_patch": {
    "id": "pr_agent.algo.pr_processing.add_ai_summary_top_patch",
    "name": "add_ai_summary_top_patch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/pr_processing.py",
    "relative_path": "pr_agent/algo/pr_processing.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def add_ai_summary_top_patch(file, full_extended_patch):\n    try:\n        # below every instance of '## File: ...' in the patch, add the ai-summary metadata\n        full_extended_patch_lines = full_extended_patch.split(\"\\n\")\n        for i, line in enumerate(full_extended_patch_lines):\n            if line.startswith(\"## File:\") or line.startswith(\"## file:\"):\n                full_extended_patch_lines.insert(i + 1,\n                                                 f\"### AI-generated changes summary:\\n{file.ai_file_summary['long_summary']}\")\n                full_extended_patch = \"\\n\".join(full_extended_patch_lines)\n                return full_extended_patch\n\n        # if no '## File: ...' was found\n        return full_extended_patch\n    except Exception as e:\n        get_logger().error(f\"Failed to add AI summary to the top of the patch: {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})\n        return full_extended_patch",
    "start_line": 522,
    "end_line": 538,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "file",
      "full_extended_patch"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_ai_summary_top_patch",
    "component_id": "pr_agent.algo.pr_processing.add_ai_summary_top_patch"
  },
  "pr_agent.algo.token_handler.TokenEncoder": {
    "id": "pr_agent.algo.token_handler.TokenEncoder",
    "name": "TokenEncoder",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/token_handler.py",
    "relative_path": "pr_agent/algo/token_handler.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class TokenEncoder:\n    _encoder_instance = None\n    _model = None\n    _lock = Lock()  # Create a lock object\n\n    @classmethod\n    def get_token_encoder(cls):\n        model = get_settings().config.model\n        if cls._encoder_instance is None or model != cls._model:  # Check without acquiring the lock for performance\n            with cls._lock:  # Lock acquisition to ensure thread safety\n                if cls._encoder_instance is None or model != cls._model:\n                    cls._model = model\n                    cls._encoder_instance = encoding_for_model(cls._model) if \"gpt\" in cls._model else get_encoding(\n                        \"cl100k_base\")\n        return cls._encoder_instance",
    "start_line": 11,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class TokenEncoder",
    "component_id": "pr_agent.algo.token_handler.TokenEncoder"
  },
  "pr_agent.algo.token_handler.TokenHandler": {
    "id": "pr_agent.algo.token_handler.TokenHandler",
    "name": "TokenHandler",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/token_handler.py",
    "relative_path": "pr_agent/algo/token_handler.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class TokenHandler:\n    \"\"\"\n    A class for handling tokens in the context of a pull request.\n\n    Attributes:\n    - encoder: An object of the encoding_for_model class from the tiktoken module. Used to encode strings and count the\n      number of tokens in them.\n    - limit: The maximum number of tokens allowed for the given model, as defined in the MAX_TOKENS dictionary in the\n      pr_agent.algo module.\n    - prompt_tokens: The number of tokens in the system and user strings, as calculated by the _get_system_user_tokens\n      method.\n    \"\"\"\n\n    def __init__(self, pr=None, vars: dict = {}, system=\"\", user=\"\"):\n        \"\"\"\n        Initializes the TokenHandler object.\n\n        Args:\n        - pr: The pull request object.\n        - vars: A dictionary of variables.\n        - system: The system string.\n        - user: The user string.\n        \"\"\"\n        self.encoder = TokenEncoder.get_token_encoder()\n        if pr is not None:\n            self.prompt_tokens = self._get_system_user_tokens(pr, self.encoder, vars, system, user)\n\n    def _get_system_user_tokens(self, pr, encoder, vars: dict, system, user):\n        \"\"\"\n        Calculates the number of tokens in the system and user strings.\n\n        Args:\n        - pr: The pull request object.\n        - encoder: An object of the encoding_for_model class from the tiktoken module.\n        - vars: A dictionary of variables.\n        - system: The system string.\n        - user: The user string.\n\n        Returns:\n        The sum of the number of tokens in the system and user strings.\n        \"\"\"\n        try:\n            environment = Environment(undefined=StrictUndefined)\n            system_prompt = environment.from_string(system).render(vars)\n            user_prompt = environment.from_string(user).render(vars)\n            system_prompt_tokens = len(encoder.encode(system_prompt))\n            user_prompt_tokens = len(encoder.encode(user_prompt))\n            return system_prompt_tokens + user_prompt_tokens\n        except Exception as e:\n            get_logger().error(f\"Error in _get_system_user_tokens: {e}\")\n            return 0\n\n    def calc_claude_tokens(self, patch):\n        try:\n            import anthropic\n            from pr_agent.algo import MAX_TOKENS\n            client = anthropic.Anthropic(api_key=get_settings(use_context=False).get('anthropic.key'))\n            MaxTokens = MAX_TOKENS[get_settings().config.model]\n\n            # Check if the content size is too large (9MB limit)\n            if len(patch.encode('utf-8')) > 9_000_000:\n                get_logger().warning(\n                    \"Content too large for Anthropic token counting API, falling back to local tokenizer\"\n                )\n                return MaxTokens\n\n            response = client.messages.count_tokens(\n                model=\"claude-3-7-sonnet-20250219\",\n                system=\"system\",\n                messages=[{\n                    \"role\": \"user\",\n                    \"content\": patch\n                }],\n            )\n            return response.input_tokens\n\n        except Exception as e:\n            get_logger().error( f\"Error in Anthropic token counting: {e}\")\n            return MaxTokens\n\n    def count_tokens(self, patch: str, force_accurate=False) -> int:\n        \"\"\"\n        Counts the number of tokens in a given patch string.\n\n        Args:\n        - patch: The patch string.\n\n        Returns:\n        The number of tokens in the patch string.\n        \"\"\"\n        encoder_estimate = len(self.encoder.encode(patch, disallowed_special=()))\n        if not force_accurate:\n            return encoder_estimate\n        #else, need to provide an accurate estimation:\n\n        model = get_settings().config.model.lower()\n        if force_accurate and 'claude' in model and get_settings(use_context=False).get('anthropic.key'):\n            return self.calc_claude_tokens(patch) # API call to Anthropic for accurate token counting for Claude models\n        #else: Non Anthropic provided model\n\n        import re\n        model_is_from_o_series = re.match(r\"^o[1-9](-mini|-preview)?$\", model)\n        if ('gpt' in get_settings().config.model.lower() or model_is_from_o_series) and get_settings(use_context=False).get('openai.key'):\n            return encoder_estimate\n        #else: Model is neither an OpenAI, nor an Anthropic model - therefore, cannot provide an accurate token count and instead, return a higher number as best effort.\n\n        elbow_factor = 1 + get_settings().get('config.model_token_count_estimate_factor', 0)\n        get_logger().warning(f\"{model}'s expected token count cannot be accurately estimated. Using {elbow_factor} of encoder output as best effort estimate\")\n        return ceil(elbow_factor * encoder_estimate)",
    "start_line": 28,
    "end_line": 136,
    "has_docstring": true,
    "docstring": "A class for handling tokens in the context of a pull request.\n\nAttributes:\n- encoder: An object of the encoding_for_model class from the tiktoken module. Used to encode strings and count the\n  number of tokens in them.\n- limit: The maximum number of tokens allowed for the given model, as defined in the MAX_TOKENS dictionary in the\n  pr_agent.algo module.\n- prompt_tokens: The number of tokens in the system and user strings, as calculated by the _get_system_user_tokens\n  method.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class TokenHandler",
    "component_id": "pr_agent.algo.token_handler.TokenHandler"
  },
  "pr_agent.algo.types.EDIT_TYPE": {
    "id": "pr_agent.algo.types.EDIT_TYPE",
    "name": "EDIT_TYPE",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/types.py",
    "relative_path": "pr_agent/algo/types.py",
    "depends_on": [],
    "source_code": "class EDIT_TYPE(Enum):\n    ADDED = 1\n    DELETED = 2\n    MODIFIED = 3\n    RENAMED = 4\n    UNKNOWN = 5",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Enum"
    ],
    "class_name": null,
    "display_name": "class EDIT_TYPE",
    "component_id": "pr_agent.algo.types.EDIT_TYPE"
  },
  "pr_agent.algo.types.FilePatchInfo": {
    "id": "pr_agent.algo.types.FilePatchInfo",
    "name": "FilePatchInfo",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/types.py",
    "relative_path": "pr_agent/algo/types.py",
    "depends_on": [],
    "source_code": "class FilePatchInfo:\n    base_file: str\n    head_file: str\n    patch: str\n    filename: str\n    tokens: int = -1\n    edit_type: EDIT_TYPE = EDIT_TYPE.UNKNOWN\n    old_filename: str = None\n    num_plus_lines: int = -1\n    num_minus_lines: int = -1\n    language: Optional[str] = None\n    ai_file_summary: str = None",
    "start_line": 15,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class FilePatchInfo",
    "component_id": "pr_agent.algo.types.FilePatchInfo"
  },
  "pr_agent.algo.utils.get_weak_model": {
    "id": "pr_agent.algo.utils.get_weak_model",
    "name": "get_weak_model",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_weak_model() -> str:\n    if get_settings().get(\"config.model_weak\"):\n        return get_settings().config.model_weak\n    return get_settings().config.model",
    "start_line": 33,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_weak_model",
    "component_id": "pr_agent.algo.utils.get_weak_model"
  },
  "pr_agent.algo.utils.Range": {
    "id": "pr_agent.algo.utils.Range",
    "name": "Range",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "class Range(BaseModel):\n    line_start: int  # should be 0-indexed\n    line_end: int\n    column_start: int = -1\n    column_end: int = -1",
    "start_line": 39,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class Range",
    "component_id": "pr_agent.algo.utils.Range"
  },
  "pr_agent.algo.utils.ModelType": {
    "id": "pr_agent.algo.utils.ModelType",
    "name": "ModelType",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "class ModelType(str, Enum):\n    REGULAR = \"regular\"\n    WEAK = \"weak\"",
    "start_line": 45,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class ModelType",
    "component_id": "pr_agent.algo.utils.ModelType"
  },
  "pr_agent.algo.utils.PRReviewHeader": {
    "id": "pr_agent.algo.utils.PRReviewHeader",
    "name": "PRReviewHeader",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "class PRReviewHeader(str, Enum):\n    REGULAR = \"## PR Reviewer Guide\"\n    INCREMENTAL = \"## Incremental PR Reviewer Guide\"",
    "start_line": 49,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class PRReviewHeader",
    "component_id": "pr_agent.algo.utils.PRReviewHeader"
  },
  "pr_agent.algo.utils.ReasoningEffort": {
    "id": "pr_agent.algo.utils.ReasoningEffort",
    "name": "ReasoningEffort",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "class ReasoningEffort(str, Enum):\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"",
    "start_line": 53,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class ReasoningEffort",
    "component_id": "pr_agent.algo.utils.ReasoningEffort"
  },
  "pr_agent.algo.utils.PRDescriptionHeader": {
    "id": "pr_agent.algo.utils.PRDescriptionHeader",
    "name": "PRDescriptionHeader",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "class PRDescriptionHeader(str, Enum):\n    CHANGES_WALKTHROUGH = \"### **Changes walkthrough** \"",
    "start_line": 59,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class PRDescriptionHeader",
    "component_id": "pr_agent.algo.utils.PRDescriptionHeader"
  },
  "pr_agent.algo.utils.get_setting": {
    "id": "pr_agent.algo.utils.get_setting",
    "name": "get_setting",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def get_setting(key: str) -> Any:\n    try:\n        key = key.upper()\n        return context.get(\"settings\", global_settings).get(key, global_settings.get(key, None))\n    except Exception:\n        return global_settings.get(key, None)",
    "start_line": 63,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "key"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_setting",
    "component_id": "pr_agent.algo.utils.get_setting"
  },
  "pr_agent.algo.utils.emphasize_header": {
    "id": "pr_agent.algo.utils.emphasize_header",
    "name": "emphasize_header",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def emphasize_header(text: str, only_markdown=False, reference_link=None) -> str:\n    try:\n        # Finding the position of the first occurrence of \": \"\n        colon_position = text.find(\": \")\n\n        # Splitting the string and wrapping the first part in <strong> tags\n        if colon_position != -1:\n            # Everything before the colon (inclusive) is wrapped in <strong> tags\n            if only_markdown:\n                if reference_link:\n                    transformed_string = f\"[**{text[:colon_position + 1]}**]({reference_link})\\n\" + text[colon_position + 1:]\n                else:\n                    transformed_string = f\"**{text[:colon_position + 1]}**\\n\" + text[colon_position + 1:]\n            else:\n                if reference_link:\n                    transformed_string = f\"<strong><a href='{reference_link}'>{text[:colon_position + 1]}</a></strong><br>\" + text[colon_position + 1:]\n                else:\n                    transformed_string = \"<strong>\" + text[:colon_position + 1] + \"</strong>\" +'<br>' + text[colon_position + 1:]\n        else:\n            # If there's no \": \", return the original string\n            transformed_string = text\n\n        return transformed_string\n    except Exception as e:\n        get_logger().exception(f\"Failed to emphasize header: {e}\")\n        return text",
    "start_line": 71,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text",
      "only_markdown",
      "reference_link"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function emphasize_header",
    "component_id": "pr_agent.algo.utils.emphasize_header"
  },
  "pr_agent.algo.utils.unique_strings": {
    "id": "pr_agent.algo.utils.unique_strings",
    "name": "unique_strings",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def unique_strings(input_list: List[str]) -> List[str]:\n    if not input_list or not isinstance(input_list, list):\n        return input_list\n    seen = set()\n    unique_list = []\n    for item in input_list:\n        if item not in seen:\n            unique_list.append(item)\n            seen.add(item)\n    return unique_list",
    "start_line": 99,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "input_list"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function unique_strings",
    "component_id": "pr_agent.algo.utils.unique_strings"
  },
  "pr_agent.algo.utils.convert_to_markdown_v2": {
    "id": "pr_agent.algo.utils.convert_to_markdown_v2",
    "name": "convert_to_markdown_v2",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.algo.utils.extract_relevant_lines_str",
      "pr_agent.algo.utils.is_value_no",
      "pr_agent.algo.utils.ticket_markdown_logic",
      "pr_agent.git_providers.git_provider.get_line_link",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.process_can_be_split",
      "pr_agent.algo.utils.emphasize_header",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def convert_to_markdown_v2(output_data: dict,\n                           gfm_supported: bool = True,\n                           incremental_review=None,\n                           git_provider=None,\n                           files=None) -> str:\n    \"\"\"\n    Convert a dictionary of data into markdown format.\n    Args:\n        output_data (dict): A dictionary containing data to be converted to markdown format.\n    Returns:\n        str: The markdown formatted text generated from the input dictionary.\n    \"\"\"\n\n    emojis = {\n        \"Can be split\": \"\",\n        \"Key issues to review\": \"\",\n        \"Recommended focus areas for review\": \"\",\n        \"Score\": \"\",\n        \"Relevant tests\": \"\",\n        \"Focused PR\": \"\",\n        \"Relevant ticket\": \"\",\n        \"Security concerns\": \"\",\n        \"Insights from user's answers\": \"\",\n        \"Code feedback\": \"\",\n        \"Estimated effort to review [1-5]\": \"\",\n        \"Ticket compliance check\": \"\",\n    }\n    markdown_text = \"\"\n    if not incremental_review:\n        markdown_text += f\"{PRReviewHeader.REGULAR.value} \\n\\n\"\n    else:\n        markdown_text += f\"{PRReviewHeader.INCREMENTAL.value} \\n\\n\"\n        markdown_text += f\" Review for commits since previous PR-Agent review {incremental_review}.\\n\\n\"\n    if not output_data or not output_data.get('review', {}):\n        return \"\"\n\n    if get_settings().get(\"pr_reviewer.enable_intro_text\", False):\n        markdown_text += f\"Here are some key observations to aid the review process:\\n\\n\"\n\n    if gfm_supported:\n        markdown_text += \"<table>\\n\"\n\n    for key, value in output_data['review'].items():\n        if value is None or value == '' or value == {} or value == []:\n            if key.lower() not in ['can_be_split', 'key_issues_to_review']:\n                continue\n        key_nice = key.replace('_', ' ').capitalize()\n        emoji = emojis.get(key_nice, \"\")\n        if 'Estimated effort to review' in key_nice:\n            key_nice = 'Estimated effort to review'\n            value = str(value).strip()\n            if value.isnumeric():\n                value_int = int(value)\n            else:\n                try:\n                    value_int = int(value.split(',')[0])\n                except ValueError:\n                    continue\n            blue_bars = '' * value_int\n            white_bars = '' * (5 - value_int)\n            value = f\"{value_int} {blue_bars}{white_bars}\"\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                markdown_text += f\"{emoji}&nbsp;<strong>{key_nice}</strong>: {value}\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                markdown_text += f\"### {emoji} {key_nice}: {value}\\n\\n\"\n        elif 'relevant tests' in key_nice.lower():\n            value = str(value).strip().lower()\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                if is_value_no(value):\n                    markdown_text += f\"{emoji}&nbsp;<strong>No relevant tests</strong>\"\n                else:\n                    markdown_text += f\"{emoji}&nbsp;<strong>PR contains tests</strong>\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                if is_value_no(value):\n                    markdown_text += f'### {emoji} No relevant tests\\n\\n'\n                else:\n                    markdown_text += f\"### {emoji} PR contains tests\\n\\n\"\n        elif 'ticket compliance check' in key_nice.lower():\n            markdown_text = ticket_markdown_logic(emoji, markdown_text, value, gfm_supported)\n        elif 'security concerns' in key_nice.lower():\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                if is_value_no(value):\n                    markdown_text += f\"{emoji}&nbsp;<strong>No security concerns identified</strong>\"\n                else:\n                    markdown_text += f\"{emoji}&nbsp;<strong>Security concerns</strong><br><br>\\n\\n\"\n                    value = emphasize_header(value.strip())\n                    markdown_text += f\"{value}\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                if is_value_no(value):\n                    markdown_text += f'### {emoji} No security concerns identified\\n\\n'\n                else:\n                    markdown_text += f\"### {emoji} Security concerns\\n\\n\"\n                    value = emphasize_header(value.strip(), only_markdown=True)\n                    markdown_text += f\"{value}\\n\\n\"\n        elif 'can be split' in key_nice.lower():\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                markdown_text += process_can_be_split(emoji, value)\n                markdown_text += f\"</td></tr>\\n\"\n        elif 'key issues to review' in key_nice.lower():\n            # value is a list of issues\n            if is_value_no(value):\n                if gfm_supported:\n                    markdown_text += f\"<tr><td>\"\n                    markdown_text += f\"{emoji}&nbsp;<strong>No major issues detected</strong>\"\n                    markdown_text += f\"</td></tr>\\n\"\n                else:\n                    markdown_text += f\"### {emoji} No major issues detected\\n\\n\"\n            else:\n                issues = value\n                if gfm_supported:\n                    markdown_text += f\"<tr><td>\"\n                    # markdown_text += f\"{emoji}&nbsp;<strong>{key_nice}</strong><br><br>\\n\\n\"\n                    markdown_text += f\"{emoji}&nbsp;<strong>Recommended focus areas for review</strong><br><br>\\n\\n\"\n                else:\n                    markdown_text += f\"### {emoji} Recommended focus areas for review\\n\\n#### \\n\"\n                for i, issue in enumerate(issues):\n                    try:\n                        if not issue or not isinstance(issue, dict):\n                            continue\n                        relevant_file = issue.get('relevant_file', '').strip()\n                        issue_header = issue.get('issue_header', '').strip()\n                        if issue_header.lower() == 'possible bug':\n                            issue_header = 'Possible Issue'  # Make the header less frightening\n                        issue_content = issue.get('issue_content', '').strip()\n                        start_line = int(str(issue.get('start_line', 0)).strip())\n                        end_line = int(str(issue.get('end_line', 0)).strip())\n\n                        relevant_lines_str = extract_relevant_lines_str(end_line, files, relevant_file, start_line, dedent=True)\n                        if git_provider:\n                            reference_link = git_provider.get_line_link(relevant_file, start_line, end_line)\n                        else:\n                            reference_link = None\n\n                        if gfm_supported:\n                            if reference_link is not None and len(reference_link) > 0:\n                                if relevant_lines_str:\n                                    issue_str = f\"<details><summary><a href='{reference_link}'><strong>{issue_header}</strong></a>\\n\\n{issue_content}\\n</summary>\\n\\n{relevant_lines_str}\\n\\n</details>\"\n                                else:\n                                    issue_str = f\"<a href='{reference_link}'><strong>{issue_header}</strong></a><br>{issue_content}\"\n                            else:\n                                issue_str = f\"<strong>{issue_header}</strong><br>{issue_content}\"\n                        else:\n                            if reference_link is not None and len(reference_link) > 0:\n                                issue_str = f\"[**{issue_header}**]({reference_link})\\n\\n{issue_content}\\n\\n\"\n                            else:\n                                issue_str = f\"**{issue_header}**\\n\\n{issue_content}\\n\\n\"\n                        markdown_text += f\"{issue_str}\\n\\n\"\n                    except Exception as e:\n                        get_logger().exception(f\"Failed to process 'Recommended focus areas for review': {e}\")\n                if gfm_supported:\n                    markdown_text += f\"</td></tr>\\n\"\n        else:\n            if gfm_supported:\n                markdown_text += f\"<tr><td>\"\n                markdown_text += f\"{emoji}&nbsp;<strong>{key_nice}</strong>: {value}\"\n                markdown_text += f\"</td></tr>\\n\"\n            else:\n                markdown_text += f\"### {emoji} {key_nice}: {value}\\n\\n\"\n\n    if gfm_supported:\n        markdown_text += \"</table>\\n\"\n\n    return markdown_text",
    "start_line": 110,
    "end_line": 279,
    "has_docstring": true,
    "docstring": "Convert a dictionary of data into markdown format.\nArgs:\n    output_data (dict): A dictionary containing data to be converted to markdown format.\nReturns:\n    str: The markdown formatted text generated from the input dictionary.",
    "parameters": [
      "output_data",
      "gfm_supported",
      "incremental_review",
      "git_provider",
      "files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convert_to_markdown_v2",
    "component_id": "pr_agent.algo.utils.convert_to_markdown_v2"
  },
  "pr_agent.algo.utils.extract_relevant_lines_str": {
    "id": "pr_agent.algo.utils.extract_relevant_lines_str",
    "name": "extract_relevant_lines_str",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.algo.git_patch_processing.extract_hunk_lines_from_patch",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.utils.set_file_languages"
    ],
    "source_code": "def extract_relevant_lines_str(end_line, files, relevant_file, start_line, dedent=False) -> str:\n    \"\"\"\n    Finds 'relevant_file' in 'files', and extracts the lines from 'start_line' to 'end_line' string from the file content.\n    \"\"\"\n    try:\n        relevant_lines_str = \"\"\n        if files:\n            files = set_file_languages(files)\n            for file in files:\n                if file.filename.strip() == relevant_file:\n                    if not file.head_file:\n                        # as a fallback, extract relevant lines directly from patch\n                        patch = file.patch\n                        get_logger().info(f\"No content found in file: '{file.filename}' for 'extract_relevant_lines_str'. Using patch instead\")\n                        _, selected_lines = extract_hunk_lines_from_patch(patch, file.filename, start_line, end_line,side='right')\n                        if not selected_lines:\n                            get_logger().error(f\"Failed to extract relevant lines from patch: {file.filename}\")\n                            return \"\"\n                        # filter out '-' lines\n                        relevant_lines_str = \"\"\n                        for line in selected_lines.splitlines():\n                            if line.startswith('-'):\n                                continue\n                            relevant_lines_str += line[1:] + '\\n'\n                    else:\n                        relevant_file_lines = file.head_file.splitlines()\n                        relevant_lines_str = \"\\n\".join(relevant_file_lines[start_line - 1:end_line])\n\n                    if dedent and relevant_lines_str:\n                        # Remove the longest leading string of spaces and tabs common to all lines.\n                        relevant_lines_str = textwrap.dedent(relevant_lines_str)\n                    relevant_lines_str = f\"```{file.language}\\n{relevant_lines_str}\\n```\"\n                    break\n\n        return relevant_lines_str\n    except Exception as e:\n        get_logger().exception(f\"Failed to extract relevant lines: {e}\")\n        return \"\"",
    "start_line": 282,
    "end_line": 319,
    "has_docstring": true,
    "docstring": "Finds 'relevant_file' in 'files', and extracts the lines from 'start_line' to 'end_line' string from the file content.",
    "parameters": [
      "end_line",
      "files",
      "relevant_file",
      "start_line",
      "dedent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_relevant_lines_str",
    "component_id": "pr_agent.algo.utils.extract_relevant_lines_str"
  },
  "pr_agent.algo.utils.ticket_markdown_logic": {
    "id": "pr_agent.algo.utils.ticket_markdown_logic",
    "name": "ticket_markdown_logic",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def ticket_markdown_logic(emoji, markdown_text, value, gfm_supported) -> str:\n    ticket_compliance_str = \"\"\n    compliance_emoji = ''\n    # Track compliance levels across all tickets\n    all_compliance_levels = []\n\n    if isinstance(value, list):\n        for ticket_analysis in value:\n            try:\n                ticket_url = ticket_analysis.get('ticket_url', '').strip()\n                explanation = ''\n                ticket_compliance_level = ''  # Individual ticket compliance\n                fully_compliant_str = ticket_analysis.get('fully_compliant_requirements', '').strip()\n                not_compliant_str = ticket_analysis.get('not_compliant_requirements', '').strip()\n                requires_further_human_verification = ticket_analysis.get('requires_further_human_verification',\n                                                                          '').strip()\n\n                if not fully_compliant_str and not not_compliant_str:\n                    get_logger().debug(f\"Ticket compliance has no requirements\",\n                                       artifact={'ticket_url': ticket_url})\n                    continue\n\n                # Calculate individual ticket compliance level\n                if fully_compliant_str:\n                    if not_compliant_str:\n                        ticket_compliance_level = 'Partially compliant'\n                    else:\n                        if not requires_further_human_verification:\n                            ticket_compliance_level = 'Fully compliant'\n                        else:\n                            ticket_compliance_level = 'PR Code Verified'\n                elif not_compliant_str:\n                    ticket_compliance_level = 'Not compliant'\n\n                # Store the compliance level for aggregation\n                if ticket_compliance_level:\n                    all_compliance_levels.append(ticket_compliance_level)\n\n                # build compliance string\n                if fully_compliant_str:\n                    explanation += f\"Compliant requirements:\\n\\n{fully_compliant_str}\\n\\n\"\n                if not_compliant_str:\n                    explanation += f\"Non-compliant requirements:\\n\\n{not_compliant_str}\\n\\n\"\n                if requires_further_human_verification:\n                    explanation += f\"Requires further human verification:\\n\\n{requires_further_human_verification}\\n\\n\"\n                ticket_compliance_str += f\"\\n\\n**[{ticket_url.split('/')[-1]}]({ticket_url}) - {ticket_compliance_level}**\\n\\n{explanation}\\n\\n\"\n\n                # for debugging\n                if requires_further_human_verification:\n                    get_logger().debug(f\"Ticket compliance requires further human verification\",\n                                       artifact={'ticket_url': ticket_url,\n                                                 'requires_further_human_verification': requires_further_human_verification,\n                                                 'compliance_level': ticket_compliance_level})\n\n            except Exception as e:\n                get_logger().exception(f\"Failed to process ticket compliance: {e}\")\n                continue\n\n        # Calculate overall compliance level and emoji\n        if all_compliance_levels:\n            if all(level == 'Fully compliant' for level in all_compliance_levels):\n                compliance_level = 'Fully compliant'\n                compliance_emoji = ''\n            elif all(level == 'PR Code Verified' for level in all_compliance_levels):\n                compliance_level = 'PR Code Verified'\n                compliance_emoji = ''\n            elif any(level == 'Not compliant' for level in all_compliance_levels):\n                # If there's a mix of compliant and non-compliant tickets\n                if any(level in ['Fully compliant', 'PR Code Verified'] for level in all_compliance_levels):\n                    compliance_level = 'Partially compliant'\n                    compliance_emoji = ''\n                else:\n                    compliance_level = 'Not compliant'\n                    compliance_emoji = ''\n            elif any(level == 'Partially compliant' for level in all_compliance_levels):\n                compliance_level = 'Partially compliant'\n                compliance_emoji = ''\n            else:\n                compliance_level = 'PR Code Verified'\n                compliance_emoji = ''\n\n            # Set extra statistics outside the ticket loop\n            get_settings().set('config.extra_statistics', {'compliance_level': compliance_level})\n\n        # editing table row for ticket compliance analysis\n        if gfm_supported:\n            markdown_text += f\"<tr><td>\\n\\n\"\n            markdown_text += f\"**{emoji} Ticket compliance analysis {compliance_emoji}**\\n\\n\"\n            markdown_text += ticket_compliance_str\n            markdown_text += f\"</td></tr>\\n\"\n        else:\n            markdown_text += f\"### {emoji} Ticket compliance analysis {compliance_emoji}\\n\\n\"\n            markdown_text += ticket_compliance_str + \"\\n\\n\"\n\n    return markdown_text",
    "start_line": 322,
    "end_line": 416,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "emoji",
      "markdown_text",
      "value",
      "gfm_supported"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ticket_markdown_logic",
    "component_id": "pr_agent.algo.utils.ticket_markdown_logic"
  },
  "pr_agent.algo.utils.process_can_be_split": {
    "id": "pr_agent.algo.utils.process_can_be_split",
    "name": "process_can_be_split",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def process_can_be_split(emoji, value):\n    try:\n        # key_nice = \"Can this PR be split?\"\n        key_nice = \"Multiple PR themes\"\n        markdown_text = \"\"\n        if not value or isinstance(value, list) and len(value) == 1:\n            value = \"No\"\n            # markdown_text += f\"<tr><td> {emoji}&nbsp;<strong>{key_nice}</strong></td><td>\\n\\n{value}\\n\\n</td></tr>\\n\"\n            # markdown_text += f\"### {emoji} No multiple PR themes\\n\\n\"\n            markdown_text += f\"{emoji} <strong>No multiple PR themes</strong>\\n\\n\"\n        else:\n            markdown_text += f\"{emoji} <strong>{key_nice}</strong><br><br>\\n\\n\"\n            for i, split in enumerate(value):\n                title = split.get('title', '')\n                relevant_files = split.get('relevant_files', [])\n                markdown_text += f\"<details><summary>\\nSub-PR theme: <b>{title}</b></summary>\\n\\n\"\n                markdown_text += f\"___\\n\\nRelevant files:\\n\\n\"\n                for file in relevant_files:\n                    markdown_text += f\"- {file}\\n\"\n                markdown_text += f\"___\\n\\n\"\n                markdown_text += f\"</details>\\n\\n\"\n\n                # markdown_text += f\"#### Sub-PR theme: {title}\\n\\n\"\n                # markdown_text += f\"Relevant files:\\n\\n\"\n                # for file in relevant_files:\n                #     markdown_text += f\"- {file}\\n\"\n                # markdown_text += \"\\n\"\n            # number_of_splits = len(value)\n            # markdown_text += f\"<tr><td rowspan={number_of_splits}> {emoji}&nbsp;<strong>{key_nice}</strong></td>\\n\"\n            # for i, split in enumerate(value):\n            #     title = split.get('title', '')\n            #     relevant_files = split.get('relevant_files', [])\n            #     if i == 0:\n            #         markdown_text += f\"<td><details><summary>\\nSub-PR theme:<br><strong>{title}</strong></summary>\\n\\n\"\n            #         markdown_text += f\"<hr>\\n\"\n            #         markdown_text += f\"Relevant files:\\n\"\n            #         markdown_text += f\"<ul>\\n\"\n            #         for file in relevant_files:\n            #             markdown_text += f\"<li>{file}</li>\\n\"\n            #         markdown_text += f\"</ul>\\n\\n</details></td></tr>\\n\"\n            #     else:\n            #         markdown_text += f\"<tr>\\n<td><details><summary>\\nSub-PR theme:<br><strong>{title}</strong></summary>\\n\\n\"\n            #         markdown_text += f\"<hr>\\n\"\n            #         markdown_text += f\"Relevant files:\\n\"\n            #         markdown_text += f\"<ul>\\n\"\n            #         for file in relevant_files:\n            #             markdown_text += f\"<li>{file}</li>\\n\"\n            #         markdown_text += f\"</ul>\\n\\n</details></td></tr>\\n\"\n    except Exception as e:\n        get_logger().exception(f\"Failed to process can be split: {e}\")\n        return \"\"\n    return markdown_text",
    "start_line": 419,
    "end_line": 470,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "emoji",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_can_be_split",
    "component_id": "pr_agent.algo.utils.process_can_be_split"
  },
  "pr_agent.algo.utils.parse_code_suggestion": {
    "id": "pr_agent.algo.utils.parse_code_suggestion",
    "name": "parse_code_suggestion",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def parse_code_suggestion(code_suggestion: dict, i: int = 0, gfm_supported: bool = True) -> str:\n    \"\"\"\n    Convert a dictionary of data into markdown format.\n\n    Args:\n        code_suggestion (dict): A dictionary containing data to be converted to markdown format.\n\n    Returns:\n        str: A string containing the markdown formatted text generated from the input dictionary.\n    \"\"\"\n    markdown_text = \"\"\n    if gfm_supported and 'relevant_line' in code_suggestion:\n        markdown_text += '<table>'\n        for sub_key, sub_value in code_suggestion.items():\n            try:\n                if sub_key.lower() == 'relevant_file':\n                    relevant_file = sub_value.strip('`').strip('\"').strip(\"'\")\n                    markdown_text += f\"<tr><td>relevant file</td><td>{relevant_file}</td></tr>\"\n                    # continue\n                elif sub_key.lower() == 'suggestion':\n                    markdown_text += (f\"<tr><td>{sub_key} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\"\n                                      f\"<td>\\n\\n<strong>\\n\\n{sub_value.strip()}\\n\\n</strong>\\n</td></tr>\")\n                elif sub_key.lower() == 'relevant_line':\n                    markdown_text += f\"<tr><td>relevant line</td>\"\n                    sub_value_list = sub_value.split('](')\n                    relevant_line = sub_value_list[0].lstrip('`').lstrip('[')\n                    if len(sub_value_list) > 1:\n                        link = sub_value_list[1].rstrip(')').strip('`')\n                        markdown_text += f\"<td><a href='{link}'>{relevant_line}</a></td>\"\n                    else:\n                        markdown_text += f\"<td>{relevant_line}</td>\"\n                    markdown_text += \"</tr>\"\n            except Exception as e:\n                get_logger().exception(f\"Failed to parse code suggestion: {e}\")\n                pass\n        markdown_text += '</table>'\n        markdown_text += \"<hr>\"\n    else:\n        for sub_key, sub_value in code_suggestion.items():\n            if isinstance(sub_key, str):\n                sub_key = sub_key.rstrip()\n            if isinstance(sub_value,str):\n                sub_value = sub_value.rstrip()\n            if isinstance(sub_value, dict):  # \"code example\"\n                markdown_text += f\"  - **{sub_key}:**\\n\"\n                for code_key, code_value in sub_value.items():  # 'before' and 'after' code\n                    code_str = f\"```\\n{code_value}\\n```\"\n                    code_str_indented = textwrap.indent(code_str, '        ')\n                    markdown_text += f\"    - **{code_key}:**\\n{code_str_indented}\\n\"\n            else:\n                if \"relevant_file\" in sub_key.lower():\n                    markdown_text += f\"\\n  - **{sub_key}:** {sub_value}  \\n\"\n                else:\n                    markdown_text += f\"   **{sub_key}:** {sub_value}  \\n\"\n                if \"relevant_line\" not in sub_key.lower():  # nicer presentation\n                    # markdown_text = markdown_text.rstrip('\\n') + \"\\\\\\n\" # works for gitlab\n                    markdown_text = markdown_text.rstrip('\\n') + \"   \\n\"  # works for gitlab and bitbucker\n\n        markdown_text += \"\\n\"\n    return markdown_text",
    "start_line": 473,
    "end_line": 532,
    "has_docstring": true,
    "docstring": "Convert a dictionary of data into markdown format.\n\nArgs:\n    code_suggestion (dict): A dictionary containing data to be converted to markdown format.\n\nReturns:\n    str: A string containing the markdown formatted text generated from the input dictionary.",
    "parameters": [
      "code_suggestion",
      "i",
      "gfm_supported"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_code_suggestion",
    "component_id": "pr_agent.algo.utils.parse_code_suggestion"
  },
  "pr_agent.algo.utils.try_fix_json": {
    "id": "pr_agent.algo.utils.try_fix_json",
    "name": "try_fix_json",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.algo.utils.fix_json_escape_char",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def try_fix_json(review, max_iter=10, code_suggestions=False):\n    \"\"\"\n    Fix broken or incomplete JSON messages and return the parsed JSON data.\n\n    Args:\n    - review: A string containing the JSON message to be fixed.\n    - max_iter: An integer representing the maximum number of iterations to try and fix the JSON message.\n    - code_suggestions: A boolean indicating whether to try and fix JSON messages with code feedback.\n\n    Returns:\n    - data: A dictionary containing the parsed JSON data.\n\n    The function attempts to fix broken or incomplete JSON messages by parsing until the last valid code suggestion.\n    If the JSON message ends with a closing bracket, the function calls the fix_json_escape_char function to fix the\n    message.\n    If code_suggestions is True and the JSON message contains code feedback, the function tries to fix the JSON\n    message by parsing until the last valid code suggestion.\n    The function uses regular expressions to find the last occurrence of \"},\" with any number of whitespaces or\n    newlines.\n    It tries to parse the JSON message with the closing bracket and checks if it is valid.\n    If the JSON message is valid, the parsed JSON data is returned.\n    If the JSON message is not valid, the last code suggestion is removed and the process is repeated until a valid JSON\n    message is obtained or the maximum number of iterations is reached.\n    If a valid JSON message is not obtained, an error is logged and an empty dictionary is returned.\n    \"\"\"\n\n    if review.endswith(\"}\"):\n        return fix_json_escape_char(review)\n\n    data = {}\n    if code_suggestions:\n        closing_bracket = \"]}\"\n    else:\n        closing_bracket = \"]}}\"\n\n    if (review.rfind(\"'Code feedback': [\") > 0 or review.rfind('\"Code feedback\": [') > 0) or \\\n            (review.rfind(\"'Code suggestions': [\") > 0 or review.rfind('\"Code suggestions\": [') > 0) :\n        last_code_suggestion_ind = [m.end() for m in re.finditer(r\"\\}\\s*,\", review)][-1] - 1\n        valid_json = False\n        iter_count = 0\n\n        while last_code_suggestion_ind > 0 and not valid_json and iter_count < max_iter:\n            try:\n                data = json.loads(review[:last_code_suggestion_ind] + closing_bracket)\n                valid_json = True\n                review = review[:last_code_suggestion_ind].strip() + closing_bracket\n            except json.decoder.JSONDecodeError:\n                review = review[:last_code_suggestion_ind]\n                last_code_suggestion_ind = [m.end() for m in re.finditer(r\"\\}\\s*,\", review)][-1] - 1\n                iter_count += 1\n\n        if not valid_json:\n            get_logger().error(\"Unable to decode JSON response from AI\")\n            data = {}\n\n    return data",
    "start_line": 535,
    "end_line": 590,
    "has_docstring": true,
    "docstring": "Fix broken or incomplete JSON messages and return the parsed JSON data.\n\nArgs:\n- review: A string containing the JSON message to be fixed.\n- max_iter: An integer representing the maximum number of iterations to try and fix the JSON message.\n- code_suggestions: A boolean indicating whether to try and fix JSON messages with code feedback.\n\nReturns:\n- data: A dictionary containing the parsed JSON data.\n\nThe function attempts to fix broken or incomplete JSON messages by parsing until the last valid code suggestion.\nIf the JSON message ends with a closing bracket, the function calls the fix_json_escape_char function to fix the\nmessage.\nIf code_suggestions is True and the JSON message contains code feedback, the function tries to fix the JSON\nmessage by parsing until the last valid code suggestion.\nThe function uses regular expressions to find the last occurrence of \"},\" with any number of whitespaces or\nnewlines.\nIt tries to parse the JSON message with the closing bracket and checks if it is valid.\nIf the JSON message is valid, the parsed JSON data is returned.\nIf the JSON message is not valid, the last code suggestion is removed and the process is repeated until a valid JSON\nmessage is obtained or the maximum number of iterations is reached.\nIf a valid JSON message is not obtained, an error is logged and an empty dictionary is returned.",
    "parameters": [
      "review",
      "max_iter",
      "code_suggestions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function try_fix_json",
    "component_id": "pr_agent.algo.utils.try_fix_json"
  },
  "pr_agent.algo.utils.fix_json_escape_char": {
    "id": "pr_agent.algo.utils.fix_json_escape_char",
    "name": "fix_json_escape_char",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.algo.utils.fix_json_escape_char"
    ],
    "source_code": "def fix_json_escape_char(json_message=None):\n    \"\"\"\n    Fix broken or incomplete JSON messages and return the parsed JSON data.\n\n    Args:\n        json_message (str): A string containing the JSON message to be fixed.\n\n    Returns:\n        dict: A dictionary containing the parsed JSON data.\n\n    Raises:\n        None\n\n    \"\"\"\n    try:\n        result = json.loads(json_message)\n    except Exception as e:\n        # Find the offending character index:\n        idx_to_replace = int(str(e).split(' ')[-1].replace(')', ''))\n        # Remove the offending character:\n        json_message = list(json_message)\n        json_message[idx_to_replace] = ' '\n        new_message = ''.join(json_message)\n        return fix_json_escape_char(json_message=new_message)\n    return result",
    "start_line": 593,
    "end_line": 617,
    "has_docstring": true,
    "docstring": "Fix broken or incomplete JSON messages and return the parsed JSON data.\n\nArgs:\n    json_message (str): A string containing the JSON message to be fixed.\n\nReturns:\n    dict: A dictionary containing the parsed JSON data.\n\nRaises:\n    None",
    "parameters": [
      "json_message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fix_json_escape_char",
    "component_id": "pr_agent.algo.utils.fix_json_escape_char"
  },
  "pr_agent.algo.utils.convert_str_to_datetime": {
    "id": "pr_agent.algo.utils.convert_str_to_datetime",
    "name": "convert_str_to_datetime",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def convert_str_to_datetime(date_str):\n    \"\"\"\n    Convert a string representation of a date and time into a datetime object.\n\n    Args:\n        date_str (str): A string representation of a date and time in the format '%a, %d %b %Y %H:%M:%S %Z'\n\n    Returns:\n        datetime: A datetime object representing the input date and time.\n\n    Example:\n        >>> convert_str_to_datetime('Mon, 01 Jan 2022 12:00:00 UTC')\n        datetime.datetime(2022, 1, 1, 12, 0, 0)\n    \"\"\"\n    datetime_format = '%a, %d %b %Y %H:%M:%S %Z'\n    return datetime.strptime(date_str, datetime_format)",
    "start_line": 620,
    "end_line": 635,
    "has_docstring": true,
    "docstring": "Convert a string representation of a date and time into a datetime object.\n\nArgs:\n    date_str (str): A string representation of a date and time in the format '%a, %d %b %Y %H:%M:%S %Z'\n\nReturns:\n    datetime: A datetime object representing the input date and time.\n\nExample:\n    >>> convert_str_to_datetime('Mon, 01 Jan 2022 12:00:00 UTC')\n    datetime.datetime(2022, 1, 1, 12, 0, 0)",
    "parameters": [
      "date_str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convert_str_to_datetime",
    "component_id": "pr_agent.algo.utils.convert_str_to_datetime"
  },
  "pr_agent.algo.utils.load_large_diff": {
    "id": "pr_agent.algo.utils.load_large_diff",
    "name": "load_large_diff",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def load_large_diff(filename, new_file_content_str: str, original_file_content_str: str, show_warning: bool = True) -> str:\n    \"\"\"\n    Generate a patch for a modified file by comparing the original content of the file with the new content provided as\n    input.\n    \"\"\"\n    if not original_file_content_str and not new_file_content_str:\n        return \"\"\n\n    try:\n        original_file_content_str = (original_file_content_str or \"\").rstrip() + \"\\n\"\n        new_file_content_str = (new_file_content_str or \"\").rstrip() + \"\\n\"\n        diff = difflib.unified_diff(original_file_content_str.splitlines(keepends=True),\n                                    new_file_content_str.splitlines(keepends=True))\n        if get_settings().config.verbosity_level >= 2 and show_warning:\n            get_logger().info(f\"File was modified, but no patch was found. Manually creating patch: {filename}.\")\n        patch = ''.join(diff)\n        return patch\n    except Exception as e:\n        get_logger().exception(f\"Failed to generate patch for file: {filename}\")\n        return \"\"",
    "start_line": 638,
    "end_line": 657,
    "has_docstring": true,
    "docstring": "Generate a patch for a modified file by comparing the original content of the file with the new content provided as\ninput.",
    "parameters": [
      "filename",
      "new_file_content_str",
      "original_file_content_str",
      "show_warning"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_large_diff",
    "component_id": "pr_agent.algo.utils.load_large_diff"
  },
  "pr_agent.algo.utils.update_settings_from_args": {
    "id": "pr_agent.algo.utils.update_settings_from_args",
    "name": "update_settings_from_args",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.algo.utils._fix_key_value",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def update_settings_from_args(args: List[str]) -> List[str]:\n    \"\"\"\n    Update the settings of the Dynaconf object based on the arguments passed to the function.\n\n    Args:\n        args: A list of arguments passed to the function.\n        Example args: ['--pr_code_suggestions.extra_instructions=\"be funny',\n                  '--pr_code_suggestions.num_code_suggestions=3']\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the argument is not in the correct format.\n\n    \"\"\"\n    other_args = []\n    if args:\n        for arg in args:\n            arg = arg.strip()\n            if arg.startswith('--'):\n                arg = arg.strip('-').strip()\n                vals = arg.split('=', 1)\n                if len(vals) != 2:\n                    if len(vals) > 2:  # --extended is a valid argument\n                        get_logger().error(f'Invalid argument format: {arg}')\n                    other_args.append(arg)\n                    continue\n                key, value = _fix_key_value(*vals)\n                get_settings().set(key, value)\n                get_logger().info(f'Updated setting {key} to: \"{value}\"')\n            else:\n                other_args.append(arg)\n    return other_args",
    "start_line": 660,
    "end_line": 693,
    "has_docstring": true,
    "docstring": "Update the settings of the Dynaconf object based on the arguments passed to the function.\n\nArgs:\n    args: A list of arguments passed to the function.\n    Example args: ['--pr_code_suggestions.extra_instructions=\"be funny',\n              '--pr_code_suggestions.num_code_suggestions=3']\n\nReturns:\n    None\n\nRaises:\n    ValueError: If the argument is not in the correct format.",
    "parameters": [
      "args"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_settings_from_args",
    "component_id": "pr_agent.algo.utils.update_settings_from_args"
  },
  "pr_agent.algo.utils._fix_key_value": {
    "id": "pr_agent.algo.utils._fix_key_value",
    "name": "_fix_key_value",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def _fix_key_value(key: str, value: str):\n    key = key.strip().upper()\n    value = value.strip()\n    try:\n        value = yaml.safe_load(value)\n    except Exception as e:\n        get_logger().debug(f\"Failed to parse YAML for config override {key}={value}\", exc_info=e)\n    return key, value",
    "start_line": 696,
    "end_line": 703,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "key",
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _fix_key_value",
    "component_id": "pr_agent.algo.utils._fix_key_value"
  },
  "pr_agent.algo.utils.load_yaml": {
    "id": "pr_agent.algo.utils.load_yaml",
    "name": "load_yaml",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.utils.try_fix_yaml"
    ],
    "source_code": "def load_yaml(response_text: str, keys_fix_yaml: List[str] = [], first_key=\"\", last_key=\"\") -> dict:\n    response_text_original = copy.deepcopy(response_text)\n    response_text = response_text.strip('\\n').removeprefix('```yaml').rstrip().removesuffix('```')\n    try:\n        data = yaml.safe_load(response_text)\n    except Exception as e:\n        get_logger().warning(f\"Initial failure to parse AI prediction: {e}\")\n        data = try_fix_yaml(response_text, keys_fix_yaml=keys_fix_yaml, first_key=first_key, last_key=last_key,\n                            response_text_original=response_text_original)\n        if not data:\n            get_logger().error(f\"Failed to parse AI prediction after fallbacks\",\n                               artifact={'response_text': response_text})\n        else:\n            get_logger().info(f\"Successfully parsed AI prediction after fallbacks\",\n                              artifact={'response_text': response_text})\n    return data",
    "start_line": 706,
    "end_line": 721,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "response_text",
      "keys_fix_yaml",
      "first_key",
      "last_key"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_yaml",
    "component_id": "pr_agent.algo.utils.load_yaml"
  },
  "pr_agent.algo.utils.try_fix_yaml": {
    "id": "pr_agent.algo.utils.try_fix_yaml",
    "name": "try_fix_yaml",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def try_fix_yaml(response_text: str,\n                 keys_fix_yaml: List[str] = [],\n                 first_key=\"\",\n                 last_key=\"\",\n                 response_text_original=\"\") -> dict:\n    response_text_lines = response_text.split('\\n')\n\n    keys_yaml = ['relevant line:', 'suggestion content:', 'relevant file:', 'existing code:', 'improved code:']\n    keys_yaml = keys_yaml + keys_fix_yaml\n    # first fallback - try to convert 'relevant line: ...' to relevant line: |-\\n        ...'\n    response_text_lines_copy = response_text_lines.copy()\n    for i in range(0, len(response_text_lines_copy)):\n        for key in keys_yaml:\n            if key in response_text_lines_copy[i] and not '|' in response_text_lines_copy[i]:\n                response_text_lines_copy[i] = response_text_lines_copy[i].replace(f'{key}',\n                                                                                  f'{key} |\\n        ')\n    try:\n        data = yaml.safe_load('\\n'.join(response_text_lines_copy))\n        get_logger().info(f\"Successfully parsed AI prediction after adding |-\\n\")\n        return data\n    except:\n        pass\n\n    # second fallback - try to extract only range from first ```yaml to ````\n    snippet_pattern = r'```(yaml)?[\\s\\S]*?```'\n    snippet = re.search(snippet_pattern, '\\n'.join(response_text_lines_copy))\n    if not snippet:\n        snippet = re.search(snippet_pattern, response_text_original) # before we removed the \"```\"\n    if snippet:\n        snippet_text = snippet.group()\n        try:\n            data = yaml.safe_load(snippet_text.removeprefix('```yaml').rstrip('`'))\n            get_logger().info(f\"Successfully parsed AI prediction after extracting yaml snippet\")\n            return data\n        except:\n            pass\n\n\n    # third fallback - try to remove leading and trailing curly brackets\n    response_text_copy = response_text.strip().rstrip().removeprefix('{').removesuffix('}').rstrip(':\\n')\n    try:\n        data = yaml.safe_load(response_text_copy)\n        get_logger().info(f\"Successfully parsed AI prediction after removing curly brackets\")\n        return data\n    except:\n        pass\n\n\n    # forth fallback - try to extract yaml snippet by 'first_key' and 'last_key'\n    # note that 'last_key' can be in practice a key that is not the last key in the yaml snippet.\n    # it just needs to be some inner key, so we can look for newlines after it\n    if first_key and last_key:\n        index_start = response_text.find(f\"\\n{first_key}:\")\n        if index_start == -1:\n            index_start = response_text.find(f\"{first_key}:\")\n        index_last_code = response_text.rfind(f\"{last_key}:\")\n        index_end = response_text.find(\"\\n\\n\", index_last_code) # look for newlines after last_key\n        if index_end == -1:\n            index_end = len(response_text)\n        response_text_copy = response_text[index_start:index_end].strip().strip('```yaml').strip('`').strip()\n        try:\n            data = yaml.safe_load(response_text_copy)\n            get_logger().info(f\"Successfully parsed AI prediction after extracting yaml snippet\")\n            return data\n        except:\n            pass\n\n    # fifth fallback - try to remove leading '+' (sometimes added by AI for 'existing code' and 'improved code')\n    response_text_lines_copy = response_text_lines.copy()\n    for i in range(0, len(response_text_lines_copy)):\n        if response_text_lines_copy[i].startswith('+'):\n            response_text_lines_copy[i] = ' ' + response_text_lines_copy[i][1:]\n    try:\n        data = yaml.safe_load('\\n'.join(response_text_lines_copy))\n        get_logger().info(f\"Successfully parsed AI prediction after removing leading '+'\")\n        return data\n    except:\n        pass\n\n    # sixth fallback - try to remove last lines\n    for i in range(1, len(response_text_lines)):\n        response_text_lines_tmp = '\\n'.join(response_text_lines[:-i])\n        try:\n            data = yaml.safe_load(response_text_lines_tmp)\n            get_logger().info(f\"Successfully parsed AI prediction after removing {i} lines\")\n            return data\n        except:\n            pass",
    "start_line": 725,
    "end_line": 812,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "response_text",
      "keys_fix_yaml",
      "first_key",
      "last_key",
      "response_text_original"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function try_fix_yaml",
    "component_id": "pr_agent.algo.utils.try_fix_yaml"
  },
  "pr_agent.algo.utils.set_custom_labels": {
    "id": "pr_agent.algo.utils.set_custom_labels",
    "name": "set_custom_labels",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def set_custom_labels(variables, git_provider=None):\n    if not get_settings().config.enable_custom_labels:\n        return\n\n    labels = get_settings().get('custom_labels', {})\n    if not labels:\n        # set default labels\n        labels = ['Bug fix', 'Tests', 'Bug fix with tests', 'Enhancement', 'Documentation', 'Other']\n        labels_list = \"\\n      - \".join(labels) if labels else \"\"\n        labels_list = f\"      - {labels_list}\" if labels_list else \"\"\n        variables[\"custom_labels\"] = labels_list\n        return\n\n    # Set custom labels\n    variables[\"custom_labels_class\"] = \"class Label(str, Enum):\"\n    counter = 0\n    labels_minimal_to_labels_dict = {}\n    for k, v in labels.items():\n        description = \"'\" + v['description'].strip('\\n').replace('\\n', '\\\\n') + \"'\"\n        # variables[\"custom_labels_class\"] += f\"\\n    {k.lower().replace(' ', '_')} = '{k}' # {description}\"\n        variables[\"custom_labels_class\"] += f\"\\n    {k.lower().replace(' ', '_')} = {description}\"\n        labels_minimal_to_labels_dict[k.lower().replace(' ', '_')] = k\n        counter += 1\n    variables[\"labels_minimal_to_labels_dict\"] = labels_minimal_to_labels_dict",
    "start_line": 815,
    "end_line": 838,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "variables",
      "git_provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function set_custom_labels",
    "component_id": "pr_agent.algo.utils.set_custom_labels"
  },
  "pr_agent.algo.utils.get_user_labels": {
    "id": "pr_agent.algo.utils.get_user_labels",
    "name": "get_user_labels",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_user_labels(current_labels: List[str] = None):\n    \"\"\"\n    Only keep labels that has been added by the user\n    \"\"\"\n    try:\n        enable_custom_labels = get_settings().config.get('enable_custom_labels', False)\n        custom_labels = get_settings().get('custom_labels', [])\n        if current_labels is None:\n            current_labels = []\n        user_labels = []\n        for label in current_labels:\n            if label.lower() in ['bug fix', 'tests', 'enhancement', 'documentation', 'other']:\n                continue\n            if enable_custom_labels:\n                if label in custom_labels:\n                    continue\n            user_labels.append(label)\n        if user_labels:\n            get_logger().debug(f\"Keeping user labels: {user_labels}\")\n    except Exception as e:\n        get_logger().exception(f\"Failed to get user labels: {e}\")\n        return current_labels\n    return user_labels",
    "start_line": 840,
    "end_line": 862,
    "has_docstring": true,
    "docstring": "Only keep labels that has been added by the user",
    "parameters": [
      "current_labels"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_user_labels",
    "component_id": "pr_agent.algo.utils.get_user_labels"
  },
  "pr_agent.algo.utils.get_max_tokens": {
    "id": "pr_agent.algo.utils.get_max_tokens",
    "name": "get_max_tokens",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_max_tokens(model):\n    \"\"\"\n    Get the maximum number of tokens allowed for a model.\n    logic:\n    (1) If the model is in './pr_agent/algo/__init__.py', use the value from there.\n    (2) else, the user needs to define explicitly 'config.custom_model_max_tokens'\n\n    For both cases, we further limit the number of tokens to 'config.max_model_tokens' if it is set.\n    This aims to improve the algorithmic quality, as the AI model degrades in performance when the input is too long.\n    \"\"\"\n    settings = get_settings()\n    if model in MAX_TOKENS:\n        max_tokens_model = MAX_TOKENS[model]\n    elif settings.config.custom_model_max_tokens > 0:\n        max_tokens_model = settings.config.custom_model_max_tokens\n    else:\n        raise Exception(f\"Ensure {model} is defined in MAX_TOKENS in ./pr_agent/algo/__init__.py or set a positive value for it in config.custom_model_max_tokens\")\n\n    if settings.config.max_model_tokens and settings.config.max_model_tokens > 0:\n        max_tokens_model = min(settings.config.max_model_tokens, max_tokens_model)\n    return max_tokens_model",
    "start_line": 865,
    "end_line": 885,
    "has_docstring": true,
    "docstring": "Get the maximum number of tokens allowed for a model.\nlogic:\n(1) If the model is in './pr_agent/algo/__init__.py', use the value from there.\n(2) else, the user needs to define explicitly 'config.custom_model_max_tokens'\n\nFor both cases, we further limit the number of tokens to 'config.max_model_tokens' if it is set.\nThis aims to improve the algorithmic quality, as the AI model degrades in performance when the input is too long.",
    "parameters": [
      "model"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_max_tokens",
    "component_id": "pr_agent.algo.utils.get_max_tokens"
  },
  "pr_agent.algo.utils.clip_tokens": {
    "id": "pr_agent.algo.utils.clip_tokens",
    "name": "clip_tokens",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def clip_tokens(text: str, max_tokens: int, add_three_dots=True, num_input_tokens=None, delete_last_line=False) -> str:\n    \"\"\"\n    Clip the number of tokens in a string to a maximum number of tokens.\n\n    Args:\n        text (str): The string to clip.\n        max_tokens (int): The maximum number of tokens allowed in the string.\n        add_three_dots (bool, optional): A boolean indicating whether to add three dots at the end of the clipped\n    Returns:\n        str: The clipped string.\n    \"\"\"\n    if not text:\n        return text\n\n    try:\n        if num_input_tokens is None:\n            encoder = TokenEncoder.get_token_encoder()\n            num_input_tokens = len(encoder.encode(text))\n        if num_input_tokens <= max_tokens:\n            return text\n        if max_tokens < 0:\n            return \"\"\n\n        # calculate the number of characters to keep\n        num_chars = len(text)\n        chars_per_token = num_chars / num_input_tokens\n        factor = 0.9  # reduce by 10% to be safe\n        num_output_chars = int(factor * chars_per_token * max_tokens)\n\n        # clip the text\n        if num_output_chars > 0:\n            clipped_text = text[:num_output_chars]\n            if delete_last_line:\n                clipped_text = clipped_text.rsplit('\\n', 1)[0]\n            if add_three_dots:\n                clipped_text += \"\\n...(truncated)\"\n        else: # if the text is empty\n            clipped_text =  \"\"\n\n        return clipped_text\n    except Exception as e:\n        get_logger().warning(f\"Failed to clip tokens: {e}\")\n        return text",
    "start_line": 888,
    "end_line": 930,
    "has_docstring": true,
    "docstring": "Clip the number of tokens in a string to a maximum number of tokens.\n\nArgs:\n    text (str): The string to clip.\n    max_tokens (int): The maximum number of tokens allowed in the string.\n    add_three_dots (bool, optional): A boolean indicating whether to add three dots at the end of the clipped\nReturns:\n    str: The clipped string.",
    "parameters": [
      "text",
      "max_tokens",
      "add_three_dots",
      "num_input_tokens",
      "delete_last_line"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clip_tokens",
    "component_id": "pr_agent.algo.utils.clip_tokens"
  },
  "pr_agent.algo.utils.replace_code_tags": {
    "id": "pr_agent.algo.utils.replace_code_tags",
    "name": "replace_code_tags",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def replace_code_tags(text):\n    \"\"\"\n    Replace odd instances of ` with <code> and even instances of ` with </code>\n    \"\"\"\n    text = html.escape(text)\n    parts = text.split('`')\n    for i in range(1, len(parts), 2):\n        parts[i] = '<code>' + parts[i] + '</code>'\n    return ''.join(parts)",
    "start_line": 932,
    "end_line": 940,
    "has_docstring": true,
    "docstring": "Replace odd instances of ` with <code> and even instances of ` with </code>",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function replace_code_tags",
    "component_id": "pr_agent.algo.utils.replace_code_tags"
  },
  "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file": {
    "id": "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
    "name": "find_line_number_of_relevant_line_in_file",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def find_line_number_of_relevant_line_in_file(diff_files: List[FilePatchInfo],\n                                              relevant_file: str,\n                                              relevant_line_in_file: str,\n                                              absolute_position: int = None) -> Tuple[int, int]:\n    position = -1\n    if absolute_position is None:\n        absolute_position = -1\n    re_hunk_header = re.compile(\n        r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n\n    if not diff_files:\n        return position, absolute_position\n\n    for file in diff_files:\n        if file.filename and (file.filename.strip() == relevant_file):\n            patch = file.patch\n            patch_lines = patch.splitlines()\n            delta = 0\n            start1, size1, start2, size2 = 0, 0, 0, 0\n            if absolute_position != -1: # matching absolute to relative\n                for i, line in enumerate(patch_lines):\n                    # new hunk\n                    if line.startswith('@@'):\n                        delta = 0\n                        match = re_hunk_header.match(line)\n                        start1, size1, start2, size2 = map(int, match.groups()[:4])\n                    elif not line.startswith('-'):\n                        delta += 1\n\n                    #\n                    absolute_position_curr = start2 + delta - 1\n\n                    if absolute_position_curr == absolute_position:\n                        position = i\n                        break\n            else:\n                # try to find the line in the patch using difflib, with some margin of error\n                matches_difflib: list[str | Any] = difflib.get_close_matches(relevant_line_in_file,\n                                                                             patch_lines, n=3, cutoff=0.93)\n                if len(matches_difflib) == 1 and matches_difflib[0].startswith('+'):\n                    relevant_line_in_file = matches_difflib[0]\n\n\n                for i, line in enumerate(patch_lines):\n                    if line.startswith('@@'):\n                        delta = 0\n                        match = re_hunk_header.match(line)\n                        start1, size1, start2, size2 = map(int, match.groups()[:4])\n                    elif not line.startswith('-'):\n                        delta += 1\n\n                    if relevant_line_in_file in line and line[0] != '-':\n                        position = i\n                        absolute_position = start2 + delta - 1\n                        break\n\n                if position == -1 and relevant_line_in_file[0] == '+':\n                    no_plus_line = relevant_line_in_file[1:].lstrip()\n                    for i, line in enumerate(patch_lines):\n                        if line.startswith('@@'):\n                            delta = 0\n                            match = re_hunk_header.match(line)\n                            start1, size1, start2, size2 = map(int, match.groups()[:4])\n                        elif not line.startswith('-'):\n                            delta += 1\n\n                        if no_plus_line in line and line[0] != '-':\n                            # The model might add a '+' to the beginning of the relevant_line_in_file even if originally\n                            # it's a context line\n                            position = i\n                            absolute_position = start2 + delta - 1\n                            break\n    return position, absolute_position",
    "start_line": 943,
    "end_line": 1015,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "diff_files",
      "relevant_file",
      "relevant_line_in_file",
      "absolute_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function find_line_number_of_relevant_line_in_file",
    "component_id": "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file"
  },
  "pr_agent.algo.utils.get_rate_limit_status": {
    "id": "pr_agent.algo.utils.get_rate_limit_status",
    "name": "get_rate_limit_status",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_rate_limit_status(github_token) -> dict:\n    GITHUB_API_URL = get_settings(use_context=False).get(\"GITHUB.BASE_URL\", \"https://api.github.com\").rstrip(\"/\")  # \"https://api.github.com\"\n    # GITHUB_API_URL = \"https://api.github.com\"\n    RATE_LIMIT_URL = f\"{GITHUB_API_URL}/rate_limit\"\n    HEADERS = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": f\"token {github_token}\"\n    }\n\n    response = requests.get(RATE_LIMIT_URL, headers=HEADERS)\n    try:\n        rate_limit_info = response.json()\n        if rate_limit_info.get('message') == 'Rate limiting is not enabled.':  # for github enterprise\n            return {'resources': {}}\n        response.raise_for_status()  # Check for HTTP errors\n    except:  # retry\n        time.sleep(0.1)\n        response = requests.get(RATE_LIMIT_URL, headers=HEADERS)\n        return response.json()\n    return rate_limit_info",
    "start_line": 1017,
    "end_line": 1036,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "github_token"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_rate_limit_status",
    "component_id": "pr_agent.algo.utils.get_rate_limit_status"
  },
  "pr_agent.algo.utils.validate_rate_limit_github": {
    "id": "pr_agent.algo.utils.validate_rate_limit_github",
    "name": "validate_rate_limit_github",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.utils.get_rate_limit_status"
    ],
    "source_code": "def validate_rate_limit_github(github_token, installation_id=None, threshold=0.1) -> bool:\n    try:\n        rate_limit_status = get_rate_limit_status(github_token)\n        if installation_id:\n            get_logger().debug(f\"installation_id: {installation_id}, Rate limit status: {rate_limit_status['rate']}\")\n    # validate that the rate limit is not exceeded\n        # validate that the rate limit is not exceeded\n        for key, value in rate_limit_status['resources'].items():\n            if value['remaining'] < value['limit'] * threshold:\n                get_logger().error(f\"key: {key}, value: {value}\")\n                return False\n        return True\n    except Exception as e:\n        get_logger().error(f\"Error in rate limit {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})\n        return True",
    "start_line": 1039,
    "end_line": 1054,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "github_token",
      "installation_id",
      "threshold"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_rate_limit_github",
    "component_id": "pr_agent.algo.utils.validate_rate_limit_github"
  },
  "pr_agent.algo.utils.validate_and_await_rate_limit": {
    "id": "pr_agent.algo.utils.validate_and_await_rate_limit",
    "name": "validate_and_await_rate_limit",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.servers.github_polling.now",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.utils.get_rate_limit_status"
    ],
    "source_code": "def validate_and_await_rate_limit(github_token):\n    try:\n        rate_limit_status = get_rate_limit_status(github_token)\n        # validate that the rate limit is not exceeded\n        for key, value in rate_limit_status['resources'].items():\n            if value['remaining'] < value['limit'] // 80:\n                get_logger().error(f\"key: {key}, value: {value}\")\n                sleep_time_sec = value['reset'] - datetime.now().timestamp()\n                sleep_time_hour = sleep_time_sec / 3600.0\n                get_logger().error(f\"Rate limit exceeded. Sleeping for {sleep_time_hour} hours\")\n                if sleep_time_sec > 0:\n                    time.sleep(sleep_time_sec + 1)\n                rate_limit_status = get_rate_limit_status(github_token)\n        return rate_limit_status\n    except:\n        get_logger().error(\"Error in rate limit\")\n        return None",
    "start_line": 1057,
    "end_line": 1073,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "github_token"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_and_await_rate_limit",
    "component_id": "pr_agent.algo.utils.validate_and_await_rate_limit"
  },
  "pr_agent.algo.utils.github_action_output": {
    "id": "pr_agent.algo.utils.github_action_output",
    "name": "github_action_output",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def github_action_output(output_data: dict, key_name: str):\n    try:\n        if not get_settings().get('github_action_config.enable_output', False):\n            return\n\n        key_data = output_data.get(key_name, {})\n        with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:\n            print(f\"{key_name}={json.dumps(key_data, indent=None, ensure_ascii=False)}\", file=fh)\n    except Exception as e:\n        get_logger().error(f\"Failed to write to GitHub Action output: {e}\")\n    return",
    "start_line": 1076,
    "end_line": 1086,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "output_data",
      "key_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function github_action_output",
    "component_id": "pr_agent.algo.utils.github_action_output"
  },
  "pr_agent.algo.utils.show_relevant_configurations": {
    "id": "pr_agent.algo.utils.show_relevant_configurations",
    "name": "show_relevant_configurations",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def show_relevant_configurations(relevant_section: str) -> str:\n    skip_keys = ['ai_disclaimer', 'ai_disclaimer_title', 'ANALYTICS_FOLDER', 'secret_provider', \"skip_keys\", \"app_id\", \"redirect\",\n                      'trial_prefix_message', 'no_eligible_message', 'identity_provider', 'ALLOWED_REPOS','APP_NAME']\n    extra_skip_keys = get_settings().config.get('config.skip_keys', [])\n    if extra_skip_keys:\n        skip_keys.extend(extra_skip_keys)\n\n    markdown_text = \"\"\n    markdown_text += \"\\n<hr>\\n<details> <summary><strong> Relevant configurations:</strong></summary> \\n\\n\"\n    markdown_text +=\"<br>These are the relevant [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml) for this tool:\\n\\n\"\n    markdown_text += f\"**[config**]\\n```yaml\\n\\n\"\n    for key, value in get_settings().config.items():\n        if key in skip_keys:\n            continue\n        markdown_text += f\"{key}: {value}\\n\"\n    markdown_text += \"\\n```\\n\"\n    markdown_text += f\"\\n**[{relevant_section}]**\\n```yaml\\n\\n\"\n    for key, value in get_settings().get(relevant_section, {}).items():\n        if key in skip_keys:\n            continue\n        markdown_text += f\"{key}: {value}\\n\"\n    markdown_text += \"\\n```\"\n    markdown_text += \"\\n</details>\\n\"\n    return markdown_text",
    "start_line": 1089,
    "end_line": 1112,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "relevant_section"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_relevant_configurations",
    "component_id": "pr_agent.algo.utils.show_relevant_configurations"
  },
  "pr_agent.algo.utils.is_value_no": {
    "id": "pr_agent.algo.utils.is_value_no",
    "name": "is_value_no",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def is_value_no(value):\n    if not value:\n        return True\n    value_str = str(value).strip().lower()\n    if value_str == 'no' or value_str == 'none' or value_str == 'false':\n        return True\n    return False",
    "start_line": 1114,
    "end_line": 1120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_value_no",
    "component_id": "pr_agent.algo.utils.is_value_no"
  },
  "pr_agent.algo.utils.set_pr_string": {
    "id": "pr_agent.algo.utils.set_pr_string",
    "name": "set_pr_string",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def set_pr_string(repo_name, pr_number):\n    return f\"{repo_name}#{pr_number}\"",
    "start_line": 1123,
    "end_line": 1124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "repo_name",
      "pr_number"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function set_pr_string",
    "component_id": "pr_agent.algo.utils.set_pr_string"
  },
  "pr_agent.algo.utils.string_to_uniform_number": {
    "id": "pr_agent.algo.utils.string_to_uniform_number",
    "name": "string_to_uniform_number",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [],
    "source_code": "def string_to_uniform_number(s: str) -> float:\n    \"\"\"\n    Convert a string to a uniform number in the range [0, 1].\n    The uniform distribution is achieved by the nature of the SHA-256 hash function, which produces a uniformly distributed hash value over its output space.\n    \"\"\"\n    # Generate a hash of the string\n    hash_object = hashlib.sha256(s.encode())\n    # Convert the hash to an integer\n    hash_int = int(hash_object.hexdigest(), 16)\n    # Normalize the integer to the range [0, 1]\n    max_hash_int = 2 ** 256 - 1\n    uniform_number = float(hash_int) / max_hash_int\n    return uniform_number",
    "start_line": 1127,
    "end_line": 1139,
    "has_docstring": true,
    "docstring": "Convert a string to a uniform number in the range [0, 1].\nThe uniform distribution is achieved by the nature of the SHA-256 hash function, which produces a uniformly distributed hash value over its output space.",
    "parameters": [
      "s"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function string_to_uniform_number",
    "component_id": "pr_agent.algo.utils.string_to_uniform_number"
  },
  "pr_agent.algo.utils.process_description": {
    "id": "pr_agent.algo.utils.process_description",
    "name": "process_description",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def process_description(description_full: str) -> Tuple[str, List]:\n    if not description_full:\n        return \"\", []\n\n    description_split = description_full.split(PRDescriptionHeader.CHANGES_WALKTHROUGH.value)\n    base_description_str = description_split[0]\n    changes_walkthrough_str = \"\"\n    files = []\n    if len(description_split) > 1:\n        changes_walkthrough_str = description_split[1]\n    else:\n        get_logger().debug(\"No changes walkthrough found\")\n\n    try:\n        if changes_walkthrough_str:\n            # get the end of the table\n            if '</table>\\n\\n___' in changes_walkthrough_str:\n                end = changes_walkthrough_str.index(\"</table>\\n\\n___\")\n            elif '\\n___' in changes_walkthrough_str:\n                end = changes_walkthrough_str.index(\"\\n___\")\n            else:\n                end = len(changes_walkthrough_str)\n            changes_walkthrough_str = changes_walkthrough_str[:end]\n\n            h = html2text.HTML2Text()\n            h.body_width = 0  # Disable line wrapping\n\n            # find all the files\n            pattern = r'<tr>\\s*<td>\\s*(<details>\\s*<summary>(.*?)</summary>(.*?)</details>)\\s*</td>'\n            files_found = re.findall(pattern, changes_walkthrough_str, re.DOTALL)\n            for file_data in files_found:\n                try:\n                    if isinstance(file_data, tuple):\n                        file_data = file_data[0]\n                    pattern = r'<details>\\s*<summary><strong>(.*?)</strong>\\s*<dd><code>(.*?)</code>.*?</summary>\\s*<hr>\\s*(.*?)\\s*<li>(.*?)</details>'\n                    res = re.search(pattern, file_data, re.DOTALL)\n                    if not res or res.lastindex != 4:\n                        pattern_back = r'<details>\\s*<summary><strong>(.*?)</strong><dd><code>(.*?)</code>.*?</summary>\\s*<hr>\\s*(.*?)\\n\\n\\s*(.*?)</details>'\n                        res = re.search(pattern_back, file_data, re.DOTALL)\n                    if not res or res.lastindex != 4:\n                        pattern_back = r'<details>\\s*<summary><strong>(.*?)</strong>\\s*<dd><code>(.*?)</code>.*?</summary>\\s*<hr>\\s*(.*?)\\s*-\\s*(.*?)\\s*</details>' # looking for hypen ('- ')\n                        res = re.search(pattern_back, file_data, re.DOTALL)\n                    if res and res.lastindex == 4:\n                        short_filename = res.group(1).strip()\n                        short_summary = res.group(2).strip()\n                        long_filename = res.group(3).strip()\n                        long_summary =  res.group(4).strip()\n                        long_summary = long_summary.replace('<br> *', '\\n*').replace('<br>','').replace('\\n','<br>')\n                        long_summary = h.handle(long_summary).strip()\n                        if long_summary.startswith('\\\\-'):\n                            long_summary = \"* \" + long_summary[2:]\n                        elif not long_summary.startswith('*'):\n                            long_summary = f\"* {long_summary}\"\n\n                        files.append({\n                            'short_file_name': short_filename,\n                            'full_file_name': long_filename,\n                            'short_summary': short_summary,\n                            'long_summary': long_summary\n                        })\n                    else:\n                        if '<code>...</code>' in file_data:\n                            pass # PR with many files. some did not get analyzed\n                        else:\n                            get_logger().error(f\"Failed to parse description\", artifact={'description': file_data})\n                except Exception as e:\n                    get_logger().exception(f\"Failed to process description: {e}\", artifact={'description': file_data})\n\n\n    except Exception as e:\n        get_logger().exception(f\"Failed to process description: {e}\")\n\n    return base_description_str, files",
    "start_line": 1142,
    "end_line": 1214,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "description_full"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_description",
    "component_id": "pr_agent.algo.utils.process_description"
  },
  "pr_agent.algo.utils.get_version": {
    "id": "pr_agent.algo.utils.get_version",
    "name": "get_version",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def get_version() -> str:\n    # First check pyproject.toml if running directly out of repository\n    if os.path.exists(\"pyproject.toml\"):\n        if sys.version_info >= (3, 11):\n            import tomllib\n            with open(\"pyproject.toml\", \"rb\") as f:\n                data = tomllib.load(f)\n                if \"project\" in data and \"version\" in data[\"project\"]:\n                    return data[\"project\"][\"version\"]\n                else:\n                    get_logger().warning(\"Version not found in pyproject.toml\")\n        else:\n            get_logger().warning(\"Unable to determine local version from pyproject.toml\")\n\n    # Otherwise get the installed pip package version\n    try:\n        return version('pr-agent')\n    except PackageNotFoundError:\n        get_logger().warning(\"Unable to find package named 'pr-agent'\")\n        return \"unknown\"",
    "start_line": 1216,
    "end_line": 1235,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_version",
    "component_id": "pr_agent.algo.utils.get_version"
  },
  "pr_agent.algo.utils.set_file_languages": {
    "id": "pr_agent.algo.utils.set_file_languages",
    "name": "set_file_languages",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/algo/utils.py",
    "relative_path": "pr_agent/algo/utils.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def set_file_languages(diff_files) -> List[FilePatchInfo]:\n    try:\n        # if the language is already set, do not change it\n        if hasattr(diff_files[0], 'language') and diff_files[0].language:\n            return diff_files\n\n        # map file extensions to programming languages\n        language_extension_map_org = get_settings().language_extension_map_org\n        extension_to_language = {}\n        for language, extensions in language_extension_map_org.items():\n            for ext in extensions:\n                extension_to_language[ext] = language\n        for file in diff_files:\n            extension_s = '.' + file.filename.rsplit('.')[-1]\n            language_name = \"txt\"\n            if extension_s and (extension_s in extension_to_language):\n                language_name = extension_to_language[extension_s]\n            file.language = language_name.lower()\n    except Exception as e:\n        get_logger().exception(f\"Failed to set file languages: {e}\")\n\n    return diff_files",
    "start_line": 1238,
    "end_line": 1259,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "diff_files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function set_file_languages",
    "component_id": "pr_agent.algo.utils.set_file_languages"
  },
  "pr_agent.cli.set_parser": {
    "id": "pr_agent.cli.set_parser",
    "name": "set_parser",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/cli.py",
    "relative_path": "pr_agent/cli.py",
    "depends_on": [
      "pr_agent.algo.utils.get_version"
    ],
    "source_code": "def set_parser():\n    parser = argparse.ArgumentParser(description='AI based pull request analyzer', usage=\n    \"\"\"\\\n    Usage: cli.py --pr-url=<URL on supported git hosting service> <command> [<args>].\n    For example:\n    - cli.py --pr_url=... review\n    - cli.py --pr_url=... describe\n    - cli.py --pr_url=... improve\n    - cli.py --pr_url=... ask \"write me a poem about this PR\"\n    - cli.py --pr_url=... reflect\n    - cli.py --issue_url=... similar_issue\n    - cli.py --pr_url/--issue_url= help_docs [<asked question>]\n\n    Supported commands:\n    - review / review_pr - Add a review that includes a summary of the PR and specific suggestions for improvement.\n\n    - ask / ask_question [question] - Ask a question about the PR.\n\n    - describe / describe_pr - Modify the PR title and description based on the PR's contents.\n\n    - improve / improve_code - Suggest improvements to the code in the PR as pull request comments ready to commit.\n    Extended mode ('improve --extended') employs several calls, and provides a more thorough feedback\n\n    - reflect - Ask the PR author questions about the PR.\n\n    - update_changelog - Update the changelog based on the PR's contents.\n\n    - add_docs\n\n    - generate_labels\n    \n    - help_docs - Ask a question, from either an issue or PR context, on a given repo (current context or a different one)\n\n\n    Configuration:\n    To edit any configuration parameter from 'configuration.toml', just add -config_path=<value>.\n    For example: 'python cli.py --pr_url=... review --pr_reviewer.extra_instructions=\"focus on the file: ...\"'\n    \"\"\")\n    parser.add_argument('--version', action='version', version=f'pr-agent {get_version()}')\n    parser.add_argument('--pr_url', type=str, help='The URL of the PR to review', default=None)\n    parser.add_argument('--issue_url', type=str, help='The URL of the Issue to review', default=None)\n    parser.add_argument('command', type=str, help='The', choices=commands, default='review')\n    parser.add_argument('rest', nargs=argparse.REMAINDER, default=[])\n    return parser",
    "start_line": 14,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function set_parser",
    "component_id": "pr_agent.cli.set_parser"
  },
  "pr_agent.cli.run_command": {
    "id": "pr_agent.cli.run_command",
    "name": "run_command",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/cli.py",
    "relative_path": "pr_agent/cli.py",
    "depends_on": [
      "pr_agent.cli.set_parser",
      "pr_agent.cli.run"
    ],
    "source_code": "def run_command(pr_url, command):\n    # Preparing the command\n    run_command_str = f\"--pr_url={pr_url} {command.lstrip('/')}\"\n    args = set_parser().parse_args(run_command_str.split())\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    run(args=args)",
    "start_line": 60,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_url",
      "command"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run_command",
    "component_id": "pr_agent.cli.run_command"
  },
  "pr_agent.cli.run": {
    "id": "pr_agent.cli.run",
    "name": "run",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/cli.py",
    "relative_path": "pr_agent/cli.py",
    "depends_on": [
      "pr_agent.cli.set_parser",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def run(inargs=None, args=None):\n    parser = set_parser()\n    if not args:\n        args = parser.parse_args(inargs)\n    if not args.pr_url and not args.issue_url:\n        parser.print_help()\n        return\n\n    command = args.command.lower()\n    get_settings().set(\"CONFIG.CLI_MODE\", True)\n\n    async def inner():\n        if args.issue_url:\n            result = await asyncio.create_task(PRAgent().handle_request(args.issue_url, [command] + args.rest))\n        else:\n            result = await asyncio.create_task(PRAgent().handle_request(args.pr_url, [command] + args.rest))\n\n        if get_settings().litellm.get(\"enable_callbacks\", False):\n            # There may be additional events on the event queue from the run above. If there are give them time to complete.\n            get_logger().debug(\"Waiting for event queue to complete\")\n            await asyncio.wait([task for task in asyncio.all_tasks() if task is not asyncio.current_task()])\n\n        return result\n\n    result = asyncio.run(inner())\n    if not result:\n        parser.print_help()",
    "start_line": 69,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "inargs",
      "args"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run",
    "component_id": "pr_agent.cli.run"
  },
  "pr_agent.cli.inner": {
    "id": "pr_agent.cli.inner",
    "name": "inner",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/cli.py",
    "relative_path": "pr_agent/cli.py",
    "depends_on": [
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "    async def inner():\n        if args.issue_url:\n            result = await asyncio.create_task(PRAgent().handle_request(args.issue_url, [command] + args.rest))\n        else:\n            result = await asyncio.create_task(PRAgent().handle_request(args.pr_url, [command] + args.rest))\n\n        if get_settings().litellm.get(\"enable_callbacks\", False):\n            # There may be additional events on the event queue from the run above. If there are give them time to complete.\n            get_logger().debug(\"Waiting for event queue to complete\")\n            await asyncio.wait([task for task in asyncio.all_tasks() if task is not asyncio.current_task()])\n\n        return result",
    "start_line": 80,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function inner",
    "component_id": "pr_agent.cli.inner"
  },
  "pr_agent.cli_pip.main": {
    "id": "pr_agent.cli_pip.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/cli_pip.py",
    "relative_path": "pr_agent/cli_pip.py",
    "depends_on": [
      "pr_agent.cli.run_command",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def main():\n    # Fill in the following values\n    provider = \"github\"  # GitHub provider\n    user_token = \"...\"  # GitHub user token\n    openai_key = \"...\"  # OpenAI key\n    pr_url = \"...\"  # PR URL, for example 'https://github.com/Codium-ai/pr-agent/pull/809'\n    command = \"/review\"  # Command to run (e.g. '/review', '/describe', '/ask=\"What is the purpose of this PR?\"')\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    cli.run_command(pr_url, command)",
    "start_line": 5,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "pr_agent.cli_pip.main"
  },
  "pr_agent.config_loader.get_settings": {
    "id": "pr_agent.config_loader.get_settings",
    "name": "get_settings",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/config_loader.py",
    "relative_path": "pr_agent/config_loader.py",
    "depends_on": [],
    "source_code": "def get_settings(use_context=False):\n    \"\"\"\n    Retrieves the current settings.\n\n    This function attempts to fetch the settings from the starlette_context's context object. If it fails,\n    it defaults to the global settings defined outside of this function.\n\n    Returns:\n        Dynaconf: The current settings object, either from the context or the global default.\n    \"\"\"\n    try:\n        return context[\"settings\"]\n    except Exception:\n        return global_settings",
    "start_line": 38,
    "end_line": 51,
    "has_docstring": true,
    "docstring": "Retrieves the current settings.\n\nThis function attempts to fetch the settings from the starlette_context's context object. If it fails,\nit defaults to the global settings defined outside of this function.\n\nReturns:\n    Dynaconf: The current settings object, either from the context or the global default.",
    "parameters": [
      "use_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_settings",
    "component_id": "pr_agent.config_loader.get_settings"
  },
  "pr_agent.config_loader._find_repository_root": {
    "id": "pr_agent.config_loader._find_repository_root",
    "name": "_find_repository_root",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/config_loader.py",
    "relative_path": "pr_agent/config_loader.py",
    "depends_on": [],
    "source_code": "def _find_repository_root() -> Optional[Path]:\n    \"\"\"\n    Identify project root directory by recursively searching for the .git directory in the parent directories.\n    \"\"\"\n    cwd = Path.cwd().resolve()\n    no_way_up = False\n    while not no_way_up:\n        no_way_up = cwd == cwd.parent\n        if (cwd / \".git\").is_dir():\n            return cwd\n        cwd = cwd.parent\n    return None",
    "start_line": 55,
    "end_line": 66,
    "has_docstring": true,
    "docstring": "Identify project root directory by recursively searching for the .git directory in the parent directories.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _find_repository_root",
    "component_id": "pr_agent.config_loader._find_repository_root"
  },
  "pr_agent.config_loader._find_pyproject": {
    "id": "pr_agent.config_loader._find_pyproject",
    "name": "_find_pyproject",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/config_loader.py",
    "relative_path": "pr_agent/config_loader.py",
    "depends_on": [
      "pr_agent.config_loader._find_repository_root"
    ],
    "source_code": "def _find_pyproject() -> Optional[Path]:\n    \"\"\"\n    Search for file pyproject.toml in the repository root.\n    \"\"\"\n    repo_root = _find_repository_root()\n    if repo_root:\n        pyproject = repo_root / \"pyproject.toml\"\n        return pyproject if pyproject.is_file() else None\n    return None",
    "start_line": 69,
    "end_line": 77,
    "has_docstring": true,
    "docstring": "Search for file pyproject.toml in the repository root.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _find_pyproject",
    "component_id": "pr_agent.config_loader._find_pyproject"
  },
  "pr_agent.git_providers.__init__.get_git_provider": {
    "id": "pr_agent.git_providers.__init__.get_git_provider",
    "name": "get_git_provider",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/__init__.py",
    "relative_path": "pr_agent/git_providers/__init__.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_git_provider():\n    try:\n        provider_id = get_settings().config.git_provider\n    except AttributeError as e:\n        raise ValueError(\"git_provider is a required attribute in the configuration file\") from e\n    if provider_id not in _GIT_PROVIDERS:\n        raise ValueError(f\"Unknown git provider: {provider_id}\")\n    return _GIT_PROVIDERS[provider_id]",
    "start_line": 29,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_git_provider",
    "component_id": "pr_agent.git_providers.__init__.get_git_provider"
  },
  "pr_agent.git_providers.__init__.get_git_provider_with_context": {
    "id": "pr_agent.git_providers.__init__.get_git_provider_with_context",
    "name": "get_git_provider_with_context",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/__init__.py",
    "relative_path": "pr_agent/git_providers/__init__.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_git_provider_with_context(pr_url) -> GitProvider:\n    \"\"\"\n    Get a GitProvider instance for the given PR URL. If the GitProvider instance is already in the context, return it.\n    \"\"\"\n\n    is_context_env = None\n    try:\n        is_context_env = context.get(\"settings\", None)\n    except Exception:\n        pass  # we are not in a context environment (CLI)\n\n    # check if context[\"git_provider\"][\"pr_url\"] exists\n    if is_context_env and context.get(\"git_provider\", {}).get(\"pr_url\", {}):\n        git_provider = context[\"git_provider\"][\"pr_url\"]\n        # possibly check if the git_provider is still valid, or if some reset is needed\n        # ...\n        return git_provider\n    else:\n        try:\n            provider_id = get_settings().config.git_provider\n            if provider_id not in _GIT_PROVIDERS:\n                raise ValueError(f\"Unknown git provider: {provider_id}\")\n            git_provider = _GIT_PROVIDERS[provider_id](pr_url)\n            if is_context_env:\n                context[\"git_provider\"] = {pr_url: git_provider}\n            return git_provider\n        except Exception as e:\n            raise ValueError(f\"Failed to get git provider for {pr_url}\") from e",
    "start_line": 39,
    "end_line": 66,
    "has_docstring": true,
    "docstring": "Get a GitProvider instance for the given PR URL. If the GitProvider instance is already in the context, return it.",
    "parameters": [
      "pr_url"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_git_provider_with_context",
    "component_id": "pr_agent.git_providers.__init__.get_git_provider_with_context"
  },
  "pr_agent.git_providers.azuredevops_provider.AzureDevopsProvider": {
    "id": "pr_agent.git_providers.azuredevops_provider.AzureDevopsProvider",
    "name": "AzureDevopsProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/azuredevops_provider.py",
    "relative_path": "pr_agent/git_providers/azuredevops_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.git_provider.create_inline_comment",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
      "pr_agent.git_providers.git_provider.publish_inline_comments",
      "pr_agent.algo.utils.load_large_diff",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.file_filter.filter_ignored",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class AzureDevopsProvider(GitProvider):\n\n    def __init__(\n            self, pr_url: Optional[str] = None, incremental: Optional[bool] = False\n    ):\n        if not AZURE_DEVOPS_AVAILABLE:\n            raise ImportError(\n                \"Azure DevOps provider is not available. Please install the required dependencies.\"\n            )\n\n        self.azure_devops_client = self._get_azure_devops_client()\n        self.diff_files = None\n        self.workspace_slug = None\n        self.repo_slug = None\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.temp_comments = []\n        self.incremental = incremental\n        if pr_url:\n            self.set_pr(pr_url)\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n        for suggestion in code_suggestions:\n            body = suggestion['body']\n            relevant_file = suggestion['relevant_file']\n            relevant_lines_start = suggestion['relevant_lines_start']\n            relevant_lines_end = suggestion['relevant_lines_end']\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().warning(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().warning(f\"Failed to publish code suggestion, \"\n                                       f\"relevant_lines_end is {relevant_lines_end} and \"\n                                       f\"relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n        if not post_parameters_list:\n            return False\n\n        for post_parameters in post_parameters_list:\n            try:\n                comment = Comment(content=post_parameters[\"body\"], comment_type=1)\n                thread = CommentThread(comments=[comment],\n                                       thread_context={\n                                           \"filePath\": post_parameters[\"path\"],\n                                           \"rightFileStart\": {\n                                               \"line\": post_parameters[\"start_line\"],\n                                               \"offset\": 1,\n                                           },\n                                           \"rightFileEnd\": {\n                                               \"line\": post_parameters[\"line\"],\n                                               \"offset\": 1,\n                                           },\n                                       })\n                self.azure_devops_client.create_thread(\n                    comment_thread=thread,\n                    project=self.workspace_slug,\n                    repository_id=self.repo_slug,\n                    pull_request_id=self.pr_num\n                )\n            except Exception as e:\n                get_logger().warning(f\"Azure failed to publish code suggestion, error: {e}\")\n        return True\n\n\n\n    def get_pr_description_full(self) -> str:\n        return self.pr.description\n\n    def edit_comment(self, comment, body: str):\n        try:\n            self.azure_devops_client.update_comment(\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                thread_id=comment[\"thread_id\"],\n                comment_id=comment[\"comment_id\"],\n                comment=Comment(content=body),\n                project=self.workspace_slug,\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to edit comment, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            self.azure_devops_client.delete_comment(\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                thread_id=comment[\"thread_id\"],\n                comment_id=comment[\"comment_id\"],\n                project=self.workspace_slug,\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def publish_labels(self, pr_types):\n        try:\n            for pr_type in pr_types:\n                self.azure_devops_client.create_pull_request_label(\n                    label={\"name\": pr_type},\n                    project=self.workspace_slug,\n                    repository_id=self.repo_slug,\n                    pull_request_id=self.pr_num,\n                )\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def get_pr_labels(self, update=False):\n        try:\n            labels = self.azure_devops_client.get_pull_request_labels(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n            )\n            return [label.name for label in labels]\n        except Exception as e:\n            get_logger().exception(f\"Failed to get labels, error: {e}\")\n            return []\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\n            \"get_issue_comments\",\n        ]:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.pr_url = pr_url\n        self.workspace_slug, self.repo_slug, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_repo_settings(self):\n        try:\n            contents = self.azure_devops_client.get_item_content(\n                repository_id=self.repo_slug,\n                project=self.workspace_slug,\n                download=False,\n                include_content_metadata=False,\n                include_content=True,\n                path=\".pr_agent.toml\",\n            )\n            return list(contents)[0]\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().error(f\"Failed to get repo settings, error: {e}\")\n            return \"\"\n\n    def get_files(self):\n        files = []\n        for i in self.azure_devops_client.get_pull_request_commits(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n        ):\n            changes_obj = self.azure_devops_client.get_changes(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                commit_id=i.commit_id,\n            )\n\n            for c in changes_obj.changes:\n                files.append(c[\"item\"][\"path\"])\n        return list(set(files))\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        try:\n\n            if self.diff_files:\n                return self.diff_files\n\n            base_sha = self.pr.last_merge_target_commit\n            head_sha = self.pr.last_merge_source_commit\n\n            # Get PR iterations\n            iterations = self.azure_devops_client.get_pull_request_iterations(\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                project=self.workspace_slug\n            )\n            changes = None\n            if iterations:\n                iteration_id = iterations[-1].id  # Get the last iteration (most recent changes)\n\n                # Get changes for the iteration\n                changes = self.azure_devops_client.get_pull_request_iteration_changes(\n                    repository_id=self.repo_slug,\n                    pull_request_id=self.pr_num,\n                    iteration_id=iteration_id,\n                    project=self.workspace_slug\n                )\n            diff_files = []\n            diffs = []\n            diff_types = {}\n            if changes:\n                for change in changes.change_entries:\n                    item = change.additional_properties.get('item', {})\n                    path = item.get('path', None)\n                    if path:\n                        diffs.append(path)\n                        diff_types[path] = change.additional_properties.get('changeType', 'Unknown')\n\n            # wrong implementation - gets all the files that were changed in any commit in the PR\n            # commits = self.azure_devops_client.get_pull_request_commits(\n            #     project=self.workspace_slug,\n            #     repository_id=self.repo_slug,\n            #     pull_request_id=self.pr_num,\n            # )\n            #\n            # diff_files = []\n            # diffs = []\n            # diff_types = {}\n\n            # for c in commits:\n            #     changes_obj = self.azure_devops_client.get_changes(\n            #         project=self.workspace_slug,\n            #         repository_id=self.repo_slug,\n            #         commit_id=c.commit_id,\n            #     )\n            #     for i in changes_obj.changes:\n            #         if i[\"item\"][\"gitObjectType\"] == \"tree\":\n            #             continue\n            #         diffs.append(i[\"item\"][\"path\"])\n            #         diff_types[i[\"item\"][\"path\"]] = i[\"changeType\"]\n            #\n            # diffs = list(set(diffs))\n\n            diffs_original = diffs\n            diffs = filter_ignored(diffs_original, 'azure')\n            if diffs_original != diffs:\n                try:\n                    get_logger().info(f\"Filtered out [ignore] files for pull request:\", extra=\n                    {\"files\": diffs_original,  # diffs is just a list of names\n                     \"filtered_files\": diffs})\n                except Exception:\n                    pass\n\n            invalid_files_names = []\n            for file in diffs:\n                if not is_valid_file(file):\n                    invalid_files_names.append(file)\n                    continue\n\n                version = GitVersionDescriptor(\n                    version=head_sha.commit_id, version_type=\"commit\"\n                )\n                try:\n                    new_file_content_str = self.azure_devops_client.get_item(\n                        repository_id=self.repo_slug,\n                        path=file,\n                        project=self.workspace_slug,\n                        version_descriptor=version,\n                        download=False,\n                        include_content=True,\n                    )\n\n                    new_file_content_str = new_file_content_str.content\n                except Exception as error:\n                    get_logger().error(f\"Failed to retrieve new file content of {file} at version {version}\", error=error)\n                    # get_logger().error(\n                    #     \"Failed to retrieve new file content of %s at version %s. Error: %s\",\n                    #     file,\n                    #     version,\n                    #     str(error),\n                    # )\n                    new_file_content_str = \"\"\n\n                edit_type = EDIT_TYPE.MODIFIED\n                if diff_types[file] == \"add\":\n                    edit_type = EDIT_TYPE.ADDED\n                elif diff_types[file] == \"delete\":\n                    edit_type = EDIT_TYPE.DELETED\n                elif \"rename\" in diff_types[file]: # diff_type can be `rename` | `edit, rename`\n                    edit_type = EDIT_TYPE.RENAMED\n\n                version = GitVersionDescriptor(\n                    version=base_sha.commit_id, version_type=\"commit\"\n                )\n                if edit_type == EDIT_TYPE.ADDED or edit_type == EDIT_TYPE.RENAMED:\n                    original_file_content_str = \"\"\n                else:\n                    try:\n                        original_file_content_str = self.azure_devops_client.get_item(\n                            repository_id=self.repo_slug,\n                            path=file,\n                            project=self.workspace_slug,\n                            version_descriptor=version,\n                            download=False,\n                            include_content=True,\n                        )\n                        original_file_content_str = original_file_content_str.content\n                    except Exception as error:\n                        get_logger().error(f\"Failed to retrieve original file content of {file} at version {version}\", error=error)\n                        original_file_content_str = \"\"\n\n                patch = load_large_diff(\n                    file, new_file_content_str, original_file_content_str, show_warning=False\n                ).rstrip()\n\n                # count number of lines added and removed\n                patch_lines = patch.splitlines(keepends=True)\n                num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n                num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n\n                diff_files.append(\n                    FilePatchInfo(\n                        original_file_content_str,\n                        new_file_content_str,\n                        patch=patch,\n                        filename=file,\n                        edit_type=edit_type,\n                        num_plus_lines=num_plus_lines,\n                        num_minus_lines=num_minus_lines,\n                    )\n                )\n            get_logger().info(f\"Invalid files: {invalid_files_names}\")\n\n            self.diff_files = diff_files\n            return diff_files\n        except Exception as e:\n            get_logger().exception(f\"Failed to get diff files, error: {e}\")\n            return []\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False, thread_context=None):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {pr_comment}\")\n            return None\n        comment = Comment(content=pr_comment)\n        thread = CommentThread(comments=[comment], thread_context=thread_context, status=1)\n        thread_response = self.azure_devops_client.create_thread(\n            comment_thread=thread,\n            project=self.workspace_slug,\n            repository_id=self.repo_slug,\n            pull_request_id=self.pr_num,\n        )\n        response = {\"thread_id\": thread_response.id, \"comment_id\": thread_response.comments[0].id}\n        if is_temporary:\n            self.temp_comments.append(response)\n        return response\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        if len(pr_body) > MAX_PR_DESCRIPTION_AZURE_LENGTH:\n\n            usage_guide_text='<details> <summary><strong> Describe tool usage guide:</strong></summary><hr>'\n            ind = pr_body.find(usage_guide_text)\n            if ind != -1:\n                pr_body = pr_body[:ind]\n\n            if len(pr_body) > MAX_PR_DESCRIPTION_AZURE_LENGTH:\n                changes_walkthrough_text = PRDescriptionHeader.CHANGES_WALKTHROUGH.value\n                ind = pr_body.find(changes_walkthrough_text)\n                if ind != -1:\n                    pr_body = pr_body[:ind]\n\n            if len(pr_body) > MAX_PR_DESCRIPTION_AZURE_LENGTH:\n                trunction_message = \" ... (description truncated due to length limit)\"\n                pr_body = pr_body[:MAX_PR_DESCRIPTION_AZURE_LENGTH - len(trunction_message)] + trunction_message\n                get_logger().warning(\"PR description was truncated due to length limit\")\n        try:\n            updated_pr = GitPullRequest()\n            updated_pr.title = pr_title\n            updated_pr.description = pr_body\n            self.azure_devops_client.update_pull_request(\n                project=self.workspace_slug,\n                repository_id=self.repo_slug,\n                pull_request_id=self.pr_num,\n                git_pull_request_to_update=updated_pr,\n            )\n        except Exception as e:\n            get_logger().exception(\n                f\"Could not update pull request {self.pr_num} description: {e}\"\n            )\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        self.publish_inline_comments([self.create_inline_comment(body, relevant_file, relevant_line_in_file)])\n\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        position, absolute_position = find_line_number_of_relevant_line_in_file(self.get_diff_files(),\n                                                                                relevant_file.strip('`'),\n                                                                                relevant_line_in_file,\n                                                                                absolute_position)\n        if position == -1:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=position, absolute_position=absolute_position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comments(self, comments: list[dict], disable_fallback: bool = False):\n            overall_success = True\n            for comment in comments:\n                try:\n                    self.publish_comment(comment[\"body\"],\n                                        thread_context={\n                                            \"filePath\": comment[\"path\"],\n                                            \"rightFileStart\": {\n                                                \"line\": comment[\"absolute_position\"],\n                                                \"offset\": comment[\"position\"],\n                                            },\n                                            \"rightFileEnd\": {\n                                                \"line\": comment[\"absolute_position\"],\n                                                \"offset\": comment[\"position\"],\n                                            },\n                                        })\n                    if get_settings().config.verbosity_level >= 2:\n                        get_logger().info(\n                            f\"Published code suggestion on {self.pr_num} at {comment['path']}\"\n                        )\n                except Exception as e:\n                    if get_settings().config.verbosity_level >= 2:\n                        get_logger().error(f\"Failed to publish code suggestion, error: {e}\")\n                    overall_success = False\n            return overall_success\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        languages = []\n        files = self.azure_devops_client.get_items(\n            project=self.workspace_slug,\n            repository_id=self.repo_slug,\n            recursion_level=\"Full\",\n            include_content_metadata=True,\n            include_links=False,\n            download=False,\n        )\n        for f in files:\n            if f.git_object_type == \"blob\":\n                file_name, file_extension = os.path.splitext(f.path)\n                languages.append(file_extension[1:])\n\n        extension_counts = {}\n        for ext in languages:\n            if ext != \"\":\n                extension_counts[ext] = extension_counts.get(ext, 0) + 1\n\n        total_extensions = sum(extension_counts.values())\n\n        extension_percentages = {\n            ext: (count / total_extensions) * 100\n            for ext, count in extension_counts.items()\n        }\n\n        return extension_percentages\n\n    def get_pr_branch(self):\n        pr_info = self.azure_devops_client.get_pull_request_by_id(\n            project=self.workspace_slug, pull_request_id=self.pr_num\n        )\n        source_branch = pr_info.source_ref_name.split(\"/\")[-1]\n        return source_branch\n\n    def get_user_id(self):\n        return 0\n\n    def get_issue_comments(self):\n        threads = self.azure_devops_client.get_threads(repository_id=self.repo_slug, pull_request_id=self.pr_num, project=self.workspace_slug)\n        threads.reverse()\n        comment_list = []\n        for thread in threads:\n            for comment in thread.comments:\n                if comment.content and comment not in comment_list:\n                    comment.body = comment.content\n                    comment.thread_id = thread.id\n                    comment_list.append(comment)\n        return comment_list\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, str, int]:\n        parsed_url = urlparse(pr_url)\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n        if \"pullrequest\" not in path_parts:\n            raise ValueError(\n                \"The provided URL does not appear to be a Azure DevOps PR URL\"\n            )\n        if len(path_parts) == 6:  # \"https://dev.azure.com/organization/project/_git/repo/pullrequest/1\"\n            workspace_slug = path_parts[1]\n            repo_slug = path_parts[3]\n            pr_number = int(path_parts[5])\n        elif len(path_parts) == 5:  # 'https://organization.visualstudio.com/project/_git/repo/pullrequest/1'\n            workspace_slug = path_parts[0]\n            repo_slug = path_parts[2]\n            pr_number = int(path_parts[4])\n        else:\n            raise ValueError(\"The provided URL does not appear to be a Azure DevOps PR URL\")\n\n        return workspace_slug, repo_slug, pr_number\n\n    @staticmethod\n    def _get_azure_devops_client():\n        org = get_settings().azure_devops.get(\"org\", None)\n        pat = get_settings().azure_devops.get(\"pat\", None)\n\n        if not org:\n            raise ValueError(\"Azure DevOps organization is required\")\n\n        if pat:\n            auth_token = pat\n        else:\n            try:\n                # try to use azure default credentials\n                # see https://learn.microsoft.com/en-us/python/api/overview/azure/identity-readme?view=azure-python\n                # for usage and env var configuration of user-assigned managed identity, local machine auth etc.\n                get_logger().info(\"No PAT found in settings, trying to use Azure Default Credentials.\")\n                credentials = DefaultAzureCredential()\n                accessToken = credentials.get_token(ADO_APP_CLIENT_DEFAULT_ID)\n                auth_token = accessToken.token\n            except Exception as e:\n                get_logger().error(f\"No PAT found in settings, and Azure Default Authentication failed, error: {e}\")\n                raise\n\n        credentials = BasicAuthentication(\"\", auth_token)\n\n        credentials = BasicAuthentication(\"\", auth_token)\n        azure_devops_connection = Connection(base_url=org, creds=credentials)\n        azure_devops_client = azure_devops_connection.clients.get_git_client()\n\n        return azure_devops_client\n\n    def _get_repo(self):\n        if self.repo is None:\n            self.repo = self.azure_devops_client.get_repository(\n                project=self.workspace_slug, repository_id=self.repo_slug\n            )\n        return self.repo\n\n    def _get_pr(self):\n        self.pr = self.azure_devops_client.get_pull_request_by_id(\n            pull_request_id=self.pr_num, project=self.workspace_slug\n        )\n        return self.pr\n\n    def get_commit_messages(self):\n        return \"\"  # not implemented yet\n\n    def get_pr_id(self):\n        try:\n            pr_id = f\"{self.workspace_slug}/{self.repo_slug}/{self.pr_num}\"\n            return pr_id\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed to get pr id, error: {e}\")\n            return \"\"\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        return self.pr_url+f\"?_a=files&path={relevant_file}\"",
    "start_line": 36,
    "end_line": 625,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class AzureDevopsProvider",
    "component_id": "pr_agent.git_providers.azuredevops_provider.AzureDevopsProvider"
  },
  "pr_agent.git_providers.bitbucket_provider._gef_filename": {
    "id": "pr_agent.git_providers.bitbucket_provider._gef_filename",
    "name": "_gef_filename",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/bitbucket_provider.py",
    "relative_path": "pr_agent/git_providers/bitbucket_provider.py",
    "depends_on": [],
    "source_code": "def _gef_filename(diff):\n    if diff.new.path:\n        return diff.new.path\n    return diff.old.path",
    "start_line": 21,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "diff"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _gef_filename",
    "component_id": "pr_agent.git_providers.bitbucket_provider._gef_filename"
  },
  "pr_agent.git_providers.bitbucket_provider.BitbucketProvider": {
    "id": "pr_agent.git_providers.bitbucket_provider.BitbucketProvider",
    "name": "BitbucketProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/bitbucket_provider.py",
    "relative_path": "pr_agent/git_providers/bitbucket_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_latest_commit_url",
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.limit_output_characters",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.git_provider.get_comment_url",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
      "pr_agent.git_providers.git_provider.publish_inline_comments",
      "pr_agent.git_providers.bitbucket_provider._gef_filename",
      "pr_agent.git_providers.git_provider.publish_inline_comment",
      "pr_agent.git_providers.gerrit_provider.diff",
      "pr_agent.algo.file_filter.filter_ignored",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class BitbucketProvider(GitProvider):\n    def __init__(\n        self, pr_url: Optional[str] = None, incremental: Optional[bool] = False\n    ):\n        s = requests.Session()\n        try:\n            self.bearer_token = bearer = context.get(\"bitbucket_bearer_token\", None)\n            if not bearer and get_settings().get(\"BITBUCKET.BEARER_TOKEN\", None):\n                self.bearer_token = bearer = get_settings().get(\"BITBUCKET.BEARER_TOKEN\", None)\n            s.headers[\"Authorization\"] = f\"Bearer {bearer}\"\n        except Exception:\n            self.bearer_token = get_settings().get(\"BITBUCKET.BEARER_TOKEN\", None)\n            s.headers[\n                \"Authorization\"\n            ] = f'Bearer {self.bearer_token}'\n        s.headers[\"Content-Type\"] = \"application/json\"\n        self.headers = s.headers\n        self.bitbucket_client = Cloud(session=s)\n        self.max_comment_length = 31000\n        self.workspace_slug = None\n        self.repo_slug = None\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.pr_url = pr_url\n        self.temp_comments = []\n        self.incremental = incremental\n        self.diff_files = None\n        self.git_files = None\n        if pr_url:\n            self.set_pr(pr_url)\n        self.bitbucket_comment_api_url = self.pr._BitbucketBase__data[\"links\"][\"comments\"][\"href\"]\n        self.bitbucket_pull_request_api_url = self.pr._BitbucketBase__data[\"links\"]['self']['href']\n\n    def get_repo_settings(self):\n        try:\n            url = (f\"https://api.bitbucket.org/2.0/repositories/{self.workspace_slug}/{self.repo_slug}/src/\"\n                   f\"{self.pr.destination_branch}/.pr_agent.toml\")\n            response = requests.request(\"GET\", url, headers=self.headers)\n            if response.status_code == 404:  # not found\n                return \"\"\n            contents = response.text.encode('utf-8')\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_git_repo_url(self, pr_url: str=None) -> str: #bitbucket does not support issue url, so ignore param\n        try:\n            parsed_url = urlparse(self.pr_url)\n            return f\"{parsed_url.scheme}://{parsed_url.netloc}/{self.workspace_slug}/{self.repo_slug}.git\"\n        except Exception as e:\n            get_logger().exception(f\"url is not a valid merge requests url: {self.pr_url}\")\n            return \"\"\n\n    # Given a git repo url, return prefix and suffix of the provider in order to view a given file belonging to that repo.\n    # Example: git clone git clone https://bitbucket.org/codiumai/pr-agent.git and branch: main -> prefix: \"https://bitbucket.org/codiumai/pr-agent/src/main\", suffix: \"\"\n    # In case git url is not provided, provider will use PR context (which includes branch) to determine the prefix and suffix.\n    def get_canonical_url_parts(self, repo_git_url:str=None, desired_branch:str=None) -> Tuple[str, str]:\n        scheme_and_netloc = None\n        if repo_git_url:\n            parsed_git_url = urlparse(repo_git_url)\n            scheme_and_netloc = parsed_git_url.scheme + \"://\" + parsed_git_url.netloc\n            repo_path = parsed_git_url.path.split('.git')[0][1:] #/<workspace>/<repo>.git -> <workspace>/<repo>\n            if repo_path.count('/') != 1:\n                get_logger().error(f\"repo_git_url is not a valid git repo url: {repo_git_url}\")\n                return (\"\", \"\")\n            workspace_name, project_name = repo_path.split('/')\n        else:\n            desired_branch = self.get_pr_branch()\n            parsed_pr_url = urlparse(self.pr_url)\n            scheme_and_netloc = parsed_pr_url.scheme + \"://\" + parsed_pr_url.netloc\n            workspace_name, project_name = (self.workspace_slug, self.repo_slug)\n        prefix = f\"{scheme_and_netloc}/{workspace_name}/{project_name}/src/{desired_branch}\"\n        suffix = \"\" #None\n        return (prefix, suffix)\n\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n        for suggestion in code_suggestions:\n            body = suggestion[\"body\"]\n            original_suggestion = suggestion.get('original_suggestion', None)  # needed for diff code\n            if original_suggestion:\n                try:\n                    existing_code = original_suggestion['existing_code'].rstrip() + \"\\n\"\n                    improved_code = original_suggestion['improved_code'].rstrip() + \"\\n\"\n                    diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                improved_code.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    # replace ```suggestion ... ``` with diff_code, using regex:\n                    body = re.sub(r'```suggestion.*?```', diff_code, body, flags=re.DOTALL)\n                except Exception as e:\n                    get_logger().exception(f\"Bitbucket failed to get diff code for publishing, error: {e}\")\n                    continue\n\n            relevant_file = suggestion[\"relevant_file\"]\n            relevant_lines_start = suggestion[\"relevant_lines_start\"]\n            relevant_lines_end = suggestion[\"relevant_lines_end\"]\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().exception(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().exception(\n                    f\"Failed to publish code suggestion, \"\n                    f\"relevant_lines_end is {relevant_lines_end} and \"\n                    f\"relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n\n        try:\n            self.publish_inline_comments(post_parameters_list)\n            return True\n        except Exception as e:\n            get_logger().error(f\"Bitbucket failed to publish code suggestion, error: {e}\")\n            return False\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'publish_inline_comments', 'get_labels', 'gfm_markdown',\n                            'publish_file_comments']:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.workspace_slug, self.repo_slug, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_files(self):\n        try:\n            git_files = context.get(\"git_files\", None)\n            if git_files:\n                return git_files\n            self.git_files = [_gef_filename(diff) for diff in self.pr.diffstat()]\n            context[\"git_files\"] = self.git_files\n            return self.git_files\n        except Exception:\n            if not self.git_files:\n                self.git_files = [_gef_filename(diff) for diff in self.pr.diffstat()]\n            return self.git_files\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        if self.diff_files:\n            return self.diff_files\n\n        diffs_original = list(self.pr.diffstat())\n        diffs = filter_ignored(diffs_original, 'bitbucket')\n        if diffs != diffs_original:\n            try:\n                names_original = [d.new.path for d in diffs_original]\n                names_kept = [d.new.path for d in diffs]\n                names_filtered = list(set(names_original) - set(names_kept))\n                get_logger().info(f\"Filtered out [ignore] files for PR\", extra={\n                    'original_files': names_original,\n                    'names_kept': names_kept,\n                    'names_filtered': names_filtered\n\n                })\n            except Exception as e:\n                pass\n\n        # get the pr patches\n        try:\n            pr_patches = self.pr.diff()\n        except Exception as e:\n            # Try different encodings if UTF-8 fails\n            get_logger().warning(f\"Failed to decode PR patch with utf-8, error: {e}\")\n            encodings_to_try = ['iso-8859-1', 'latin-1', 'ascii', 'utf-16']\n            pr_patches = None\n            for encoding in encodings_to_try:\n                try:\n                    pr_patches = self.pr.diff(encoding=encoding)\n                    get_logger().info(f\"Successfully decoded PR patch with encoding {encoding}\")\n                    break\n                except UnicodeDecodeError:\n                    continue\n\n            if pr_patches is None:\n                raise ValueError(f\"Failed to decode PR patch with encodings {encodings_to_try}\")\n\n        diff_split = [\"diff --git\" + x for x in pr_patches.split(\"diff --git\") if x.strip()]\n        # filter all elements of 'diff_split' that are of indices in 'diffs_original' that are not in 'diffs'\n        if len(diff_split) > len(diffs) and len(diffs_original) == len(diff_split):\n            diff_split = [diff_split[i] for i in range(len(diff_split)) if diffs_original[i] in diffs]\n        if len(diff_split) != len(diffs):\n            get_logger().error(f\"Error - failed to split the diff into {len(diffs)} parts\")\n            return []\n        # bitbucket diff has a header for each file, we need to remove it:\n        # \"diff --git filename\n        # new file mode 100644 (optional)\n        #  index caa56f0..61528d7 100644\n        #   --- a/pr_agent/cli_pip.py\n        #  +++ b/pr_agent/cli_pip.py\n        #   @@ -... @@\"\n        for i, _ in enumerate(diff_split):\n            diff_split_lines = diff_split[i].splitlines()\n            if (len(diff_split_lines) >= 6) and \\\n                    ((diff_split_lines[2].startswith(\"---\") and\n                      diff_split_lines[3].startswith(\"+++\") and\n                      diff_split_lines[4].startswith(\"@@\")) or\n                     (diff_split_lines[3].startswith(\"---\") and  # new or deleted file\n                      diff_split_lines[4].startswith(\"+++\") and\n                      diff_split_lines[5].startswith(\"@@\"))):\n                diff_split[i] = \"\\n\".join(diff_split_lines[4:])\n            else:\n                if diffs[i].data.get('lines_added', 0) == 0 and diffs[i].data.get('lines_removed', 0) == 0:\n                    diff_split[i] = \"\"\n                elif len(diff_split_lines) <= 3:\n                    diff_split[i] = \"\"\n                    get_logger().info(f\"Disregarding empty diff for file {_gef_filename(diffs[i])}\")\n                else:\n                    get_logger().warning(f\"Bitbucket failed to get diff for file {_gef_filename(diffs[i])}\")\n                    diff_split[i] = \"\"\n\n        invalid_files_names = []\n        diff_files = []\n        counter_valid = 0\n        # get full files\n        for index, diff in enumerate(diffs):\n            file_path = _gef_filename(diff)\n            if not is_valid_file(file_path):\n                invalid_files_names.append(file_path)\n                continue\n\n            try:\n                counter_valid += 1\n                if get_settings().get(\"bitbucket_app.avoid_full_files\", False):\n                    original_file_content_str = \"\"\n                    new_file_content_str = \"\"\n                elif counter_valid < MAX_FILES_ALLOWED_FULL // 2:  # factor 2 because bitbucket has limited API calls\n                    if diff.old.get_data(\"links\"):\n                        original_file_content_str = self._get_pr_file_content(\n                            diff.old.get_data(\"links\")['self']['href'])\n                    else:\n                        original_file_content_str = \"\"\n                    if diff.new.get_data(\"links\"):\n                        new_file_content_str = self._get_pr_file_content(diff.new.get_data(\"links\")['self']['href'])\n                    else:\n                        new_file_content_str = \"\"\n                else:\n                    if counter_valid == MAX_FILES_ALLOWED_FULL // 2:\n                        get_logger().info(\n                            f\"Bitbucket too many files in PR, will avoid loading full content for rest of files\")\n                    original_file_content_str = \"\"\n                    new_file_content_str = \"\"\n            except Exception as e:\n                get_logger().exception(f\"Error - bitbucket failed to get file content, error: {e}\")\n                original_file_content_str = \"\"\n                new_file_content_str = \"\"\n\n            file_patch_canonic_structure = FilePatchInfo(\n                original_file_content_str,\n                new_file_content_str,\n                diff_split[index],\n                file_path,\n            )\n\n            if diff.data['status'] == 'added':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.ADDED\n            elif diff.data['status'] == 'removed':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.DELETED\n            elif diff.data['status'] == 'modified':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.MODIFIED\n            elif diff.data['status'] == 'renamed':\n                file_patch_canonic_structure.edit_type = EDIT_TYPE.RENAMED\n            diff_files.append(file_patch_canonic_structure)\n\n        if invalid_files_names:\n            get_logger().info(f\"Disregarding files with invalid extensions:\\n{invalid_files_names}\")\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_latest_commit_url(self):\n        return self.pr.data['source']['commit']['links']['html']['href']\n\n    def get_comment_url(self, comment):\n        return comment.data['links']['html']['href']\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        try:\n            for comment in self.pr.comments():\n                body = comment.raw\n                if initial_header in body:\n                    latest_commit_url = self.get_latest_commit_url()\n                    comment_url = self.get_comment_url(comment)\n                    if update_header:\n                        updated_header = f\"{initial_header}\\n\\n#### ({name.capitalize()} updated until commit {latest_commit_url})\\n\"\n                        pr_comment_updated = pr_comment.replace(initial_header, updated_header)\n                    else:\n                        pr_comment_updated = pr_comment\n                    get_logger().info(f\"Persistent mode - updating comment {comment_url} to latest {name} message\")\n                    d = {\"content\": {\"raw\": pr_comment_updated}}\n                    response = comment._update_data(comment.put(None, data=d))\n                    if final_update_message:\n                        self.publish_comment(\n                            f\"**[Persistent {name}]({comment_url})** updated to latest commit {latest_commit_url}\")\n                    return\n        except Exception as e:\n            get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n            pass\n        self.publish_comment(pr_comment)\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {pr_comment}\")\n            return None\n        pr_comment = self.limit_output_characters(pr_comment, self.max_comment_length)\n        comment = self.pr.comment(pr_comment)\n        if is_temporary:\n            self.temp_comments.append(comment[\"id\"])\n        return comment\n\n    def edit_comment(self, comment, body: str):\n        try:\n            body = self.limit_output_characters(body, self.max_comment_length)\n            comment.update(body)\n        except Exception as e:\n            get_logger().exception(f\"Failed to update comment, error: {e}\")\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            self.pr.delete(f\"comments/{comment}\")\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    # function to create_inline_comment\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        body = self.limit_output_characters(body, self.max_comment_length)\n        position, absolute_position = find_line_number_of_relevant_line_in_file(self.get_diff_files(),\n                                                                                relevant_file.strip('`'),\n                                                                                relevant_line_in_file,\n                                                                                absolute_position)\n        if position == -1:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=absolute_position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comment(self, comment: str, from_line: int, file: str, original_suggestion=None):\n        comment = self.limit_output_characters(comment, self.max_comment_length)\n        payload = json.dumps({\n            \"content\": {\n                \"raw\": comment,\n            },\n            \"inline\": {\n                \"to\": from_line,\n                \"path\": file\n            },\n        })\n        response = requests.request(\n            \"POST\", self.bitbucket_comment_api_url, data=payload, headers=self.headers\n        )\n        return response\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.pr_url}/#L{relevant_file}\"\n        else:\n            link = f\"{self.pr_url}/#L{relevant_file}T{relevant_line_start}\"\n        return link\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            diff_files = self.get_diff_files()\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1 and self.pr_url:\n                link = f\"{self.pr_url}/#L{relevant_file}T{absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n\n    def publish_inline_comments(self, comments: list[dict]):\n        for comment in comments:\n            if 'position' in comment:\n                self.publish_inline_comment(comment['body'], comment['position'], comment['path'])\n            elif 'start_line' in comment:  # multi-line comment\n                # note that bitbucket does not seem to support range - only a comment on a single line - https://community.developer.atlassian.com/t/api-post-endpoint-for-inline-pull-request-comments/60452\n                self.publish_inline_comment(comment['body'], comment['start_line'], comment['path'])\n            elif 'line' in comment:  # single-line comment\n                self.publish_inline_comment(comment['body'], comment['line'], comment['path'])\n            else:\n                get_logger().error(f\"Could not publish inline comment {comment}\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        languages = {self._get_repo().get_data(\"language\"): 0}\n        return languages\n\n    def get_pr_branch(self):\n        return self.pr.source_branch\n\n    def get_pr_owner_id(self) -> str | None:\n        return self.workspace_slug\n\n    def get_pr_description_full(self):\n        return self.pr.description\n\n    def get_user_id(self):\n        return 0\n\n    def get_issue_comments(self):\n        raise NotImplementedError(\n            \"Bitbucket provider does not support issue comments yet\"\n        )\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, int, int]:\n        parsed_url = urlparse(pr_url)\n\n        if \"bitbucket.org\" not in parsed_url.netloc:\n            raise ValueError(\"The provided URL is not a valid Bitbucket URL\")\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n        if len(path_parts) < 4 or path_parts[2] != \"pull-requests\":\n            raise ValueError(\n                \"The provided URL does not appear to be a Bitbucket PR URL\"\n            )\n\n        workspace_slug = path_parts[0]\n        repo_slug = path_parts[1]\n        try:\n            pr_number = int(path_parts[3])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert PR number to integer\") from e\n\n        return workspace_slug, repo_slug, pr_number\n\n    def _get_repo(self):\n        if self.repo is None:\n            self.repo = self.bitbucket_client.workspaces.get(\n                self.workspace_slug\n            ).repositories.get(self.repo_slug)\n        return self.repo\n\n    def _get_pr(self):\n        return self._get_repo().pullrequests.get(self.pr_num)\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            if branch == self.pr.source_branch:\n                branch = self.pr.data[\"source\"][\"commit\"][\"hash\"]\n            elif branch == self.pr.destination_branch:\n                branch = self.pr.data[\"destination\"][\"commit\"][\"hash\"]\n            url = (f\"https://api.bitbucket.org/2.0/repositories/{self.workspace_slug}/{self.repo_slug}/src/\"\n                   f\"{branch}/{file_path}\")\n            response = requests.request(\"GET\", url, headers=self.headers)\n            if response.status_code == 404:  # not found\n                return \"\"\n            contents = response.text\n            return contents\n        except Exception:\n            return \"\"\n\n    def create_or_update_pr_file(self, file_path: str, branch: str, contents=\"\", message=\"\") -> None:\n        url = (f\"https://api.bitbucket.org/2.0/repositories/{self.workspace_slug}/{self.repo_slug}/src/\")\n        if not message:\n            if contents:\n                message = f\"Update {file_path}\"\n            else:\n                message = f\"Create {file_path}\"\n        files = {file_path: contents}\n        data = {\n            \"message\": message,\n            \"branch\": branch\n        }\n        headers = {'Authorization': self.headers['Authorization']} if 'Authorization' in self.headers else {}\n        try:\n            requests.request(\"POST\", url, headers=headers, data=data, files=files)\n        except Exception:\n            get_logger().exception(f\"Failed to create empty file {file_path} in branch {branch}\")\n\n    def _get_pr_file_content(self, remote_link: str):\n        try:\n            response = requests.request(\"GET\", remote_link, headers=self.headers)\n            if response.status_code == 404:  # not found\n                return \"\"\n            contents = response.text\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_commit_messages(self):\n        return \"\"  # not implemented yet\n\n    # bitbucket does not support labels\n    def publish_description(self, pr_title: str, description: str):\n        payload = json.dumps({\n            \"description\": description,\n            \"title\": pr_title\n\n        })\n\n        response = requests.request(\"PUT\", self.bitbucket_pull_request_api_url, headers=self.headers, data=payload)\n        try:\n            if response.status_code != 200:\n                get_logger().info(f\"Failed to update description, error code: {response.status_code}\")\n        except:\n            pass\n        return response\n\n    # bitbucket does not support labels\n    def publish_labels(self, pr_types: list):\n        pass\n\n    # bitbucket does not support labels\n    def get_pr_labels(self, update=False):\n        pass\n    #Clone related\n    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        if \"bitbucket.org\" not in repo_url_to_clone:\n            get_logger().error(\"Repo URL is not a valid bitbucket URL.\")\n            return None\n        bearer_token = self.bearer_token\n        if not bearer_token:\n            get_logger().error(\"No bearer token provided. Returning None\")\n            return None\n\n        #For example: For repo: https://bitbucket.org/codiumai/pr-agent-tests.git\n        #clone url will be: https://x-token-auth:<token>@bitbucket.org/codiumai/pr-agent-tests.git\n        (scheme, base_url) = repo_url_to_clone.split(\"bitbucket.org\")\n        if not all([scheme, base_url]):\n            get_logger().error(f\"repo_url_to_clone: {repo_url_to_clone} is not a valid bitbucket URL.\")\n            return None\n        clone_url = f\"{scheme}x-token-auth:{bearer_token}@bitbucket.org{base_url}\"\n        return clone_url",
    "start_line": 27,
    "end_line": 613,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class BitbucketProvider",
    "component_id": "pr_agent.git_providers.bitbucket_provider.BitbucketProvider"
  },
  "pr_agent.git_providers.bitbucket_server_provider.BitbucketServerProvider": {
    "id": "pr_agent.git_providers.bitbucket_server_provider.BitbucketServerProvider",
    "name": "BitbucketServerProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/bitbucket_server_provider.py",
    "relative_path": "pr_agent/git_providers/bitbucket_server_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.git_patch_processing.decode_if_bytes",
      "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
      "pr_agent.git_providers.git_provider.publish_inline_comments",
      "pr_agent.git_providers.git_provider.publish_inline_comment",
      "pr_agent.cli.run",
      "pr_agent.algo.utils.load_large_diff",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class BitbucketServerProvider(GitProvider):\n    def __init__(\n            self, pr_url: Optional[str] = None, incremental: Optional[bool] = False,\n            bitbucket_client: Optional[Bitbucket] = None,\n    ):\n        self.bitbucket_server_url = None\n        self.workspace_slug = None\n        self.repo_slug = None\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.pr_url = pr_url\n        self.temp_comments = []\n        self.incremental = incremental\n        self.diff_files = None\n        self.bitbucket_pull_request_api_url = pr_url\n        self.bearer_token = get_settings().get(\"BITBUCKET_SERVER.BEARER_TOKEN\", None)\n        self.bitbucket_server_url = self._parse_bitbucket_server(url=pr_url)\n        self.bitbucket_client = bitbucket_client or Bitbucket(url=self.bitbucket_server_url,\n                                                              token=get_settings().get(\"BITBUCKET_SERVER.BEARER_TOKEN\",\n                                                                                       None))\n        try:\n            self.bitbucket_api_version = parse_version(self.bitbucket_client.get(\"rest/api/1.0/application-properties\").get('version'))\n        except Exception:\n            self.bitbucket_api_version = None\n\n        if pr_url:\n            self.set_pr(pr_url)\n\n    def get_git_repo_url(self, pr_url: str=None) -> str: #bitbucket server does not support issue url, so ignore param\n        try:\n            parsed_url = urlparse(self.pr_url)\n            return f\"{parsed_url.scheme}://{parsed_url.netloc}/scm/{self.workspace_slug.lower()}/{self.repo_slug.lower()}.git\"\n        except Exception as e:\n            get_logger().exception(f\"url is not a valid merge requests url: {self.pr_url}\")\n            return \"\"\n\n    # Given a git repo url, return prefix and suffix of the provider in order to view a given file belonging to that repo.\n    # Example: https://bitbucket.dev.my_inc.com/scm/my_work/my_repo.git and branch: my_branch -> prefix: \"https://bitbucket.dev.my_inc.com/projects/MY_WORK/repos/my_repo/browse/src\", suffix: \"?at=refs%2Fheads%2Fmy_branch\"\n    # In case git url is not provided, provider will use PR context (which includes branch) to determine the prefix and suffix.\n    def get_canonical_url_parts(self, repo_git_url:str=None, desired_branch:str=None) -> Tuple[str, str]:\n        workspace_name = None\n        project_name = None\n        if not repo_git_url:\n            desired_branch = self.get_pr_branch()\n            workspace_name = self.workspace_slug\n            project_name = self.repo_slug\n        elif '.git' in repo_git_url and 'scm/' in repo_git_url:\n            repo_path = repo_git_url.split('.git')[0].split('scm/')[-1]\n            if repo_path.count('/') == 1:  # Has to have the form <workspace>/<repo>\n                workspace_name, project_name = repo_path.split('/')\n        if not workspace_name or not project_name:\n            get_logger().error(f\"workspace_name or project_name not found in context, either git url: {repo_git_url} or uninitialized workspace/project.\")\n            return (\"\", \"\")\n        prefix = f\"{self.bitbucket_server_url}/projects/{workspace_name}/repos/{project_name}/browse\"\n        suffix = f\"?at=refs%2Fheads%2F{desired_branch}\"\n        return (prefix, suffix)\n\n    def get_repo_settings(self):\n        try:\n            content = self.bitbucket_client.get_content_of_file(self.workspace_slug, self.repo_slug, \".pr_agent.toml\", self.get_pr_branch())\n\n            return content\n        except Exception as e:\n            if isinstance(e, HTTPError):\n                if e.response.status_code == 404:  # not found\n                    return \"\"\n\n            get_logger().error(f\"Failed to load .pr_agent.toml file, error: {e}\")\n            return \"\"\n\n    def get_pr_id(self):\n        return self.pr_num\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n        for suggestion in code_suggestions:\n            body = suggestion[\"body\"]\n            original_suggestion = suggestion.get('original_suggestion', None)  # needed for diff code\n            if original_suggestion:\n                try:\n                    existing_code = original_suggestion['existing_code'].rstrip() + \"\\n\"\n                    improved_code = original_suggestion['improved_code'].rstrip() + \"\\n\"\n                    diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                improved_code.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    # replace ```suggestion ... ``` with diff_code, using regex:\n                    body = re.sub(r'```suggestion.*?```', diff_code, body, flags=re.DOTALL)\n                except Exception as e:\n                    get_logger().exception(f\"Bitbucket failed to get diff code for publishing, error: {e}\")\n                    continue\n            relevant_file = suggestion[\"relevant_file\"]\n            relevant_lines_start = suggestion[\"relevant_lines_start\"]\n            relevant_lines_end = suggestion[\"relevant_lines_end\"]\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().warning(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().warning(\n                    f\"Failed to publish code suggestion, \"\n                    f\"relevant_lines_end is {relevant_lines_end} and \"\n                    f\"relevant_lines_start is {relevant_lines_start}\"\n                )\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                # Bitbucket does not support multi-line suggestions so use a code block instead - https://jira.atlassian.com/browse/BSERV-4553\n                body = body.replace(\"```suggestion\", \"```\")\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n\n        try:\n            self.publish_inline_comments(post_parameters_list)\n            return True\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().error(f\"Failed to publish code suggestion, error: {e}\")\n            return False\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'get_labels', 'gfm_markdown', 'publish_file_comments']:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.workspace_slug, self.repo_slug, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_file(self, path: str, commit_id: str):\n        file_content = \"\"\n        try:\n            file_content = self.bitbucket_client.get_content_of_file(self.workspace_slug,\n                                                                     self.repo_slug,\n                                                                     path,\n                                                                     commit_id)\n        except HTTPError as e:\n            get_logger().debug(f\"File {path} not found at commit id: {commit_id}\")\n        return file_content\n\n    def get_files(self):\n        changes = self.bitbucket_client.get_pull_requests_changes(self.workspace_slug, self.repo_slug, self.pr_num)\n        diffstat = [change[\"path\"]['toString'] for change in changes]\n        return diffstat\n\n    #gets the best common ancestor: https://git-scm.com/docs/git-merge-base\n    @staticmethod\n    def get_best_common_ancestor(source_commits_list, destination_commits_list, guaranteed_common_ancestor) -> str:\n        destination_commit_hashes = {commit['id'] for commit in destination_commits_list} | {guaranteed_common_ancestor}\n\n        for commit in source_commits_list:\n            for parent_commit in commit['parents']:\n                if parent_commit['id'] in destination_commit_hashes:\n                    return parent_commit['id']\n\n        return guaranteed_common_ancestor\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        if self.diff_files:\n            return self.diff_files\n\n        head_sha = self.pr.fromRef['latestCommit']\n\n        # if Bitbucket api version is >= 8.16 then use the merge-base api for 2-way diff calculation\n        if self.bitbucket_api_version is not None and self.bitbucket_api_version >= parse_version(\"8.16\"):\n            try:\n                base_sha = self.bitbucket_client.get(self._get_merge_base())['id']\n            except Exception as e:\n                get_logger().error(f\"Failed to get the best common ancestor for PR: {self.pr_url}, \\nerror: {e}\")\n                raise e\n        else:\n            source_commits_list = list(self.bitbucket_client.get_pull_requests_commits(\n                self.workspace_slug,\n                self.repo_slug,\n                self.pr_num\n            ))\n            # if Bitbucket api version is None or < 7.0 then do a simple diff with a guaranteed common ancestor\n            base_sha = source_commits_list[-1]['parents'][0]['id']\n            # if Bitbucket api version is 7.0-8.15 then use 2-way diff functionality for the base_sha\n            if self.bitbucket_api_version is not None and self.bitbucket_api_version >= parse_version(\"7.0\"):\n                try:\n                    destination_commits = list(\n                        self.bitbucket_client.get_commits(self.workspace_slug, self.repo_slug, base_sha,\n                                                          self.pr.toRef['latestCommit']))\n                    base_sha = self.get_best_common_ancestor(source_commits_list, destination_commits, base_sha)\n                except Exception as e:\n                    get_logger().error(\n                        f\"Failed to get the commit list for calculating best common ancestor for PR: {self.pr_url}, \\nerror: {e}\")\n                    raise e\n\n        diff_files = []\n        original_file_content_str = \"\"\n        new_file_content_str = \"\"\n\n        changes = self.bitbucket_client.get_pull_requests_changes(self.workspace_slug, self.repo_slug, self.pr_num)\n        for change in changes:\n            file_path = change['path']['toString']\n            if not is_valid_file(file_path.split(\"/\")[-1]):\n                get_logger().info(f\"Skipping a non-code file: {file_path}\")\n                continue\n\n            match change['type']:\n                case 'ADD':\n                    edit_type = EDIT_TYPE.ADDED\n                    new_file_content_str = self.get_file(file_path, head_sha)\n                    new_file_content_str = decode_if_bytes(new_file_content_str)\n                    original_file_content_str = \"\"\n                case 'DELETE':\n                    edit_type = EDIT_TYPE.DELETED\n                    new_file_content_str = \"\"\n                    original_file_content_str = self.get_file(file_path, base_sha)\n                    original_file_content_str = decode_if_bytes(original_file_content_str)\n                case 'RENAME':\n                    edit_type = EDIT_TYPE.RENAMED\n                case _:\n                    edit_type = EDIT_TYPE.MODIFIED\n                    original_file_content_str = self.get_file(file_path, base_sha)\n                    original_file_content_str = decode_if_bytes(original_file_content_str)\n                    new_file_content_str = self.get_file(file_path, head_sha)\n                    new_file_content_str = decode_if_bytes(new_file_content_str)\n\n            patch = load_large_diff(file_path, new_file_content_str, original_file_content_str, show_warning=False)\n\n            diff_files.append(\n                FilePatchInfo(\n                    original_file_content_str,\n                    new_file_content_str,\n                    patch,\n                    file_path,\n                    edit_type=edit_type,\n                )\n            )\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if not is_temporary:\n            self.bitbucket_client.add_pull_request_comment(self.workspace_slug, self.repo_slug, self.pr_num, pr_comment)\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except ValueError as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        pass\n\n    # function to create_inline_comment\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n\n        position, absolute_position = find_line_number_of_relevant_line_in_file(\n            self.get_diff_files(),\n            relevant_file.strip('`'),\n            relevant_line_in_file,\n            absolute_position\n        )\n        if position == -1:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=absolute_position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comment(self, comment: str, from_line: int, file: str, original_suggestion=None):\n        payload = {\n            \"text\": comment,\n            \"severity\": \"NORMAL\",\n            \"anchor\": {\n                \"diffType\": \"EFFECTIVE\",\n                \"path\": file,\n                \"lineType\": \"ADDED\",\n                \"line\": from_line,\n                \"fileType\": \"TO\"\n            }\n        }\n\n        try:\n            self.bitbucket_client.post(self._get_pr_comments_path(), data=payload)\n        except Exception as e:\n            get_logger().error(f\"Failed to publish inline comment to '{file}' at line {from_line}, error: {e}\")\n            raise e\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}\"\n        else:\n            link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}?t={relevant_line_start}\"\n        return link\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            diff_files = self.get_diff_files()\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                if self.pr:\n                    link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}?t={absolute_position}\"\n                    return link\n                else:\n                    if get_settings().config.verbosity_level >= 2:\n                        get_logger().info(f\"Failed adding line link to '{relevant_file}' since PR not set\")\n            else:\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"Failed adding line link to '{relevant_file}' since position not found\")\n\n            if absolute_position != -1 and self.pr_url:\n                link = f\"{self.pr_url}/diff#{quote_plus(relevant_file)}?t={absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link to '{relevant_file}', error: {e}\")\n\n        return \"\"\n\n    def publish_inline_comments(self, comments: list[dict]):\n        for comment in comments:\n            if 'position' in comment:\n                self.publish_inline_comment(comment['body'], comment['position'], comment['path'])\n            elif 'start_line' in comment: # multi-line comment\n                # note that bitbucket does not seem to support range - only a comment on a single line - https://community.developer.atlassian.com/t/api-post-endpoint-for-inline-pull-request-comments/60452\n                self.publish_inline_comment(comment['body'], comment['start_line'], comment['path'])\n            elif 'line' in comment: # single-line comment\n                self.publish_inline_comment(comment['body'], comment['line'], comment['path'])\n            else:\n                get_logger().error(f\"Could not publish inline comment: {comment}\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        return {\"yaml\": 0}  # devops LOL\n\n    def get_pr_branch(self):\n        return self.pr.fromRef['displayId']\n\n    def get_pr_owner_id(self) -> str | None:\n        return self.workspace_slug\n\n    def get_pr_description_full(self):\n        if hasattr(self.pr, \"description\"):\n            return self.pr.description\n        else:\n            return None\n\n    def get_user_id(self):\n        return 0\n\n    def get_issue_comments(self):\n        raise NotImplementedError(\n            \"Bitbucket provider does not support issue comments yet\"\n        )\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    @staticmethod\n    def _parse_bitbucket_server(url: str) -> str:\n        # pr url format: f\"{bitbucket_server}/projects/{project_name}/repos/{repository_name}/pull-requests/{pr_id}\"\n        parsed_url = urlparse(url)\n        server_path = parsed_url.path.split(\"/projects/\")\n        if len(server_path) > 1:\n            server_path = server_path[0].strip(\"/\")\n            return f\"{parsed_url.scheme}://{parsed_url.netloc}/{server_path}\".strip(\"/\")\n        return f\"{parsed_url.scheme}://{parsed_url.netloc}\"\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, str, int]:\n        # pr url format: f\"{bitbucket_server}/projects/{project_name}/repos/{repository_name}/pull-requests/{pr_id}\"\n        parsed_url = urlparse(pr_url)\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n        try:\n            projects_index = path_parts.index(\"projects\")\n        except ValueError:\n            projects_index = -1\n\n        try:\n            users_index = path_parts.index(\"users\")\n        except ValueError:\n            users_index = -1\n\n        if projects_index == -1 and users_index == -1:\n            raise ValueError(f\"The provided URL '{pr_url}' does not appear to be a Bitbucket PR URL\")\n\n        if projects_index != -1:\n            path_parts = path_parts[projects_index:]\n        else:\n            path_parts = path_parts[users_index:]\n\n        if len(path_parts) < 6 or path_parts[2] != \"repos\" or path_parts[4] != \"pull-requests\":\n            raise ValueError(\n                f\"The provided URL '{pr_url}' does not appear to be a Bitbucket PR URL\"\n            )\n\n        workspace_slug = path_parts[1]\n        if users_index != -1:\n            workspace_slug = f\"~{workspace_slug}\"\n        repo_slug = path_parts[3]\n        try:\n            pr_number = int(path_parts[5])\n        except ValueError as e:\n            raise ValueError(f\"Unable to convert PR number '{path_parts[5]}' to integer\") from e\n\n        return workspace_slug, repo_slug, pr_number\n\n    def _get_repo(self):\n        if self.repo is None:\n            self.repo = self.bitbucket_client.get_repo(self.workspace_slug, self.repo_slug)\n        return self.repo\n\n    def _get_pr(self):\n        try:\n            pr = self.bitbucket_client.get_pull_request(self.workspace_slug, self.repo_slug,\n                                                        pull_request_id=self.pr_num)\n            return type('new_dict', (object,), pr)\n        except Exception as e:\n            get_logger().error(f\"Failed to get pull request, error: {e}\")\n            raise e\n\n    def _get_pr_file_content(self, remote_link: str):\n        return \"\"\n\n    def get_commit_messages(self):\n        return \"\"\n\n    # bitbucket does not support labels\n    def publish_description(self, pr_title: str, description: str):\n        payload = {\n            \"version\": self.pr.version,\n            \"description\": description,\n            \"title\": pr_title,\n            \"reviewers\": self.pr.reviewers  # needs to be sent otherwise gets wiped\n        }\n        try:\n            self.bitbucket_client.update_pull_request(self.workspace_slug, self.repo_slug, str(self.pr_num), payload)\n        except Exception as e:\n            get_logger().error(f\"Failed to update pull request, error: {e}\")\n            raise e\n\n    # bitbucket does not support labels\n    def publish_labels(self, pr_types: list):\n        pass\n\n    # bitbucket does not support labels\n    def get_pr_labels(self, update=False):\n        pass\n\n    def _get_pr_comments_path(self):\n        return f\"rest/api/latest/projects/{self.workspace_slug}/repos/{self.repo_slug}/pull-requests/{self.pr_num}/comments\"\n\n    def _get_merge_base(self):\n        return f\"rest/api/latest/projects/{self.workspace_slug}/repos/{self.repo_slug}/pull-requests/{self.pr_num}/merge-base\"\n    # Clone related\n    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        if 'bitbucket.' not in repo_url_to_clone:\n            get_logger().error(\"Repo URL is not a valid bitbucket URL.\")\n            return None\n        bearer_token = self.bearer_token\n        if not bearer_token:\n            get_logger().error(\"No bearer token provided. Returning None\")\n            return None\n        # Return unmodified URL as the token is passed via HTTP headers in _clone_inner, as seen below.\n        return repo_url_to_clone\n\n    #Overriding the shell command, since for some reason usage of x-token-auth doesn't work, as mentioned here:\n    # https://stackoverflow.com/questions/56760396/cloning-bitbucket-server-repo-with-access-tokens\n    def _clone_inner(self, repo_url: str, dest_folder: str, operation_timeout_in_seconds: int=None):\n        bearer_token = self.bearer_token\n        if not bearer_token:\n            #Shouldn't happen since this is checked in _prepare_clone, therefore - throwing an exception.\n            raise RuntimeError(f\"Bearer token is required!\")\n\n        cli_args = shlex.split(f\"git clone -c http.extraHeader='Authorization: Bearer {bearer_token}' \"\n                               f\"--filter=blob:none --depth 1 {repo_url} {dest_folder}\")\n\n        subprocess.run(cli_args, check=True,  # check=True will raise an exception if the command fails\n            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=operation_timeout_in_seconds)",
    "start_line": 23,
    "end_line": 539,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class BitbucketServerProvider",
    "component_id": "pr_agent.git_providers.bitbucket_server_provider.BitbucketServerProvider"
  },
  "pr_agent.git_providers.codecommit_client.CodeCommitDifferencesResponse": {
    "id": "pr_agent.git_providers.codecommit_client.CodeCommitDifferencesResponse",
    "name": "CodeCommitDifferencesResponse",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_client.py",
    "relative_path": "pr_agent/git_providers/codecommit_client.py",
    "depends_on": [],
    "source_code": "class CodeCommitDifferencesResponse:\n    \"\"\"\n    CodeCommitDifferencesResponse is the response object returned from our get_differences() function.\n    It maps the JSON response to member variables of this class.\n    \"\"\"\n\n    def __init__(self, json: dict):\n        before_blob = json.get(\"beforeBlob\", {})\n        after_blob = json.get(\"afterBlob\", {})\n\n        self.before_blob_id = before_blob.get(\"blobId\", \"\")\n        self.before_blob_path = before_blob.get(\"path\", \"\")\n        self.after_blob_id = after_blob.get(\"blobId\", \"\")\n        self.after_blob_path = after_blob.get(\"path\", \"\")\n        self.change_type = json.get(\"changeType\", \"\")",
    "start_line": 5,
    "end_line": 19,
    "has_docstring": true,
    "docstring": "CodeCommitDifferencesResponse is the response object returned from our get_differences() function.\nIt maps the JSON response to member variables of this class.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CodeCommitDifferencesResponse",
    "component_id": "pr_agent.git_providers.codecommit_client.CodeCommitDifferencesResponse"
  },
  "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestResponse": {
    "id": "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestResponse",
    "name": "CodeCommitPullRequestResponse",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_client.py",
    "relative_path": "pr_agent/git_providers/codecommit_client.py",
    "depends_on": [
      "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestTarget"
    ],
    "source_code": "class CodeCommitPullRequestResponse:\n    \"\"\"\n    CodeCommitPullRequestResponse is the response object returned from our get_pr() function.\n    It maps the JSON response to member variables of this class.\n    \"\"\"\n\n    def __init__(self, json: dict):\n        self.title = json.get(\"title\", \"\")\n        self.description = json.get(\"description\", \"\")\n\n        self.targets = []\n        for target in json.get(\"pullRequestTargets\", []):\n            self.targets.append(CodeCommitPullRequestResponse.CodeCommitPullRequestTarget(target))\n\n    class CodeCommitPullRequestTarget:\n        \"\"\"\n        CodeCommitPullRequestTarget is a subclass of CodeCommitPullRequestResponse that\n        holds details about an individual target commit.\n        \"\"\"\n\n        def __init__(self, json: dict):\n            self.source_commit = json.get(\"sourceCommit\", \"\")\n            self.source_branch = json.get(\"sourceReference\", \"\")\n            self.destination_commit = json.get(\"destinationCommit\", \"\")\n            self.destination_branch = json.get(\"destinationReference\", \"\")",
    "start_line": 22,
    "end_line": 46,
    "has_docstring": true,
    "docstring": "CodeCommitPullRequestResponse is the response object returned from our get_pr() function.\nIt maps the JSON response to member variables of this class.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CodeCommitPullRequestResponse",
    "component_id": "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestResponse"
  },
  "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestTarget": {
    "id": "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestTarget",
    "name": "CodeCommitPullRequestTarget",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_client.py",
    "relative_path": "pr_agent/git_providers/codecommit_client.py",
    "depends_on": [],
    "source_code": "    class CodeCommitPullRequestTarget:\n        \"\"\"\n        CodeCommitPullRequestTarget is a subclass of CodeCommitPullRequestResponse that\n        holds details about an individual target commit.\n        \"\"\"\n\n        def __init__(self, json: dict):\n            self.source_commit = json.get(\"sourceCommit\", \"\")\n            self.source_branch = json.get(\"sourceReference\", \"\")\n            self.destination_commit = json.get(\"destinationCommit\", \"\")\n            self.destination_branch = json.get(\"destinationReference\", \"\")",
    "start_line": 36,
    "end_line": 46,
    "has_docstring": true,
    "docstring": "CodeCommitPullRequestTarget is a subclass of CodeCommitPullRequestResponse that\nholds details about an individual target commit.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CodeCommitPullRequestTarget",
    "component_id": "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestTarget"
  },
  "pr_agent.git_providers.codecommit_client.CodeCommitClient": {
    "id": "pr_agent.git_providers.codecommit_client.CodeCommitClient",
    "name": "CodeCommitClient",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_client.py",
    "relative_path": "pr_agent/git_providers/codecommit_client.py",
    "depends_on": [
      "pr_agent.git_providers.codecommit_client.CodeCommitPullRequestResponse",
      "pr_agent.git_providers.codecommit_client.CodeCommitDifferencesResponse"
    ],
    "source_code": "class CodeCommitClient:\n    \"\"\"\n    CodeCommitClient is a wrapper around the AWS boto3 SDK for the CodeCommit client\n    \"\"\"\n\n    def __init__(self):\n        self.boto_client = None\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\"gfm_markdown\"]:\n            return False\n        return True\n\n    def _connect_boto_client(self):\n        try:\n            self.boto_client = boto3.client(\"codecommit\")\n        except Exception as e:\n            raise ValueError(f\"Failed to connect to AWS CodeCommit: {e}\") from e\n\n    def get_differences(self, repo_name: int, destination_commit: str, source_commit: str):\n        \"\"\"\n        Get the differences between two commits in CodeCommit.\n\n        Args:\n        - repo_name: Name of the repository\n        - destination_commit: Commit hash you want to merge into (the \"before\" hash) (usually on the main or master branch)\n        - source_commit: Commit hash of the code you are adding (the \"after\" branch)\n\n        Returns:\n        - List of CodeCommitDifferencesResponse objects\n\n        Boto3 Documentation:\n        - aws codecommit get-differences\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/get_differences.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        # The differences response from AWS is paginated, so we need to iterate through the pages to get all the differences.\n        differences = []\n        try:\n            paginator = self.boto_client.get_paginator(\"get_differences\")\n            for page in paginator.paginate(\n                repositoryName=repo_name,\n                beforeCommitSpecifier=destination_commit,\n                afterCommitSpecifier=source_commit,\n            ):\n                differences.extend(page.get(\"differences\", []))\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve differences: Repository does not exist: {repo_name}\") from e\n            raise ValueError(f\"CodeCommit cannot retrieve differences for {source_commit}..{destination_commit}\") from e\n        except Exception as e:\n            raise ValueError(f\"CodeCommit cannot retrieve differences for {source_commit}..{destination_commit}\") from e\n\n        output = []\n        for json in differences:\n            output.append(CodeCommitDifferencesResponse(json))\n        return output\n\n    def get_file(self, repo_name: str, file_path: str, sha_hash: str, optional: bool = False):\n        \"\"\"\n        Retrieve a file from CodeCommit.\n\n        Args:\n        - repo_name: Name of the repository\n        - file_path: Path to the file you are retrieving\n        - sha_hash: Commit hash of the file you are retrieving\n\n        Returns:\n        - File contents\n\n        Boto3 Documentation:\n        - aws codecommit get_file\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/get_file.html\n        \"\"\"\n        if not file_path:\n            return \"\"\n\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            response = self.boto_client.get_file(repositoryName=repo_name, commitSpecifier=sha_hash, filePath=file_path)\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve PR: Repository does not exist: {repo_name}\") from e\n            # if the file does not exist, but is flagged as optional, then return an empty string\n            if optional and e.response[\"Error\"][\"Code\"] == 'FileDoesNotExistException':\n                return \"\"\n            raise ValueError(f\"CodeCommit cannot retrieve file '{file_path}' from repository '{repo_name}'\") from e\n        except Exception as e:\n            raise ValueError(f\"CodeCommit cannot retrieve file '{file_path}' from repository '{repo_name}'\") from e\n        if \"fileContent\" not in response:\n            raise ValueError(f\"File content is empty for file: {file_path}\")\n\n        return response.get(\"fileContent\", \"\")\n\n    def get_pr(self, repo_name: str, pr_number: int):\n        \"\"\"\n        Get a information about a CodeCommit PR.\n\n        Args:\n        - repo_name: Name of the repository\n        - pr_number: The PR number you are requesting\n\n        Returns:\n        - CodeCommitPullRequestResponse object\n\n        Boto3 Documentation:\n        - aws codecommit get_pull_request\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/get_pull_request.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            response = self.boto_client.get_pull_request(pullRequestId=str(pr_number))\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve PR: PR number does not exist: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"CodeCommit cannot retrieve PR: Repository does not exist: {repo_name}\") from e\n            raise ValueError(f\"CodeCommit cannot retrieve PR: {pr_number}: boto client error\") from e\n        except Exception as e:\n            raise ValueError(f\"CodeCommit cannot retrieve PR: {pr_number}\") from e\n\n        if \"pullRequest\" not in response:\n            raise ValueError(\"CodeCommit PR number not found: {pr_number}\")\n\n        return CodeCommitPullRequestResponse(response.get(\"pullRequest\", {}))\n\n    def publish_description(self, pr_number: int, pr_title: str, pr_body: str):\n        \"\"\"\n        Set the title and description on a pull request\n\n        Args:\n        - pr_number: the AWS CodeCommit pull request number\n        - pr_title: title of the pull request\n        - pr_body: body of the pull request\n\n        Returns:\n        - None\n\n        Boto3 Documentation:\n        - aws codecommit update_pull_request_title\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/update_pull_request_title.html\n        - aws codecommit update_pull_request_description\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/update_pull_request_description.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            self.boto_client.update_pull_request_title(pullRequestId=str(pr_number), title=pr_title)\n            self.boto_client.update_pull_request_description(pullRequestId=str(pr_number), description=pr_body)\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestDoesNotExistException':\n                raise ValueError(f\"PR number does not exist: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'InvalidTitleException':\n                raise ValueError(f\"Invalid title for PR number: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'InvalidDescriptionException':\n                raise ValueError(f\"Invalid description for PR number: {pr_number}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestAlreadyClosedException':\n                raise ValueError(f\"PR is already closed: PR number: {pr_number}\") from e\n            raise ValueError(f\"Boto3 client error calling publish_description\") from e\n        except Exception as e:\n            raise ValueError(f\"Error calling publish_description\") from e\n\n    def publish_comment(self, repo_name: str, pr_number: int, destination_commit: str, source_commit: str, comment: str, annotation_file: str = None, annotation_line: int = None):\n        \"\"\"\n        Publish a comment to a pull request\n\n        Args:\n        - repo_name: name of the repository\n        - pr_number: number of the pull request\n        - destination_commit: The commit hash you want to merge into (the \"before\" hash) (usually on the main or master branch)\n        - source_commit: The commit hash of the code you are adding (the \"after\" branch)\n        - comment: The comment you want to publish\n        - annotation_file: The file you want to annotate (optional)\n        - annotation_line: The line number you want to annotate (optional)\n\n        Comment annotations for CodeCommit are different than GitHub.\n        CodeCommit only designates the starting line number for the comment.\n        It does not support the ending line number to highlight a range of lines.\n\n        Returns:\n        - None\n\n        Boto3 Documentation:\n        - aws codecommit post_comment_for_pull_request\n        - https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/post_comment_for_pull_request.html\n        \"\"\"\n        if self.boto_client is None:\n            self._connect_boto_client()\n\n        try:\n            # If the comment has code annotations,\n            # then set the file path and line number in the location dictionary\n            if annotation_file and annotation_line:\n                self.boto_client.post_comment_for_pull_request(\n                    pullRequestId=str(pr_number),\n                    repositoryName=repo_name,\n                    beforeCommitId=destination_commit,\n                    afterCommitId=source_commit,\n                    content=comment,\n                    location={\n                        \"filePath\": annotation_file,\n                        \"filePosition\": annotation_line,\n                        \"relativeFileVersion\": \"AFTER\",\n                    },\n                )\n            else:\n                # The comment does not have code annotations\n                self.boto_client.post_comment_for_pull_request(\n                    pullRequestId=str(pr_number),\n                    repositoryName=repo_name,\n                    beforeCommitId=destination_commit,\n                    afterCommitId=source_commit,\n                    content=comment,\n                )\n        except botocore.exceptions.ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == 'RepositoryDoesNotExistException':\n                raise ValueError(f\"Repository does not exist: {repo_name}\") from e\n            if e.response[\"Error\"][\"Code\"] == 'PullRequestDoesNotExistException':\n                raise ValueError(f\"PR number does not exist: {pr_number}\") from e\n            raise ValueError(f\"Boto3 client error calling post_comment_for_pull_request\") from e\n        except Exception as e:\n            raise ValueError(f\"Error calling post_comment_for_pull_request\") from e",
    "start_line": 49,
    "end_line": 277,
    "has_docstring": true,
    "docstring": "CodeCommitClient is a wrapper around the AWS boto3 SDK for the CodeCommit client",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CodeCommitClient",
    "component_id": "pr_agent.git_providers.codecommit_client.CodeCommitClient"
  },
  "pr_agent.git_providers.codecommit_provider.PullRequestCCMimic": {
    "id": "pr_agent.git_providers.codecommit_provider.PullRequestCCMimic",
    "name": "PullRequestCCMimic",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_provider.py",
    "relative_path": "pr_agent/git_providers/codecommit_provider.py",
    "depends_on": [],
    "source_code": "class PullRequestCCMimic:\n    \"\"\"\n    This class mimics the PullRequest class from the PyGithub library for the CodeCommitProvider.\n    \"\"\"\n\n    def __init__(self, title: str, diff_files: List[FilePatchInfo]):\n        self.title = title\n        self.diff_files = diff_files\n        self.description = None\n        self.source_commit = None\n        self.source_branch = None  # the branch containing your new code changes\n        self.destination_commit = None\n        self.destination_branch = None  # the branch you are going to merge into",
    "start_line": 17,
    "end_line": 29,
    "has_docstring": true,
    "docstring": "This class mimics the PullRequest class from the PyGithub library for the CodeCommitProvider.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PullRequestCCMimic",
    "component_id": "pr_agent.git_providers.codecommit_provider.PullRequestCCMimic"
  },
  "pr_agent.git_providers.codecommit_provider.CodeCommitFile": {
    "id": "pr_agent.git_providers.codecommit_provider.CodeCommitFile",
    "name": "CodeCommitFile",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_provider.py",
    "relative_path": "pr_agent/git_providers/codecommit_provider.py",
    "depends_on": [],
    "source_code": "class CodeCommitFile:\n    \"\"\"\n    This class represents a file in a pull request in CodeCommit.\n    \"\"\"\n\n    def __init__(\n        self,\n        a_path: str,\n        a_blob_id: str,\n        b_path: str,\n        b_blob_id: str,\n        edit_type: EDIT_TYPE,\n    ):\n        self.a_path = a_path\n        self.a_blob_id = a_blob_id\n        self.b_path = b_path\n        self.b_blob_id = b_blob_id\n        self.edit_type: EDIT_TYPE = edit_type\n        self.filename = b_path if b_path else a_path",
    "start_line": 32,
    "end_line": 50,
    "has_docstring": true,
    "docstring": "This class represents a file in a pull request in CodeCommit.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CodeCommitFile",
    "component_id": "pr_agent.git_providers.codecommit_provider.CodeCommitFile"
  },
  "pr_agent.git_providers.codecommit_provider.CodeCommitProvider": {
    "id": "pr_agent.git_providers.codecommit_provider.CodeCommitProvider",
    "name": "CodeCommitProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/codecommit_provider.py",
    "relative_path": "pr_agent/git_providers/codecommit_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.codecommit_provider.PullRequestCCMimic",
      "pr_agent.git_providers.git_provider.publish_description",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.codecommit_provider.CodeCommitFile",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.codecommit_client.CodeCommitClient",
      "pr_agent.algo.utils.load_large_diff",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class CodeCommitProvider(GitProvider):\n    \"\"\"\n    This class implements the GitProvider interface for AWS CodeCommit repositories.\n    \"\"\"\n\n    def __init__(self, pr_url: Optional[str] = None, incremental: Optional[bool] = False):\n        self.codecommit_client = CodeCommitClient()\n        self.aws_client = None\n        self.repo_name = None\n        self.pr_num = None\n        self.pr = None\n        self.diff_files = None\n        self.git_files = None\n        self.pr_url = pr_url\n        if pr_url:\n            self.set_pr(pr_url)\n\n    def provider_name(self):\n        return \"CodeCommit\"\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\n            \"get_issue_comments\",\n            \"create_inline_comment\",\n            \"publish_inline_comments\",\n            \"get_labels\",\n            \"gfm_markdown\"\n        ]:\n            return False\n        return True\n\n    def set_pr(self, pr_url: str):\n        self.repo_name, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def get_files(self) -> list[CodeCommitFile]:\n        # bring files from CodeCommit only once\n        if self.git_files:\n            return self.git_files\n\n        self.git_files = []\n        differences = self.codecommit_client.get_differences(self.repo_name, self.pr.destination_commit, self.pr.source_commit)\n        for item in differences:\n            self.git_files.append(CodeCommitFile(item.before_blob_path,\n                                                 item.before_blob_id,\n                                                 item.after_blob_path,\n                                                 item.after_blob_id,\n                                                 CodeCommitProvider._get_edit_type(item.change_type)))\n        return self.git_files\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in CodeCommit,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n        # bring files from CodeCommit only once\n        if self.diff_files:\n            return self.diff_files\n\n        self.diff_files = []\n\n        files = self.get_files()\n        for diff_item in files:\n            patch_filename = \"\"\n            if diff_item.a_blob_id is not None:\n                patch_filename = diff_item.a_path\n                original_file_content_str = self.codecommit_client.get_file(\n                    self.repo_name, diff_item.a_path, self.pr.destination_commit)\n                if isinstance(original_file_content_str, (bytes, bytearray)):\n                    original_file_content_str = original_file_content_str.decode(\"utf-8\")\n            else:\n                original_file_content_str = \"\"\n\n            if diff_item.b_blob_id is not None:\n                patch_filename = diff_item.b_path\n                new_file_content_str = self.codecommit_client.get_file(self.repo_name, diff_item.b_path, self.pr.source_commit)\n                if isinstance(new_file_content_str, (bytes, bytearray)):\n                    new_file_content_str = new_file_content_str.decode(\"utf-8\")\n            else:\n                new_file_content_str = \"\"\n\n            patch = load_large_diff(patch_filename, new_file_content_str, original_file_content_str)\n\n            # Store the diffs as a list of FilePatchInfo objects\n            info = FilePatchInfo(\n                original_file_content_str,\n                new_file_content_str,\n                patch,\n                diff_item.b_path,\n                edit_type=diff_item.edit_type,\n                old_filename=None\n                if diff_item.a_path == diff_item.b_path\n                else diff_item.a_path,\n            )\n            # Only add valid files to the diff list\n            # \"bad extensions\" are set in the language_extensions.toml file\n            # a \"valid file\" is one that is not in the \"bad extensions\" list\n            if is_valid_file(info.filename):\n                self.diff_files.append(info)\n\n        return self.diff_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        try:\n            self.codecommit_client.publish_description(\n                pr_number=self.pr_num,\n                pr_title=pr_title,\n                pr_body=CodeCommitProvider._add_additional_newlines(pr_body),\n            )\n        except Exception as e:\n            raise ValueError(f\"CodeCommit Cannot publish description for PR: {self.pr_num}\") from e\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if is_temporary:\n            get_logger().info(pr_comment)\n            return\n\n        pr_comment = CodeCommitProvider._remove_markdown_html(pr_comment)\n        pr_comment = CodeCommitProvider._add_additional_newlines(pr_comment)\n\n        try:\n            self.codecommit_client.publish_comment(\n                repo_name=self.repo_name,\n                pr_number=self.pr_num,\n                destination_commit=self.pr.destination_commit,\n                source_commit=self.pr.source_commit,\n                comment=pr_comment,\n            )\n        except Exception as e:\n            raise ValueError(f\"CodeCommit Cannot publish comment for PR: {self.pr_num}\") from e\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        counter = 1\n        for suggestion in code_suggestions:\n            # Verify that each suggestion has the required keys\n            if not all(key in suggestion for key in [\"body\", \"relevant_file\", \"relevant_lines_start\"]):\n                get_logger().warning(f\"Skipping code suggestion #{counter}: Each suggestion must have 'body', 'relevant_file', 'relevant_lines_start' keys\")\n                continue\n\n            # Publish the code suggestion to CodeCommit\n            try:\n                get_logger().debug(f\"Code Suggestion #{counter} in file: {suggestion['relevant_file']}: {suggestion['relevant_lines_start']}\")\n                self.codecommit_client.publish_comment(\n                    repo_name=self.repo_name,\n                    pr_number=self.pr_num,\n                    destination_commit=self.pr.destination_commit,\n                    source_commit=self.pr.source_commit,\n                    comment=suggestion[\"body\"],\n                    annotation_file=suggestion[\"relevant_file\"],\n                    annotation_line=suggestion[\"relevant_lines_start\"],\n                )\n            except Exception as e:\n                raise ValueError(f\"CodeCommit Cannot publish code suggestions for PR: {self.pr_num}\") from e\n\n            counter += 1\n\n        # The calling function passes in a list of code suggestions, and this function publishes each suggestion one at a time.\n        # If we were to return False here, the calling function will attempt to publish the same list of code suggestions again, one at a time.\n        # Since this function publishes the suggestions one at a time anyway, we always return True here to avoid the retry.\n        return True\n\n    def publish_labels(self, labels):\n        return [\"\"]  # not implemented yet\n\n    def get_pr_labels(self, update=False):\n        return [\"\"]  # not implemented yet\n\n    def remove_initial_comment(self):\n        return \"\"  # not implemented yet\n\n    def remove_comment(self, comment):\n        return \"\"  # not implemented yet\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/codecommit/client/post_comment_for_compared_commit.html\n        raise NotImplementedError(\"CodeCommit provider does not support publishing inline comments yet\")\n\n    def publish_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\"CodeCommit provider does not support publishing inline comments yet\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_pr_id(self):\n        \"\"\"\n        Returns the PR ID in the format: \"repo_name/pr_number\".\n        Note: This is an internal identifier for PR-Agent,\n        and is not the same as the CodeCommit PR identifier.\n        \"\"\"\n        try:\n            pr_id = f\"{self.repo_name}/{self.pr_num}\"\n            return pr_id\n        except:\n            return \"\"\n\n    def get_languages(self):\n        \"\"\"\n        Returns a dictionary of languages, containing the percentage of each language used in the PR.\n\n        Returns:\n        - dict: A dictionary where each key is a language name and the corresponding value is the percentage of that language in the PR.\n        \"\"\"\n        commit_files = self.get_files()\n        filenames = [ item.filename for item in commit_files ]\n        extensions = CodeCommitProvider._get_file_extensions(filenames)\n\n        # Calculate the percentage of each file extension in the PR\n        percentages = CodeCommitProvider._get_language_percentages(extensions)\n\n        # The global language_extension_map is a dictionary of languages,\n        # where each dictionary item is a BoxList of extensions.\n        # We want a dictionary of extensions,\n        # where each dictionary item is a language name.\n        # We build that language->extension dictionary here in main_extensions_flat.\n        main_extensions_flat = {}\n        language_extension_map_org = get_settings().language_extension_map_org\n        language_extension_map = {k.lower(): v for k, v in language_extension_map_org.items()}\n        for language, extensions in language_extension_map.items():\n            for ext in extensions:\n                main_extensions_flat[ext] = language\n\n        # Map the file extension/languages to percentages\n        languages = {}\n        for ext, pct in percentages.items():\n            languages[main_extensions_flat.get(ext, \"\")] = pct\n\n        return languages\n\n    def get_pr_branch(self):\n        return self.pr.source_branch\n\n    def get_pr_description_full(self) -> str:\n        return self.pr.description\n\n    def get_user_id(self):\n        return -1  # not implemented yet\n\n    def get_issue_comments(self):\n        raise NotImplementedError(\"CodeCommit provider does not support issue comments yet\")\n\n    def get_repo_settings(self):\n        # a local \".pr_agent.toml\" settings file is optional\n        settings_filename = \".pr_agent.toml\"\n        return self.codecommit_client.get_file(self.repo_name, settings_filename, self.pr.source_commit, optional=True)\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        get_logger().info(\"CodeCommit provider does not support eyes reaction yet\")\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        get_logger().info(\"CodeCommit provider does not support removing reactions yet\")\n        return True\n\n    @staticmethod\n    def _parse_pr_url(pr_url: str) -> Tuple[str, int]:\n        \"\"\"\n        Parse the CodeCommit PR URL and return the repository name and PR number.\n\n        Args:\n        - pr_url: the full AWS CodeCommit pull request URL\n\n        Returns:\n        - Tuple[str, int]: A tuple containing the repository name and PR number.\n        \"\"\"\n        # Example PR URL:\n        # https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/__MY_REPO__/pull-requests/123456\"\n        parsed_url = urlparse(pr_url)\n\n        if not CodeCommitProvider._is_valid_codecommit_hostname(parsed_url.netloc):\n            raise ValueError(f\"The provided URL is not a valid CodeCommit URL: {pr_url}\")\n\n        path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n        if (\n            len(path_parts) < 6\n            or path_parts[0] != \"codesuite\"\n            or path_parts[1] != \"codecommit\"\n            or path_parts[2] != \"repositories\"\n            or path_parts[4] != \"pull-requests\"\n        ):\n            raise ValueError(f\"The provided URL does not appear to be a CodeCommit PR URL: {pr_url}\")\n\n        repo_name = path_parts[3]\n\n        try:\n            pr_number = int(path_parts[5])\n        except ValueError as e:\n            raise ValueError(f\"Unable to convert PR number to integer: '{path_parts[5]}'\") from e\n\n        return repo_name, pr_number\n\n    @staticmethod\n    def _is_valid_codecommit_hostname(hostname: str) -> bool:\n        \"\"\"\n        Check if the provided hostname is a valid AWS CodeCommit hostname.\n\n        This is not an exhaustive check of AWS region names,\n        but instead uses a regex to check for matching AWS region patterns.\n\n        Args:\n        - hostname: the hostname to check\n\n        Returns:\n        - bool: True if the hostname is valid, False otherwise.\n        \"\"\"\n        return re.match(r\"^[a-z]{2}-(gov-)?[a-z]+-\\d\\.console\\.aws\\.amazon\\.com$\", hostname) is not None\n\n    def _get_pr(self):\n        response = self.codecommit_client.get_pr(self.repo_name, self.pr_num)\n\n        if len(response.targets) == 0:\n            raise ValueError(f\"No files found in CodeCommit PR: {self.pr_num}\")\n\n        # TODO: implement support for multiple targets in one CodeCommit PR\n        #       for now, we are only using the first target in the PR\n        if len(response.targets) > 1:\n            get_logger().warning(\n                \"Multiple targets in one PR is not supported for CodeCommit yet. Continuing, using the first target only...\"\n            )\n\n        # Return our object that mimics PullRequest class from the PyGithub library\n        # (This strategy was copied from the LocalGitProvider)\n        mimic = PullRequestCCMimic(response.title, self.diff_files)\n        mimic.description = response.description\n        mimic.source_commit = response.targets[0].source_commit\n        mimic.source_branch = response.targets[0].source_branch\n        mimic.destination_commit = response.targets[0].destination_commit\n        mimic.destination_branch = response.targets[0].destination_branch\n\n        return mimic\n\n    def get_commit_messages(self):\n        return \"\"  # not implemented yet\n\n    @staticmethod\n    def _add_additional_newlines(body: str) -> str:\n        \"\"\"\n        Replace single newlines in a PR body with double newlines.\n\n        CodeCommit Markdown does not seem to render as well as GitHub Markdown,\n        so we add additional newlines to the PR body to make it more readable in CodeCommit.\n\n        Args:\n        - body: the PR body\n\n        Returns:\n        - str: the PR body with the double newlines added\n        \"\"\"\n        return re.sub(r'(?<!\\n)\\n(?!\\n)', '\\n\\n', body)\n\n    @staticmethod\n    def _remove_markdown_html(comment: str) -> str:\n        \"\"\"\n        Remove the HTML tags from a PR comment.\n\n        CodeCommit Markdown does not seem to render as well as GitHub Markdown,\n        so we remove the HTML tags from the PR comment to make it more readable in CodeCommit.\n\n        Args:\n        - comment: the PR comment\n\n        Returns:\n        - str: the PR comment with the HTML tags removed\n        \"\"\"\n        comment = comment.replace(\"<details>\", \"\")\n        comment = comment.replace(\"</details>\", \"\")\n        comment = comment.replace(\"<summary>\", \"\")\n        comment = comment.replace(\"</summary>\", \"\")\n        return comment\n\n    @staticmethod\n    def _get_edit_type(codecommit_change_type: str):\n        \"\"\"\n        Convert the CodeCommit change type string to the EDIT_TYPE enum.\n        The CodeCommit change type string is returned from the get_differences SDK method.\n\n        Args:\n        - codecommit_change_type: the CodeCommit change type string\n\n        Returns:\n        - An EDIT_TYPE enum representing the modified, added, deleted, or renamed file in the PR diff.\n        \"\"\"\n        t = codecommit_change_type.upper()\n        edit_type = None\n        if t == \"A\":\n            edit_type = EDIT_TYPE.ADDED\n        elif t == \"D\":\n            edit_type = EDIT_TYPE.DELETED\n        elif t == \"M\":\n            edit_type = EDIT_TYPE.MODIFIED\n        elif t == \"R\":\n            edit_type = EDIT_TYPE.RENAMED\n        return edit_type\n\n    @staticmethod\n    def _get_file_extensions(filenames):\n        \"\"\"\n        Return a list of file extensions from a list of filenames.\n        The returned extensions will include the dot \".\" prefix,\n        to accommodate for the dots in the existing language_extension_map settings.\n        Filenames with no extension will return an empty string for the extension.\n\n        Args:\n        - filenames: a list of filenames\n\n        Returns:\n        - list: A list of file extensions, including the dot \".\" prefix.\n        \"\"\"\n        extensions = []\n        for filename in filenames:\n            filename, ext = os.path.splitext(filename)\n            if ext:\n                extensions.append(ext.lower())\n            else:\n                extensions.append(\"\")\n        return extensions\n\n    @staticmethod\n    def _get_language_percentages(extensions):\n        \"\"\"\n        Return a dictionary containing the programming language name (as the key),\n        and the percentage that language is used (as the value),\n        given a list of file extensions.\n\n        Args:\n        - extensions: a list of file extensions\n\n        Returns:\n        - dict: A dictionary where each key is a language name and the corresponding value is the percentage of that language in the PR.\n        \"\"\"\n        total_files = len(extensions)\n        if total_files == 0:\n            return {}\n\n        # Identify language by file extension and count\n        lang_count = Counter(extensions)\n        # Convert counts to percentages\n        lang_percentage = {\n            lang: round(count / total_files * 100) for lang, count in lang_count.items()\n        }\n        return lang_percentage",
    "start_line": 53,
    "end_line": 497,
    "has_docstring": true,
    "docstring": "This class implements the GitProvider interface for AWS CodeCommit repositories.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class CodeCommitProvider",
    "component_id": "pr_agent.git_providers.codecommit_provider.CodeCommitProvider"
  },
  "pr_agent.git_providers.gerrit_provider._call": {
    "id": "pr_agent.git_providers.gerrit_provider._call",
    "name": "_call",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.cli.run"
    ],
    "source_code": "def _call(*command, **kwargs) -> (int, str, str):\n    res = subprocess.run(\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        check=True,\n        **kwargs,\n    )\n    return res.stdout.decode()",
    "start_line": 22,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _call",
    "component_id": "pr_agent.git_providers.gerrit_provider._call"
  },
  "pr_agent.git_providers.gerrit_provider.clone": {
    "id": "pr_agent.git_providers.gerrit_provider.clone",
    "name": "clone",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def clone(url, directory):\n    get_logger().info(\"Cloning %s to %s\", url, directory)\n    stdout = _call('git', 'clone', \"--depth\", \"1\", url, directory)\n    get_logger().info(stdout)",
    "start_line": 33,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "directory"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clone",
    "component_id": "pr_agent.git_providers.gerrit_provider.clone"
  },
  "pr_agent.git_providers.gerrit_provider.fetch": {
    "id": "pr_agent.git_providers.gerrit_provider.fetch",
    "name": "fetch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def fetch(url, refspec, cwd):\n    get_logger().info(\"Fetching %s %s\", url, refspec)\n    stdout = _call(\n        'git', 'fetch', '--depth', '2', url, refspec,\n        cwd=cwd\n    )\n    get_logger().info(stdout)",
    "start_line": 39,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "refspec",
      "cwd"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch",
    "component_id": "pr_agent.git_providers.gerrit_provider.fetch"
  },
  "pr_agent.git_providers.gerrit_provider.checkout": {
    "id": "pr_agent.git_providers.gerrit_provider.checkout",
    "name": "checkout",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def checkout(cwd):\n    get_logger().info(\"Checking out\")\n    stdout = _call('git', 'checkout', \"FETCH_HEAD\", cwd=cwd)\n    get_logger().info(stdout)",
    "start_line": 48,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "cwd"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function checkout",
    "component_id": "pr_agent.git_providers.gerrit_provider.checkout"
  },
  "pr_agent.git_providers.gerrit_provider.show": {
    "id": "pr_agent.git_providers.gerrit_provider.show",
    "name": "show",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def show(*args, cwd=None):\n    get_logger().info(\"Show\")\n    return _call('git', 'show', *args, cwd=cwd)",
    "start_line": 54,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show",
    "component_id": "pr_agent.git_providers.gerrit_provider.show"
  },
  "pr_agent.git_providers.gerrit_provider.diff": {
    "id": "pr_agent.git_providers.gerrit_provider.diff",
    "name": "diff",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def diff(*args, cwd=None):\n    get_logger().info(\"Diff\")\n    patch = _call('git', 'diff', *args, cwd=cwd)\n    if not patch:\n        get_logger().warning(\"No changes found\")\n        return\n    return patch",
    "start_line": 59,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function diff",
    "component_id": "pr_agent.git_providers.gerrit_provider.diff"
  },
  "pr_agent.git_providers.gerrit_provider.reset_local_changes": {
    "id": "pr_agent.git_providers.gerrit_provider.reset_local_changes",
    "name": "reset_local_changes",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def reset_local_changes(cwd):\n    get_logger().info(\"Reset local changes\")\n    _call('git', 'checkout', \"--force\", cwd=cwd)",
    "start_line": 68,
    "end_line": 70,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "cwd"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function reset_local_changes",
    "component_id": "pr_agent.git_providers.gerrit_provider.reset_local_changes"
  },
  "pr_agent.git_providers.gerrit_provider.add_comment": {
    "id": "pr_agent.git_providers.gerrit_provider.add_comment",
    "name": "add_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def add_comment(url: urllib3.util.Url, refspec, message):\n    *_, patchset, changenum = refspec.rsplit(\"/\")\n    message = \"'\" + message.replace(\"'\", \"'\\\"'\\\"'\") + \"'\"\n    return _call(\n        \"ssh\",\n        \"-p\", str(url.port),\n        f\"{url.auth}@{url.host}\",\n        \"gerrit\", \"review\",\n        \"--message\", message,\n        # \"--code-review\", score,\n        f\"{patchset},{changenum}\",\n    )",
    "start_line": 73,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "refspec",
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_comment",
    "component_id": "pr_agent.git_providers.gerrit_provider.add_comment"
  },
  "pr_agent.git_providers.gerrit_provider.list_comments": {
    "id": "pr_agent.git_providers.gerrit_provider.list_comments",
    "name": "list_comments",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.git_providers.gerrit_provider._call"
    ],
    "source_code": "def list_comments(url: urllib3.util.Url, refspec):\n    *_, patchset, _ = refspec.rsplit(\"/\")\n    stdout = _call(\n        \"ssh\",\n        \"-p\", str(url.port),\n        f\"{url.auth}@{url.host}\",\n        \"gerrit\", \"query\",\n        \"--comments\",\n        \"--current-patch-set\", patchset,\n        \"--format\", \"JSON\",\n    )\n    change_set, *_ = stdout.splitlines()\n    return json.loads(change_set)[\"currentPatchSet\"][\"comments\"]",
    "start_line": 87,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "refspec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function list_comments",
    "component_id": "pr_agent.git_providers.gerrit_provider.list_comments"
  },
  "pr_agent.git_providers.gerrit_provider.prepare_repo": {
    "id": "pr_agent.git_providers.gerrit_provider.prepare_repo",
    "name": "prepare_repo",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.git_providers.gerrit_provider.clone",
      "pr_agent.git_providers.gerrit_provider.checkout",
      "pr_agent.git_providers.gerrit_provider.fetch"
    ],
    "source_code": "def prepare_repo(url: urllib3.util.Url, project, refspec):\n    repo_url = (f\"{url.scheme}://{url.auth}@{url.host}:{url.port}/{project}\")\n\n    directory = pathlib.Path(mkdtemp())\n    clone(repo_url, directory),\n    fetch(repo_url, refspec, cwd=directory)\n    checkout(cwd=directory)\n    return directory",
    "start_line": 102,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "project",
      "refspec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function prepare_repo",
    "component_id": "pr_agent.git_providers.gerrit_provider.prepare_repo"
  },
  "pr_agent.git_providers.gerrit_provider.adopt_to_gerrit_message": {
    "id": "pr_agent.git_providers.gerrit_provider.adopt_to_gerrit_message",
    "name": "adopt_to_gerrit_message",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [],
    "source_code": "def adopt_to_gerrit_message(message):\n    lines = message.splitlines()\n    buf = []\n    for line in lines:\n        # remove markdown formatting\n        line = (line.replace(\"*\", \"\")\n                .replace(\"``\", \"`\")\n                .replace(\"<details>\", \"\")\n                .replace(\"</details>\", \"\")\n                .replace(\"<summary>\", \"\")\n                .replace(\"</summary>\", \"\"))\n\n        line = line.strip()\n        if line.startswith('#'):\n            buf.append(\"\\n\" +\n                       line.replace('#', '').removesuffix(\":\").strip() +\n                       \":\")\n            continue\n        elif line.startswith('-'):\n            buf.append(line.removeprefix('-').strip())\n            continue\n        else:\n            buf.append(line)\n    return \"\\n\".join(buf).strip()",
    "start_line": 112,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function adopt_to_gerrit_message",
    "component_id": "pr_agent.git_providers.gerrit_provider.adopt_to_gerrit_message"
  },
  "pr_agent.git_providers.gerrit_provider.add_suggestion": {
    "id": "pr_agent.git_providers.gerrit_provider.add_suggestion",
    "name": "add_suggestion",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [],
    "source_code": "def add_suggestion(src_filename, context: str, start, end: int):\n    with (\n        NamedTemporaryFile(\"w\", delete=False) as tmp,\n        open(src_filename, \"r\") as src\n    ):\n        lines = src.readlines()\n        tmp.writelines(lines[:start - 1])\n        if context:\n            tmp.write(context)\n        tmp.writelines(lines[end:])\n\n    shutil.copy(tmp.name, src_filename)\n    os.remove(tmp.name)",
    "start_line": 138,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "src_filename",
      "context",
      "start",
      "end"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_suggestion",
    "component_id": "pr_agent.git_providers.gerrit_provider.add_suggestion"
  },
  "pr_agent.git_providers.gerrit_provider.upload_patch": {
    "id": "pr_agent.git_providers.gerrit_provider.upload_patch",
    "name": "upload_patch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def upload_patch(patch, path):\n    patch_server_endpoint = get_settings().get(\n        'gerrit.patch_server_endpoint')\n    patch_server_token = get_settings().get(\n        'gerrit.patch_server_token')\n\n    response = requests.post(\n        patch_server_endpoint,\n        json={\n            \"content\": patch,\n            \"path\": path,\n        },\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {patch_server_token}\",\n        }\n    )\n    response.raise_for_status()\n    patch_server_endpoint = patch_server_endpoint.rstrip(\"/\")\n    return patch_server_endpoint + \"/\" + path",
    "start_line": 153,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "patch",
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function upload_patch",
    "component_id": "pr_agent.git_providers.gerrit_provider.upload_patch"
  },
  "pr_agent.git_providers.gerrit_provider.GerritProvider": {
    "id": "pr_agent.git_providers.gerrit_provider.GerritProvider",
    "name": "GerritProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gerrit_provider.py",
    "relative_path": "pr_agent/git_providers/gerrit_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.local_git_provider.PullRequestMimic",
      "pr_agent.git_providers.gerrit_provider.adopt_to_gerrit_message",
      "pr_agent.git_providers.gerrit_provider.prepare_repo",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.gerrit_provider.add_comment",
      "pr_agent.git_providers.gerrit_provider.list_comments",
      "pr_agent.git_providers.gerrit_provider.upload_patch",
      "pr_agent.git_providers.gerrit_provider.diff",
      "pr_agent.git_providers.gerrit_provider.reset_local_changes",
      "pr_agent.git_providers.gerrit_provider.add_suggestion"
    ],
    "source_code": "class GerritProvider(GitProvider):\n\n    def __init__(self, key: str, incremental=False):\n        self.project, self.refspec = key.split(':')\n        assert self.project, \"Project name is required\"\n        assert self.refspec, \"Refspec is required\"\n        base_url = get_settings().get('gerrit.url')\n        assert base_url, \"Gerrit URL is required\"\n        user = get_settings().get('gerrit.user')\n        assert user, \"Gerrit user is required\"\n\n        parsed = urllib3.util.parse_url(base_url)\n        self.parsed_url = urllib3.util.parse_url(\n            f\"{parsed.scheme}://{user}@{parsed.host}:{parsed.port}\"\n        )\n\n        self.repo_path = prepare_repo(\n            self.parsed_url, self.project, self.refspec\n        )\n        self.repo = Repo(self.repo_path)\n        assert self.repo\n        self.pr_url = base_url\n        self.pr = PullRequestMimic(self.get_pr_title(), self.get_diff_files())\n\n    def get_pr_title(self):\n        \"\"\"\n        Substitutes the branch-name as the PR-mimic title.\n        \"\"\"\n        return self.repo.branches[0].name\n\n    def get_issue_comments(self):\n        comments = list_comments(self.parsed_url, self.refspec)\n        Comments = namedtuple('Comments', ['reversed'])\n        Comment = namedtuple('Comment', ['body'])\n        return Comments([Comment(c['message']) for c in reversed(comments)])\n\n    def get_pr_labels(self, update=False):\n        raise NotImplementedError(\n            'Getting labels is not implemented for the gerrit provider')\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False):\n        raise NotImplementedError(\n            'Adding reactions is not implemented for the gerrit provider')\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int):\n        raise NotImplementedError(\n            'Removing reactions is not implemented for the gerrit provider')\n\n    def get_commit_messages(self):\n        return [self.repo.head.commit.message]\n\n    def get_repo_settings(self):\n        try:\n            with open(self.repo_path / \".pr_agent.toml\", 'rb') as f:\n                contents = f.read()\n            return contents\n        except OSError:\n            return b\"\"\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        diffs = self.repo.head.commit.diff(\n            self.repo.head.commit.parents[0],  # previous commit\n            create_patch=True,\n            R=True\n        )\n\n        diff_files = []\n        for diff_item in diffs:\n            if diff_item.a_blob is not None:\n                original_file_content_str = (\n                    diff_item.a_blob.data_stream.read().decode('utf-8')\n                )\n            else:\n                original_file_content_str = \"\"  # empty file\n            if diff_item.b_blob is not None:\n                new_file_content_str = diff_item.b_blob.data_stream.read(). \\\n                    decode('utf-8')\n            else:\n                new_file_content_str = \"\"  # empty file\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff_item.new_file:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff_item.deleted_file:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff_item.renamed_file:\n                edit_type = EDIT_TYPE.RENAMED\n            diff_files.append(\n                FilePatchInfo(\n                    original_file_content_str,\n                    new_file_content_str,\n                    diff_item.diff.decode('utf-8'),\n                    diff_item.b_path,\n                    edit_type=edit_type,\n                    old_filename=None\n                    if diff_item.a_path == diff_item.b_path\n                    else diff_item.a_path\n                )\n            )\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self):\n        diff_index = self.repo.head.commit.diff(\n            self.repo.head.commit.parents[0],  # previous commit\n            R=True\n        )\n        # Get the list of changed files\n        diff_files = [item.a_path for item in diff_index]\n        return diff_files\n\n    def get_languages(self):\n        \"\"\"\n        Calculate percentage of languages in repository. Used for hunk\n        prioritisation.\n        \"\"\"\n        # Get all files in repository\n        filepaths = [Path(item.path) for item in\n                     self.repo.tree().traverse() if item.type == 'blob']\n        # Identify language by file extension and count\n        lang_count = Counter(\n            ext.lstrip('.') for filepath in filepaths for ext in\n            [filepath.suffix.lower()])\n        # Convert counts to percentages\n        total_files = len(filepaths)\n        lang_percentage = {lang: count / total_files * 100 for lang, count\n                           in lang_count.items()}\n        return lang_percentage\n\n    def get_pr_description_full(self):\n        return self.repo.head.commit.message\n\n    def get_user_id(self):\n        return self.repo.head.commit.author.email\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in [\n            # 'get_issue_comments',\n            'create_inline_comment',\n            'publish_inline_comments',\n            'get_labels',\n            'gfm_markdown'\n        ]:\n            return False\n        return True\n\n    def split_suggestion(self, msg) -> tuple[str, str]:\n        is_code_context = False\n        description = []\n        context = []\n        for line in msg.splitlines():\n            if line.startswith('```suggestion'):\n                is_code_context = True\n                continue\n            if line.startswith('```'):\n                is_code_context = False\n                continue\n            if is_code_context:\n                context.append(line)\n            else:\n                description.append(\n                    line.replace('*', '')\n                )\n\n        return (\n            '\\n'.join(description),\n            '\\n'.join(context) + '\\n' if context else ''\n        )\n\n    def publish_code_suggestions(self, code_suggestions: list):\n        msg = []\n        for suggestion in code_suggestions:\n            description, code = self.split_suggestion(suggestion['body'])\n            add_suggestion(\n                pathlib.Path(self.repo_path) / suggestion[\"relevant_file\"],\n                code,\n                suggestion[\"relevant_lines_start\"],\n                suggestion[\"relevant_lines_end\"],\n            )\n            patch = diff(cwd=self.repo_path)\n            patch_id = uuid.uuid4().hex[0:4]\n            path = \"/\".join([\"codium-ai\", self.refspec, patch_id])\n            full_path = upload_patch(patch, path)\n            reset_local_changes(self.repo_path)\n            msg.append(f'* {description}\\n{full_path}')\n\n        if msg:\n            add_comment(self.parsed_url, self.refspec, \"\\n\".join(msg))\n            return True\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if not is_temporary:\n            msg = adopt_to_gerrit_message(pr_comment)\n            add_comment(self.parsed_url, self.refspec, msg)\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        msg = adopt_to_gerrit_message(pr_body)\n        add_comment(self.parsed_url, self.refspec, pr_title + '\\n' + msg)\n\n    def publish_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\n            'Publishing inline comments is not implemented for the gerrit '\n            'provider')\n\n    def publish_inline_comment(self, body: str, relevant_file: str,\n                               relevant_line_in_file: str, original_suggestion=None):\n        raise NotImplementedError(\n            'Publishing inline comments is not implemented for the gerrit '\n            'provider')\n\n\n    def publish_labels(self, labels):\n        # Not applicable to the local git provider,\n        # but required by the interface\n        pass\n\n    def remove_initial_comment(self):\n        # remove repo, cloned in previous steps\n        # shutil.rmtree(self.repo_path)\n        pass\n\n    def remove_comment(self, comment):\n        pass\n\n    def get_pr_branch(self):\n        return self.repo.head",
    "start_line": 175,
    "end_line": 399,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class GerritProvider",
    "component_id": "pr_agent.git_providers.gerrit_provider.GerritProvider"
  },
  "pr_agent.git_providers.git_provider.GitProvider": {
    "id": "pr_agent.git_providers.git_provider.GitProvider",
    "name": "GitProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "class GitProvider(ABC):\n    @abstractmethod\n    def is_supported(self, capability: str) -> bool:\n        pass\n\n    #Given a url (issues or PR/MR) - get the .git repo url to which they belong. Needs to be implemented by the provider.\n    def get_git_repo_url(self, issues_or_pr_url: str) -> str:\n        get_logger().warning(\"Not implemented! Returning empty url\")\n        return \"\"\n\n    # Given a git repo url, return prefix and suffix of the provider in order to view a given file belonging to that repo. Needs to be implemented by the provider.\n    # For example: For a git: https://git_provider.com/MY_PROJECT/MY_REPO.git and desired branch: <MY_BRANCH> then it should return ('https://git_provider.com/projects/MY_PROJECT/repos/MY_REPO/.../<MY_BRANCH>', '?=<SOME HEADER>')\n    # so that to properly view the file: docs/readme.md -> <PREFIX>/docs/readme.md<SUFFIX> -> https://git_provider.com/projects/MY_PROJECT/repos/MY_REPO/<MY_BRANCH>/docs/readme.md?=<SOME HEADER>)\n    def get_canonical_url_parts(self, repo_git_url:str, desired_branch:str) -> Tuple[str, str]:\n        get_logger().warning(\"Not implemented! Returning empty prefix and suffix\")\n        return (\"\", \"\")\n\n\n    #Clone related API\n    #An object which ensures deletion of a cloned repo, once it becomes out of scope.\n    # Example usage:\n    #    with TemporaryDirectory() as tmp_dir:\n    #            returned_obj: GitProvider.ScopedClonedRepo = self.git_provider.clone(self.repo_url, tmp_dir, remove_dest_folder=False)\n    #            print(returned_obj.path) #Use returned_obj.path.\n    #    #From this point, returned_obj.path may be deleted at any point and therefore must not be used.\n    class ScopedClonedRepo(object):\n        def __init__(self, dest_folder):\n            self.path = dest_folder\n\n        def __del__(self):\n            if self.path and os.path.exists(self.path):\n                shutil.rmtree(self.path, ignore_errors=True)\n\n    #Method to allow implementors to manipulate the repo url to clone (such as embedding tokens in the url string). Needs to be implemented by the provider.\n    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        get_logger().warning(\"Not implemented! Returning None\")\n        return None\n\n    # Does a shallow clone, using a forked process to support a timeout guard.\n    # In case operation has failed, it is expected to throw an exception as this method does not return a value.\n    def _clone_inner(self, repo_url: str, dest_folder: str, operation_timeout_in_seconds: int=None) -> None:\n        #The following ought to be equivalent to:\n        # #Repo.clone_from(repo_url, dest_folder)\n        # , but with throwing an exception upon timeout.\n        # Note: This can only be used in context that supports using pipes.\n        subprocess.run([\n            \"git\", \"clone\",\n            \"--filter=blob:none\",\n            \"--depth\", \"1\",\n            repo_url, dest_folder\n        ], check=True,  # check=True will raise an exception if the command fails\n            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=operation_timeout_in_seconds)\n\n    CLONE_TIMEOUT_SEC = 20\n    # Clone a given url to a destination folder. If successful, returns an object that wraps the destination folder,\n    # deleting it once it is garbage collected. See: GitProvider.ScopedClonedRepo for more details.\n    def clone(self, repo_url_to_clone: str, dest_folder: str, remove_dest_folder: bool = True,\n              operation_timeout_in_seconds: int=CLONE_TIMEOUT_SEC) -> ScopedClonedRepo|None:\n        returned_obj = None\n        clone_url = self._prepare_clone_url_with_token(repo_url_to_clone)\n        if not clone_url:\n            get_logger().error(\"Clone failed: Unable to obtain url to clone.\")\n            return returned_obj\n        try:\n            if remove_dest_folder and os.path.exists(dest_folder) and os.path.isdir(dest_folder):\n                shutil.rmtree(dest_folder)\n            self._clone_inner(clone_url, dest_folder, operation_timeout_in_seconds)\n            returned_obj = GitProvider.ScopedClonedRepo(dest_folder)\n        except Exception as e:\n            get_logger().exception(f\"Clone failed: Could not clone url.\",\n                artifact={\"error\": str(e), \"url\": clone_url, \"dest_folder\": dest_folder})\n        finally:\n            return returned_obj\n\n    @abstractmethod\n    def get_files(self) -> list:\n        pass\n\n    @abstractmethod\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        pass\n\n    def get_incremental_commits(self, is_incremental):\n        pass\n\n    @abstractmethod\n    def publish_description(self, pr_title: str, pr_body: str):\n        pass\n\n    @abstractmethod\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        pass\n\n    @abstractmethod\n    def get_languages(self):\n        pass\n\n    @abstractmethod\n    def get_pr_branch(self):\n        pass\n\n    @abstractmethod\n    def get_user_id(self):\n        pass\n\n    @abstractmethod\n    def get_pr_description_full(self) -> str:\n        pass\n\n    def edit_comment(self, comment, body: str):\n        pass\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        pass\n\n    def get_comment_body_from_comment_id(self, comment_id: int) -> str:\n        pass\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        pass\n\n    def get_pr_description(self, full: bool = True, split_changes_walkthrough=False) -> str or tuple:\n        from pr_agent.algo.utils import clip_tokens\n        from pr_agent.config_loader import get_settings\n        max_tokens_description = get_settings().get(\"CONFIG.MAX_DESCRIPTION_TOKENS\", None)\n        description = self.get_pr_description_full() if full else self.get_user_description()\n        if split_changes_walkthrough:\n            description, files = process_description(description)\n            if max_tokens_description:\n                description = clip_tokens(description, max_tokens_description)\n            return description, files\n        else:\n            if max_tokens_description:\n                description = clip_tokens(description, max_tokens_description)\n            return description\n\n    def get_user_description(self) -> str:\n        if hasattr(self, 'user_description') and not (self.user_description is None):\n            return self.user_description\n\n        description = (self.get_pr_description_full() or \"\").strip()\n        description_lowercase = description.lower()\n        get_logger().debug(f\"Existing description\", description=description_lowercase)\n\n        # if the existing description wasn't generated by the pr-agent, just return it as-is\n        if not self._is_generated_by_pr_agent(description_lowercase):\n            get_logger().info(f\"Existing description was not generated by the pr-agent\")\n            self.user_description = description\n            return description\n\n        # if the existing description was generated by the pr-agent, but it doesn't contain a user description,\n        # return nothing (empty string) because it means there is no user description\n        user_description_header = \"### **user description**\"\n        if user_description_header not in description_lowercase:\n            get_logger().info(f\"Existing description was generated by the pr-agent, but it doesn't contain a user description\")\n            return \"\"\n\n        # otherwise, extract the original user description from the existing pr-agent description and return it\n        # user_description_start_position = description_lowercase.find(user_description_header) + len(user_description_header)\n        # return description[user_description_start_position:].split(\"\\n\", 1)[-1].strip()\n\n        # the 'user description' is in the beginning. extract and return it\n        possible_headers = self._possible_headers()\n        start_position = description_lowercase.find(user_description_header) + len(user_description_header)\n        end_position = len(description)\n        for header in possible_headers: # try to clip at the next header\n            if header != user_description_header and header in description_lowercase:\n                end_position = min(end_position, description_lowercase.find(header))\n        if end_position != len(description) and end_position > start_position:\n            original_user_description = description[start_position:end_position].strip()\n            if original_user_description.endswith(\"___\"):\n                original_user_description = original_user_description[:-3].strip()\n        else:\n            original_user_description = description.split(\"___\")[0].strip()\n            if original_user_description.lower().startswith(user_description_header):\n                original_user_description = original_user_description[len(user_description_header):].strip()\n\n        get_logger().info(f\"Extracted user description from existing description\",\n                          description=original_user_description)\n        self.user_description = original_user_description\n        return original_user_description\n\n    def _possible_headers(self):\n        return (\"### **user description**\", \"### **pr type**\", \"### **pr description**\", \"### **pr labels**\", \"### **type**\", \"### **description**\",\n                \"### **labels**\", \"###  generated by pr agent\")\n\n    def _is_generated_by_pr_agent(self, description_lowercase: str) -> bool:\n        possible_headers = self._possible_headers()\n        return any(description_lowercase.startswith(header) for header in possible_headers)\n\n    @abstractmethod\n    def get_repo_settings(self):\n        pass\n\n    def get_workspace_name(self):\n        return \"\"\n\n    def get_pr_id(self):\n        return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        return \"\"\n\n    def get_lines_link_original_file(self, filepath:str, component_range: Range) -> str:\n        return \"\"\n\n    #### comments operations ####\n    @abstractmethod\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        pass\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_comment(pr_comment)\n\n    def publish_persistent_comment_full(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        try:\n            prev_comments = list(self.get_issue_comments())\n            for comment in prev_comments:\n                if comment.body.startswith(initial_header):\n                    latest_commit_url = self.get_latest_commit_url()\n                    comment_url = self.get_comment_url(comment)\n                    if update_header:\n                        updated_header = f\"{initial_header}\\n\\n#### ({name.capitalize()} updated until commit {latest_commit_url})\\n\"\n                        pr_comment_updated = pr_comment.replace(initial_header, updated_header)\n                    else:\n                        pr_comment_updated = pr_comment\n                    get_logger().info(f\"Persistent mode - updating comment {comment_url} to latest {name} message\")\n                    # response = self.mr.notes.update(comment.id, {'body': pr_comment_updated})\n                    self.edit_comment(comment, pr_comment_updated)\n                    if final_update_message:\n                        self.publish_comment(\n                            f\"**[Persistent {name}]({comment_url})** updated to latest commit {latest_commit_url}\")\n                    return\n        except Exception as e:\n            get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n            pass\n        self.publish_comment(pr_comment)\n\n\n    @abstractmethod\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        pass\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        raise NotImplementedError(\"This git provider does not support creating inline comments yet\")\n\n    @abstractmethod\n    def publish_inline_comments(self, comments: list[dict]):\n        pass\n\n    @abstractmethod\n    def remove_initial_comment(self):\n        pass\n\n    @abstractmethod\n    def remove_comment(self, comment):\n        pass\n\n    @abstractmethod\n    def get_issue_comments(self):\n        pass\n\n    def get_comment_url(self, comment) -> str:\n        return \"\"\n\n    #### labels operations ####\n    @abstractmethod\n    def publish_labels(self, labels):\n        pass\n\n    @abstractmethod\n    def get_pr_labels(self, update=False):\n        pass\n\n    def get_repo_labels(self):\n        pass\n\n    @abstractmethod\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        pass\n\n    @abstractmethod\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        pass\n\n    #### commits operations ####\n    @abstractmethod\n    def get_commit_messages(self):\n        pass\n\n    def get_pr_url(self) -> str:\n        if hasattr(self, 'pr_url'):\n            return self.pr_url\n        return \"\"\n\n    def get_latest_commit_url(self) -> str:\n        return \"\"\n\n    def auto_approve(self) -> bool:\n        return False\n\n    def calc_pr_statistics(self, pull_request_data: dict):\n        return {}\n\n    def get_num_of_files(self):\n        try:\n            return len(self.get_diff_files())\n        except Exception as e:\n            return -1\n\n    def limit_output_characters(self, output: str, max_chars: int):\n        return output[:max_chars] + '...' if len(output) > max_chars else output",
    "start_line": 15,
    "end_line": 335,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ABC"
    ],
    "class_name": null,
    "display_name": "class GitProvider",
    "component_id": "pr_agent.git_providers.git_provider.GitProvider"
  },
  "pr_agent.git_providers.git_provider.ScopedClonedRepo": {
    "id": "pr_agent.git_providers.git_provider.ScopedClonedRepo",
    "name": "ScopedClonedRepo",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    class ScopedClonedRepo(object):\n        def __init__(self, dest_folder):\n            self.path = dest_folder\n\n        def __del__(self):\n            if self.path and os.path.exists(self.path):\n                shutil.rmtree(self.path, ignore_errors=True)",
    "start_line": 40,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "object"
    ],
    "class_name": null,
    "display_name": "class ScopedClonedRepo",
    "component_id": "pr_agent.git_providers.git_provider.ScopedClonedRepo"
  },
  "pr_agent.git_providers.git_provider._prepare_clone_url_with_token": {
    "id": "pr_agent.git_providers.git_provider._prepare_clone_url_with_token",
    "name": "_prepare_clone_url_with_token",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        get_logger().warning(\"Not implemented! Returning None\")\n        return None",
    "start_line": 49,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "repo_url_to_clone"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _prepare_clone_url_with_token",
    "component_id": "pr_agent.git_providers.git_provider._prepare_clone_url_with_token"
  },
  "pr_agent.git_providers.git_provider._clone_inner": {
    "id": "pr_agent.git_providers.git_provider._clone_inner",
    "name": "_clone_inner",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.cli.run"
    ],
    "source_code": "    def _clone_inner(self, repo_url: str, dest_folder: str, operation_timeout_in_seconds: int=None) -> None:\n        #The following ought to be equivalent to:\n        # #Repo.clone_from(repo_url, dest_folder)\n        # , but with throwing an exception upon timeout.\n        # Note: This can only be used in context that supports using pipes.\n        subprocess.run([\n            \"git\", \"clone\",\n            \"--filter=blob:none\",\n            \"--depth\", \"1\",\n            repo_url, dest_folder\n        ], check=True,  # check=True will raise an exception if the command fails\n            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=operation_timeout_in_seconds)",
    "start_line": 55,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "repo_url",
      "dest_folder",
      "operation_timeout_in_seconds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _clone_inner",
    "component_id": "pr_agent.git_providers.git_provider._clone_inner"
  },
  "pr_agent.git_providers.git_provider.clone": {
    "id": "pr_agent.git_providers.git_provider.clone",
    "name": "clone",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider._clone_inner",
      "pr_agent.git_providers.git_provider._prepare_clone_url_with_token",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.git_provider.ScopedClonedRepo"
    ],
    "source_code": "    def clone(self, repo_url_to_clone: str, dest_folder: str, remove_dest_folder: bool = True,\n              operation_timeout_in_seconds: int=CLONE_TIMEOUT_SEC) -> ScopedClonedRepo|None:\n        returned_obj = None\n        clone_url = self._prepare_clone_url_with_token(repo_url_to_clone)\n        if not clone_url:\n            get_logger().error(\"Clone failed: Unable to obtain url to clone.\")\n            return returned_obj\n        try:\n            if remove_dest_folder and os.path.exists(dest_folder) and os.path.isdir(dest_folder):\n                shutil.rmtree(dest_folder)\n            self._clone_inner(clone_url, dest_folder, operation_timeout_in_seconds)\n            returned_obj = GitProvider.ScopedClonedRepo(dest_folder)\n        except Exception as e:\n            get_logger().exception(f\"Clone failed: Could not clone url.\",\n                artifact={\"error\": str(e), \"url\": clone_url, \"dest_folder\": dest_folder})\n        finally:\n            return returned_obj",
    "start_line": 71,
    "end_line": 87,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "repo_url_to_clone",
      "dest_folder",
      "remove_dest_folder",
      "operation_timeout_in_seconds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clone",
    "component_id": "pr_agent.git_providers.git_provider.clone"
  },
  "pr_agent.git_providers.git_provider.get_files": {
    "id": "pr_agent.git_providers.git_provider.get_files",
    "name": "get_files",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_files(self) -> list:\n        pass",
    "start_line": 90,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_files",
    "component_id": "pr_agent.git_providers.git_provider.get_files"
  },
  "pr_agent.git_providers.git_provider.get_diff_files": {
    "id": "pr_agent.git_providers.git_provider.get_diff_files",
    "name": "get_diff_files",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_diff_files(self) -> list[FilePatchInfo]:\n        pass",
    "start_line": 94,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_diff_files",
    "component_id": "pr_agent.git_providers.git_provider.get_diff_files"
  },
  "pr_agent.git_providers.git_provider.get_incremental_commits": {
    "id": "pr_agent.git_providers.git_provider.get_incremental_commits",
    "name": "get_incremental_commits",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_incremental_commits(self, is_incremental):\n        pass",
    "start_line": 97,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "is_incremental"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_incremental_commits",
    "component_id": "pr_agent.git_providers.git_provider.get_incremental_commits"
  },
  "pr_agent.git_providers.git_provider.publish_description": {
    "id": "pr_agent.git_providers.git_provider.publish_description",
    "name": "publish_description",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def publish_description(self, pr_title: str, pr_body: str):\n        pass",
    "start_line": 101,
    "end_line": 102,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "pr_title",
      "pr_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_description",
    "component_id": "pr_agent.git_providers.git_provider.publish_description"
  },
  "pr_agent.git_providers.git_provider.publish_code_suggestions": {
    "id": "pr_agent.git_providers.git_provider.publish_code_suggestions",
    "name": "publish_code_suggestions",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        pass",
    "start_line": 105,
    "end_line": 106,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "code_suggestions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_code_suggestions",
    "component_id": "pr_agent.git_providers.git_provider.publish_code_suggestions"
  },
  "pr_agent.git_providers.git_provider.get_languages": {
    "id": "pr_agent.git_providers.git_provider.get_languages",
    "name": "get_languages",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_languages(self):\n        pass",
    "start_line": 109,
    "end_line": 110,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_languages",
    "component_id": "pr_agent.git_providers.git_provider.get_languages"
  },
  "pr_agent.git_providers.git_provider.get_pr_branch": {
    "id": "pr_agent.git_providers.git_provider.get_pr_branch",
    "name": "get_pr_branch",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_pr_branch(self):\n        pass",
    "start_line": 113,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_branch",
    "component_id": "pr_agent.git_providers.git_provider.get_pr_branch"
  },
  "pr_agent.git_providers.git_provider.get_user_id": {
    "id": "pr_agent.git_providers.git_provider.get_user_id",
    "name": "get_user_id",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_user_id(self):\n        pass",
    "start_line": 117,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_user_id",
    "component_id": "pr_agent.git_providers.git_provider.get_user_id"
  },
  "pr_agent.git_providers.git_provider.get_pr_description_full": {
    "id": "pr_agent.git_providers.git_provider.get_pr_description_full",
    "name": "get_pr_description_full",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_pr_description_full(self) -> str:\n        pass",
    "start_line": 121,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_description_full",
    "component_id": "pr_agent.git_providers.git_provider.get_pr_description_full"
  },
  "pr_agent.git_providers.git_provider.edit_comment": {
    "id": "pr_agent.git_providers.git_provider.edit_comment",
    "name": "edit_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def edit_comment(self, comment, body: str):\n        pass",
    "start_line": 124,
    "end_line": 125,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comment",
      "body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function edit_comment",
    "component_id": "pr_agent.git_providers.git_provider.edit_comment"
  },
  "pr_agent.git_providers.git_provider.edit_comment_from_comment_id": {
    "id": "pr_agent.git_providers.git_provider.edit_comment_from_comment_id",
    "name": "edit_comment_from_comment_id",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        pass",
    "start_line": 127,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comment_id",
      "body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function edit_comment_from_comment_id",
    "component_id": "pr_agent.git_providers.git_provider.edit_comment_from_comment_id"
  },
  "pr_agent.git_providers.git_provider.get_comment_body_from_comment_id": {
    "id": "pr_agent.git_providers.git_provider.get_comment_body_from_comment_id",
    "name": "get_comment_body_from_comment_id",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_comment_body_from_comment_id(self, comment_id: int) -> str:\n        pass",
    "start_line": 130,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comment_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_comment_body_from_comment_id",
    "component_id": "pr_agent.git_providers.git_provider.get_comment_body_from_comment_id"
  },
  "pr_agent.git_providers.git_provider.reply_to_comment_from_comment_id": {
    "id": "pr_agent.git_providers.git_provider.reply_to_comment_from_comment_id",
    "name": "reply_to_comment_from_comment_id",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        pass",
    "start_line": 133,
    "end_line": 134,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comment_id",
      "body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function reply_to_comment_from_comment_id",
    "component_id": "pr_agent.git_providers.git_provider.reply_to_comment_from_comment_id"
  },
  "pr_agent.git_providers.git_provider.get_pr_description": {
    "id": "pr_agent.git_providers.git_provider.get_pr_description",
    "name": "get_pr_description",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.algo.utils.process_description",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.git_providers.git_provider.get_user_description",
      "pr_agent.git_providers.git_provider.get_pr_description_full"
    ],
    "source_code": "    def get_pr_description(self, full: bool = True, split_changes_walkthrough=False) -> str or tuple:\n        from pr_agent.algo.utils import clip_tokens\n        from pr_agent.config_loader import get_settings\n        max_tokens_description = get_settings().get(\"CONFIG.MAX_DESCRIPTION_TOKENS\", None)\n        description = self.get_pr_description_full() if full else self.get_user_description()\n        if split_changes_walkthrough:\n            description, files = process_description(description)\n            if max_tokens_description:\n                description = clip_tokens(description, max_tokens_description)\n            return description, files\n        else:\n            if max_tokens_description:\n                description = clip_tokens(description, max_tokens_description)\n            return description",
    "start_line": 136,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "full",
      "split_changes_walkthrough"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_description",
    "component_id": "pr_agent.git_providers.git_provider.get_pr_description"
  },
  "pr_agent.git_providers.git_provider.get_user_description": {
    "id": "pr_agent.git_providers.git_provider.get_user_description",
    "name": "get_user_description",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider._possible_headers",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.git_provider._is_generated_by_pr_agent",
      "pr_agent.git_providers.git_provider.get_pr_description_full"
    ],
    "source_code": "    def get_user_description(self) -> str:\n        if hasattr(self, 'user_description') and not (self.user_description is None):\n            return self.user_description\n\n        description = (self.get_pr_description_full() or \"\").strip()\n        description_lowercase = description.lower()\n        get_logger().debug(f\"Existing description\", description=description_lowercase)\n\n        # if the existing description wasn't generated by the pr-agent, just return it as-is\n        if not self._is_generated_by_pr_agent(description_lowercase):\n            get_logger().info(f\"Existing description was not generated by the pr-agent\")\n            self.user_description = description\n            return description\n\n        # if the existing description was generated by the pr-agent, but it doesn't contain a user description,\n        # return nothing (empty string) because it means there is no user description\n        user_description_header = \"### **user description**\"\n        if user_description_header not in description_lowercase:\n            get_logger().info(f\"Existing description was generated by the pr-agent, but it doesn't contain a user description\")\n            return \"\"\n\n        # otherwise, extract the original user description from the existing pr-agent description and return it\n        # user_description_start_position = description_lowercase.find(user_description_header) + len(user_description_header)\n        # return description[user_description_start_position:].split(\"\\n\", 1)[-1].strip()\n\n        # the 'user description' is in the beginning. extract and return it\n        possible_headers = self._possible_headers()\n        start_position = description_lowercase.find(user_description_header) + len(user_description_header)\n        end_position = len(description)\n        for header in possible_headers: # try to clip at the next header\n            if header != user_description_header and header in description_lowercase:\n                end_position = min(end_position, description_lowercase.find(header))\n        if end_position != len(description) and end_position > start_position:\n            original_user_description = description[start_position:end_position].strip()\n            if original_user_description.endswith(\"___\"):\n                original_user_description = original_user_description[:-3].strip()\n        else:\n            original_user_description = description.split(\"___\")[0].strip()\n            if original_user_description.lower().startswith(user_description_header):\n                original_user_description = original_user_description[len(user_description_header):].strip()\n\n        get_logger().info(f\"Extracted user description from existing description\",\n                          description=original_user_description)\n        self.user_description = original_user_description\n        return original_user_description",
    "start_line": 151,
    "end_line": 195,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_user_description",
    "component_id": "pr_agent.git_providers.git_provider.get_user_description"
  },
  "pr_agent.git_providers.git_provider._possible_headers": {
    "id": "pr_agent.git_providers.git_provider._possible_headers",
    "name": "_possible_headers",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def _possible_headers(self):\n        return (\"### **user description**\", \"### **pr type**\", \"### **pr description**\", \"### **pr labels**\", \"### **type**\", \"### **description**\",\n                \"### **labels**\", \"###  generated by pr agent\")",
    "start_line": 197,
    "end_line": 199,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _possible_headers",
    "component_id": "pr_agent.git_providers.git_provider._possible_headers"
  },
  "pr_agent.git_providers.git_provider._is_generated_by_pr_agent": {
    "id": "pr_agent.git_providers.git_provider._is_generated_by_pr_agent",
    "name": "_is_generated_by_pr_agent",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider._possible_headers"
    ],
    "source_code": "    def _is_generated_by_pr_agent(self, description_lowercase: str) -> bool:\n        possible_headers = self._possible_headers()\n        return any(description_lowercase.startswith(header) for header in possible_headers)",
    "start_line": 201,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "description_lowercase"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _is_generated_by_pr_agent",
    "component_id": "pr_agent.git_providers.git_provider._is_generated_by_pr_agent"
  },
  "pr_agent.git_providers.git_provider.get_repo_settings": {
    "id": "pr_agent.git_providers.git_provider.get_repo_settings",
    "name": "get_repo_settings",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_repo_settings(self):\n        pass",
    "start_line": 206,
    "end_line": 207,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_repo_settings",
    "component_id": "pr_agent.git_providers.git_provider.get_repo_settings"
  },
  "pr_agent.git_providers.git_provider.get_workspace_name": {
    "id": "pr_agent.git_providers.git_provider.get_workspace_name",
    "name": "get_workspace_name",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_workspace_name(self):\n        return \"\"",
    "start_line": 209,
    "end_line": 210,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_workspace_name",
    "component_id": "pr_agent.git_providers.git_provider.get_workspace_name"
  },
  "pr_agent.git_providers.git_provider.get_pr_id": {
    "id": "pr_agent.git_providers.git_provider.get_pr_id",
    "name": "get_pr_id",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_pr_id(self):\n        return \"\"",
    "start_line": 212,
    "end_line": 213,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_id",
    "component_id": "pr_agent.git_providers.git_provider.get_pr_id"
  },
  "pr_agent.git_providers.git_provider.get_line_link": {
    "id": "pr_agent.git_providers.git_provider.get_line_link",
    "name": "get_line_link",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        return \"\"",
    "start_line": 215,
    "end_line": 216,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "relevant_file",
      "relevant_line_start",
      "relevant_line_end"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_line_link",
    "component_id": "pr_agent.git_providers.git_provider.get_line_link"
  },
  "pr_agent.git_providers.git_provider.get_lines_link_original_file": {
    "id": "pr_agent.git_providers.git_provider.get_lines_link_original_file",
    "name": "get_lines_link_original_file",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_lines_link_original_file(self, filepath:str, component_range: Range) -> str:\n        return \"\"",
    "start_line": 218,
    "end_line": 219,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "filepath",
      "component_range"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_lines_link_original_file",
    "component_id": "pr_agent.git_providers.git_provider.get_lines_link_original_file"
  },
  "pr_agent.git_providers.git_provider.publish_comment": {
    "id": "pr_agent.git_providers.git_provider.publish_comment",
    "name": "publish_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        pass",
    "start_line": 223,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "pr_comment",
      "is_temporary"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_comment",
    "component_id": "pr_agent.git_providers.git_provider.publish_comment"
  },
  "pr_agent.git_providers.git_provider.publish_persistent_comment": {
    "id": "pr_agent.git_providers.git_provider.publish_persistent_comment",
    "name": "publish_persistent_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.publish_comment"
    ],
    "source_code": "    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_comment(pr_comment)",
    "start_line": 226,
    "end_line": 231,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "pr_comment",
      "initial_header",
      "update_header",
      "name",
      "final_update_message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_persistent_comment",
    "component_id": "pr_agent.git_providers.git_provider.publish_persistent_comment"
  },
  "pr_agent.git_providers.git_provider.publish_persistent_comment_full": {
    "id": "pr_agent.git_providers.git_provider.publish_persistent_comment_full",
    "name": "publish_persistent_comment_full",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_latest_commit_url",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.get_issue_comments",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.git_provider.get_comment_url",
      "pr_agent.git_providers.git_provider.edit_comment"
    ],
    "source_code": "    def publish_persistent_comment_full(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        try:\n            prev_comments = list(self.get_issue_comments())\n            for comment in prev_comments:\n                if comment.body.startswith(initial_header):\n                    latest_commit_url = self.get_latest_commit_url()\n                    comment_url = self.get_comment_url(comment)\n                    if update_header:\n                        updated_header = f\"{initial_header}\\n\\n#### ({name.capitalize()} updated until commit {latest_commit_url})\\n\"\n                        pr_comment_updated = pr_comment.replace(initial_header, updated_header)\n                    else:\n                        pr_comment_updated = pr_comment\n                    get_logger().info(f\"Persistent mode - updating comment {comment_url} to latest {name} message\")\n                    # response = self.mr.notes.update(comment.id, {'body': pr_comment_updated})\n                    self.edit_comment(comment, pr_comment_updated)\n                    if final_update_message:\n                        self.publish_comment(\n                            f\"**[Persistent {name}]({comment_url})** updated to latest commit {latest_commit_url}\")\n                    return\n        except Exception as e:\n            get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n            pass\n        self.publish_comment(pr_comment)",
    "start_line": 233,
    "end_line": 259,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "pr_comment",
      "initial_header",
      "update_header",
      "name",
      "final_update_message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_persistent_comment_full",
    "component_id": "pr_agent.git_providers.git_provider.publish_persistent_comment_full"
  },
  "pr_agent.git_providers.git_provider.publish_inline_comment": {
    "id": "pr_agent.git_providers.git_provider.publish_inline_comment",
    "name": "publish_inline_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        pass",
    "start_line": 263,
    "end_line": 264,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "body",
      "relevant_file",
      "relevant_line_in_file",
      "original_suggestion"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_inline_comment",
    "component_id": "pr_agent.git_providers.git_provider.publish_inline_comment"
  },
  "pr_agent.git_providers.git_provider.create_inline_comment": {
    "id": "pr_agent.git_providers.git_provider.create_inline_comment",
    "name": "create_inline_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        raise NotImplementedError(\"This git provider does not support creating inline comments yet\")",
    "start_line": 266,
    "end_line": 268,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "body",
      "relevant_file",
      "relevant_line_in_file",
      "absolute_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_inline_comment",
    "component_id": "pr_agent.git_providers.git_provider.create_inline_comment"
  },
  "pr_agent.git_providers.git_provider.publish_inline_comments": {
    "id": "pr_agent.git_providers.git_provider.publish_inline_comments",
    "name": "publish_inline_comments",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def publish_inline_comments(self, comments: list[dict]):\n        pass",
    "start_line": 271,
    "end_line": 272,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comments"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_inline_comments",
    "component_id": "pr_agent.git_providers.git_provider.publish_inline_comments"
  },
  "pr_agent.git_providers.git_provider.remove_initial_comment": {
    "id": "pr_agent.git_providers.git_provider.remove_initial_comment",
    "name": "remove_initial_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def remove_initial_comment(self):\n        pass",
    "start_line": 275,
    "end_line": 276,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function remove_initial_comment",
    "component_id": "pr_agent.git_providers.git_provider.remove_initial_comment"
  },
  "pr_agent.git_providers.git_provider.remove_comment": {
    "id": "pr_agent.git_providers.git_provider.remove_comment",
    "name": "remove_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def remove_comment(self, comment):\n        pass",
    "start_line": 279,
    "end_line": 280,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comment"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function remove_comment",
    "component_id": "pr_agent.git_providers.git_provider.remove_comment"
  },
  "pr_agent.git_providers.git_provider.get_issue_comments": {
    "id": "pr_agent.git_providers.git_provider.get_issue_comments",
    "name": "get_issue_comments",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_issue_comments(self):\n        pass",
    "start_line": 283,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_issue_comments",
    "component_id": "pr_agent.git_providers.git_provider.get_issue_comments"
  },
  "pr_agent.git_providers.git_provider.get_comment_url": {
    "id": "pr_agent.git_providers.git_provider.get_comment_url",
    "name": "get_comment_url",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_comment_url(self, comment) -> str:\n        return \"\"",
    "start_line": 286,
    "end_line": 287,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "comment"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_comment_url",
    "component_id": "pr_agent.git_providers.git_provider.get_comment_url"
  },
  "pr_agent.git_providers.git_provider.publish_labels": {
    "id": "pr_agent.git_providers.git_provider.publish_labels",
    "name": "publish_labels",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def publish_labels(self, labels):\n        pass",
    "start_line": 291,
    "end_line": 292,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "labels"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function publish_labels",
    "component_id": "pr_agent.git_providers.git_provider.publish_labels"
  },
  "pr_agent.git_providers.git_provider.get_pr_labels": {
    "id": "pr_agent.git_providers.git_provider.get_pr_labels",
    "name": "get_pr_labels",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_pr_labels(self, update=False):\n        pass",
    "start_line": 295,
    "end_line": 296,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "update"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_labels",
    "component_id": "pr_agent.git_providers.git_provider.get_pr_labels"
  },
  "pr_agent.git_providers.git_provider.get_repo_labels": {
    "id": "pr_agent.git_providers.git_provider.get_repo_labels",
    "name": "get_repo_labels",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_repo_labels(self):\n        pass",
    "start_line": 298,
    "end_line": 299,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_repo_labels",
    "component_id": "pr_agent.git_providers.git_provider.get_repo_labels"
  },
  "pr_agent.git_providers.git_provider.add_eyes_reaction": {
    "id": "pr_agent.git_providers.git_provider.add_eyes_reaction",
    "name": "add_eyes_reaction",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        pass",
    "start_line": 302,
    "end_line": 303,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "issue_comment_id",
      "disable_eyes"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_eyes_reaction",
    "component_id": "pr_agent.git_providers.git_provider.add_eyes_reaction"
  },
  "pr_agent.git_providers.git_provider.remove_reaction": {
    "id": "pr_agent.git_providers.git_provider.remove_reaction",
    "name": "remove_reaction",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        pass",
    "start_line": 306,
    "end_line": 307,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "issue_comment_id",
      "reaction_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function remove_reaction",
    "component_id": "pr_agent.git_providers.git_provider.remove_reaction"
  },
  "pr_agent.git_providers.git_provider.get_commit_messages": {
    "id": "pr_agent.git_providers.git_provider.get_commit_messages",
    "name": "get_commit_messages",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_commit_messages(self):\n        pass",
    "start_line": 311,
    "end_line": 312,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_commit_messages",
    "component_id": "pr_agent.git_providers.git_provider.get_commit_messages"
  },
  "pr_agent.git_providers.git_provider.get_pr_url": {
    "id": "pr_agent.git_providers.git_provider.get_pr_url",
    "name": "get_pr_url",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_pr_url(self) -> str:\n        if hasattr(self, 'pr_url'):\n            return self.pr_url\n        return \"\"",
    "start_line": 314,
    "end_line": 317,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_pr_url",
    "component_id": "pr_agent.git_providers.git_provider.get_pr_url"
  },
  "pr_agent.git_providers.git_provider.get_latest_commit_url": {
    "id": "pr_agent.git_providers.git_provider.get_latest_commit_url",
    "name": "get_latest_commit_url",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def get_latest_commit_url(self) -> str:\n        return \"\"",
    "start_line": 319,
    "end_line": 320,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_latest_commit_url",
    "component_id": "pr_agent.git_providers.git_provider.get_latest_commit_url"
  },
  "pr_agent.git_providers.git_provider.auto_approve": {
    "id": "pr_agent.git_providers.git_provider.auto_approve",
    "name": "auto_approve",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def auto_approve(self) -> bool:\n        return False",
    "start_line": 322,
    "end_line": 323,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function auto_approve",
    "component_id": "pr_agent.git_providers.git_provider.auto_approve"
  },
  "pr_agent.git_providers.git_provider.calc_pr_statistics": {
    "id": "pr_agent.git_providers.git_provider.calc_pr_statistics",
    "name": "calc_pr_statistics",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def calc_pr_statistics(self, pull_request_data: dict):\n        return {}",
    "start_line": 325,
    "end_line": 326,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "pull_request_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calc_pr_statistics",
    "component_id": "pr_agent.git_providers.git_provider.calc_pr_statistics"
  },
  "pr_agent.git_providers.git_provider.get_num_of_files": {
    "id": "pr_agent.git_providers.git_provider.get_num_of_files",
    "name": "get_num_of_files",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files"
    ],
    "source_code": "    def get_num_of_files(self):\n        try:\n            return len(self.get_diff_files())\n        except Exception as e:\n            return -1",
    "start_line": 328,
    "end_line": 332,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_num_of_files",
    "component_id": "pr_agent.git_providers.git_provider.get_num_of_files"
  },
  "pr_agent.git_providers.git_provider.limit_output_characters": {
    "id": "pr_agent.git_providers.git_provider.limit_output_characters",
    "name": "limit_output_characters",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "    def limit_output_characters(self, output: str, max_chars: int):\n        return output[:max_chars] + '...' if len(output) > max_chars else output",
    "start_line": 334,
    "end_line": 335,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "output",
      "max_chars"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function limit_output_characters",
    "component_id": "pr_agent.git_providers.git_provider.limit_output_characters"
  },
  "pr_agent.git_providers.git_provider.get_main_pr_language": {
    "id": "pr_agent.git_providers.git_provider.get_main_pr_language",
    "name": "get_main_pr_language",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_main_pr_language(languages, files) -> str:\n    \"\"\"\n    Get the main language of the commit. Return an empty string if cannot determine.\n    \"\"\"\n    main_language_str = \"\"\n    if not languages:\n        get_logger().info(\"No languages detected\")\n        return main_language_str\n    if not files:\n        get_logger().info(\"No files in diff\")\n        return main_language_str\n\n    try:\n        top_language = max(languages, key=languages.get).lower()\n\n        # validate that the specific commit uses the main language\n        extension_list = []\n        for file in files:\n            if not file:\n                continue\n            if isinstance(file, str):\n                file = FilePatchInfo(base_file=None, head_file=None, patch=None, filename=file)\n            extension_list.append(file.filename.rsplit('.')[-1])\n\n        # get the most common extension\n        most_common_extension = '.' + max(set(extension_list), key=extension_list.count)\n        try:\n            language_extension_map_org = get_settings().language_extension_map_org\n            language_extension_map = {k.lower(): v for k, v in language_extension_map_org.items()}\n\n            if top_language in language_extension_map and most_common_extension in language_extension_map[top_language]:\n                main_language_str = top_language\n            else:\n                for language, extensions in language_extension_map.items():\n                    if most_common_extension in extensions:\n                        main_language_str = language\n                        break\n        except Exception as e:\n            get_logger().exception(f\"Failed to get main language: {e}\")\n            pass\n\n        ## old approach:\n        # most_common_extension = max(set(extension_list), key=extension_list.count)\n        # if most_common_extension == 'py' and top_language == 'python' or \\\n        #         most_common_extension == 'js' and top_language == 'javascript' or \\\n        #         most_common_extension == 'ts' and top_language == 'typescript' or \\\n        #         most_common_extension == 'tsx' and top_language == 'typescript' or \\\n        #         most_common_extension == 'go' and top_language == 'go' or \\\n        #         most_common_extension == 'java' and top_language == 'java' or \\\n        #         most_common_extension == 'c' and top_language == 'c' or \\\n        #         most_common_extension == 'cpp' and top_language == 'c++' or \\\n        #         most_common_extension == 'cs' and top_language == 'c#' or \\\n        #         most_common_extension == 'swift' and top_language == 'swift' or \\\n        #         most_common_extension == 'php' and top_language == 'php' or \\\n        #         most_common_extension == 'rb' and top_language == 'ruby' or \\\n        #         most_common_extension == 'rs' and top_language == 'rust' or \\\n        #         most_common_extension == 'scala' and top_language == 'scala' or \\\n        #         most_common_extension == 'kt' and top_language == 'kotlin' or \\\n        #         most_common_extension == 'pl' and top_language == 'perl' or \\\n        #         most_common_extension == top_language:\n        #     main_language_str = top_language\n\n    except Exception as e:\n        get_logger().exception(e)\n        pass\n\n    return main_language_str",
    "start_line": 338,
    "end_line": 404,
    "has_docstring": true,
    "docstring": "Get the main language of the commit. Return an empty string if cannot determine.",
    "parameters": [
      "languages",
      "files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_main_pr_language",
    "component_id": "pr_agent.git_providers.git_provider.get_main_pr_language"
  },
  "pr_agent.git_providers.git_provider.IncrementalPR": {
    "id": "pr_agent.git_providers.git_provider.IncrementalPR",
    "name": "IncrementalPR",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/git_provider.py",
    "relative_path": "pr_agent/git_providers/git_provider.py",
    "depends_on": [],
    "source_code": "class IncrementalPR:\n    def __init__(self, is_incremental: bool = False):\n        self.is_incremental = is_incremental\n        self.commits_range = None\n        self.first_new_commit = None\n        self.last_seen_commit = None\n\n    @property\n    def first_new_commit_sha(self):\n        return None if self.first_new_commit is None else self.first_new_commit.sha\n\n    @property\n    def last_seen_commit_sha(self):\n        return None if self.last_seen_commit is None else self.last_seen_commit.sha",
    "start_line": 409,
    "end_line": 422,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class IncrementalPR",
    "component_id": "pr_agent.git_providers.git_provider.IncrementalPR"
  },
  "pr_agent.git_providers.github_provider.GithubProvider": {
    "id": "pr_agent.git_providers.github_provider.GithubProvider",
    "name": "GithubProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/github_provider.py",
    "relative_path": "pr_agent/git_providers/github_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.IncrementalPR",
      "pr_agent.git_providers.git_provider.limit_output_characters",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.git_providers.git_provider.create_inline_comment",
      "pr_agent.git_providers.git_provider.publish_persistent_comment_full",
      "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.utils.RateLimitExceeded",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.algo.utils.set_file_languages",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.publish_inline_comments",
      "pr_agent.algo.git_patch_processing.extract_hunk_headers",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_issue_comments",
      "pr_agent.git_providers.git_provider.get_pr_url",
      "pr_agent.algo.utils.load_large_diff",
      "pr_agent.algo.file_filter.filter_ignored",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class GithubProvider(GitProvider):\n    def __init__(self, pr_url: Optional[str] = None):\n        self.repo_obj = None\n        try:\n            self.installation_id = context.get(\"installation_id\", None)\n        except Exception:\n            self.installation_id = None\n        self.max_comment_chars = 65000\n        self.base_url = get_settings().get(\"GITHUB.BASE_URL\", \"https://api.github.com\").rstrip(\"/\") # \"https://api.github.com\"\n        self.base_url_html = self.base_url.split(\"api/\")[0].rstrip(\"/\") if \"api/\" in self.base_url else \"https://github.com\"\n        self.github_client = self._get_github_client()\n        self.repo = None\n        self.pr_num = None\n        self.pr = None\n        self.issue_main = None\n        self.github_user_id = None\n        self.diff_files = None\n        self.git_files = None\n        self.incremental = IncrementalPR(False)\n        if pr_url and 'pull' in pr_url:\n            self.set_pr(pr_url)\n            self.pr_commits = list(self.pr.get_commits())\n            self.last_commit_id = self.pr_commits[-1]\n            self.pr_url = self.get_pr_url() # pr_url for github actions can be as api.github.com, so we need to get the url from the pr object\n        elif pr_url and 'issue' in pr_url: #url is an issue\n            self.issue_main = self._get_issue_handle(pr_url)\n        else: #Instantiated the provider without a PR / Issue\n            self.pr_commits = None\n\n    def _get_issue_handle(self, issue_url) -> Optional[Issue]:\n        repo_name, issue_number = self._parse_issue_url(issue_url)\n        if not repo_name or not issue_number:\n            get_logger().error(f\"Given url: {issue_url} is not a valid issue.\")\n            return None\n        # else: Check if can get a valid Repo handle:\n        try:\n            repo_obj = self.github_client.get_repo(repo_name)\n            if not repo_obj:\n                get_logger().error(f\"Given url: {issue_url}, belonging to owner/repo: {repo_name} does \"\n                                   f\"not have a valid repository: {self.get_git_repo_url(issue_url)}\")\n                return None\n            # else: Valid repo handle:\n            return repo_obj.get_issue(issue_number)\n        except Exception as e:\n            get_logger().exception(f\"Failed to get an issue object for issue: {issue_url}, belonging to owner/repo: {repo_name}\")\n            return None\n\n    def get_incremental_commits(self, incremental=IncrementalPR(False)):\n        self.incremental = incremental\n        if self.incremental.is_incremental:\n            self.unreviewed_files_set = dict()\n            self._get_incremental_commits()\n\n    def is_supported(self, capability: str) -> bool:\n        return True\n\n    def _get_owner_and_repo_path(self, given_url: str) -> str:\n        try:\n            repo_path = None\n            if 'issues' in given_url:\n                repo_path, _ = self._parse_issue_url(given_url)\n            elif 'pull' in given_url:\n                repo_path, _ = self._parse_pr_url(given_url)\n            elif given_url.endswith('.git'):\n                parsed_url = urlparse(given_url)\n                repo_path = (parsed_url.path.split('.git')[0])[1:] # /<owner>/<repo>.git -> <owner>/<repo>\n            if not repo_path:\n                get_logger().error(f\"url is neither an issues url nor a pr url nor a valid git url: {given_url}. Returning empty result.\")\n                return \"\"\n            return repo_path\n        except Exception as e:\n            get_logger().exception(f\"unable to parse url: {given_url}. Returning empty result.\")\n            return \"\"\n\n    def get_git_repo_url(self, issues_or_pr_url: str) -> str:\n        repo_path = self._get_owner_and_repo_path(issues_or_pr_url) #Return: <OWNER>/<REPO>\n        if not repo_path or repo_path not in issues_or_pr_url:\n            get_logger().error(f\"Unable to retrieve owner/path from url: {issues_or_pr_url}\")\n            return \"\"\n        return f\"{self.base_url_html}/{repo_path}.git\" #https://github.com / <OWNER>/<REPO>.git\n\n    # Given a git repo url, return prefix and suffix of the provider in order to view a given file belonging to that repo.\n    # Example: https://github.com/qodo-ai/pr-agent.git and branch: v0.8 -> prefix: \"https://github.com/qodo-ai/pr-agent/blob/v0.8\", suffix: \"\"\n    # In case git url is not provided, provider will use PR context (which includes branch) to determine the prefix and suffix.\n    def get_canonical_url_parts(self, repo_git_url:str, desired_branch:str) -> Tuple[str, str]:\n        owner = None\n        repo = None\n        scheme_and_netloc = None\n\n        if repo_git_url or self.issue_main: #Either user provided an external git url, which may be different than what this provider was initialized with, or an issue:\n            desired_branch = desired_branch if repo_git_url else self.issue_main.repository.default_branch\n            html_url = repo_git_url if repo_git_url else self.issue_main.html_url\n            parsed_git_url = urlparse(html_url)\n            scheme_and_netloc = parsed_git_url.scheme + \"://\" + parsed_git_url.netloc\n            repo_path = self._get_owner_and_repo_path(html_url)\n            if repo_path.count('/') == 1: #Has to have the form <owner>/<repo>\n                owner, repo = repo_path.split('/')\n            else:\n                get_logger().error(f\"Invalid repo_path: {repo_path} from url: {html_url}\")\n                return (\"\", \"\")\n\n        if (not owner or not repo) and self.repo: #\"else\" - User did not provide an external git url, or not an issue, use self.repo object\n            owner, repo = self.repo.split('/')\n            scheme_and_netloc = self.base_url_html\n            desired_branch = self.get_pr_branch()\n        if not all([scheme_and_netloc, owner, repo]): #\"else\": Not invoked from a PR context,but no provided git url for context\n            get_logger().error(f\"Unable to get canonical url parts since missing context (PR or explicit git url)\")\n            return (\"\", \"\")\n\n        prefix = f\"{scheme_and_netloc}/{owner}/{repo}/blob/{desired_branch}\"\n        suffix = \"\"  # github does not add a suffix\n        return (prefix, suffix)\n\n    def get_pr_url(self) -> str:\n        return self.pr.html_url\n\n    def set_pr(self, pr_url: str):\n        self.repo, self.pr_num = self._parse_pr_url(pr_url)\n        self.pr = self._get_pr()\n\n    def _get_incremental_commits(self):\n        if not self.pr_commits:\n            self.pr_commits = list(self.pr.get_commits())\n\n        self.previous_review = self.get_previous_review(full=True, incremental=True)\n        if self.previous_review:\n            self.incremental.commits_range = self.get_commit_range()\n            # Get all files changed during the commit range\n\n            for commit in self.incremental.commits_range:\n                if commit.commit.message.startswith(f\"Merge branch '{self._get_repo().default_branch}'\"):\n                    get_logger().info(f\"Skipping merge commit {commit.commit.message}\")\n                    continue\n                self.unreviewed_files_set.update({file.filename: file for file in commit.files})\n        else:\n            get_logger().info(\"No previous review found, will review the entire PR\")\n            self.incremental.is_incremental = False\n\n    def get_commit_range(self):\n        last_review_time = self.previous_review.created_at\n        first_new_commit_index = None\n        for index in range(len(self.pr_commits) - 1, -1, -1):\n            if self.pr_commits[index].commit.author.date > last_review_time:\n                self.incremental.first_new_commit = self.pr_commits[index]\n                first_new_commit_index = index\n            else:\n                self.incremental.last_seen_commit = self.pr_commits[index]\n                break\n        return self.pr_commits[first_new_commit_index:] if first_new_commit_index is not None else []\n\n    def get_previous_review(self, *, full: bool, incremental: bool):\n        if not (full or incremental):\n            raise ValueError(\"At least one of full or incremental must be True\")\n        if not getattr(self, \"comments\", None):\n            self.comments = list(self.pr.get_issue_comments())\n        prefixes = []\n        if full:\n            prefixes.append(PRReviewHeader.REGULAR.value)\n        if incremental:\n            prefixes.append(PRReviewHeader.INCREMENTAL.value)\n        for index in range(len(self.comments) - 1, -1, -1):\n            if any(self.comments[index].body.startswith(prefix) for prefix in prefixes):\n                return self.comments[index]\n\n    def get_files(self):\n        if self.incremental.is_incremental and self.unreviewed_files_set:\n            return self.unreviewed_files_set.values()\n        try:\n            git_files = context.get(\"git_files\", None)\n            if git_files:\n                return git_files\n            self.git_files = list(self.pr.get_files()) # 'list' to handle pagination\n            context[\"git_files\"] = self.git_files\n            return self.git_files\n        except Exception:\n            if not self.git_files:\n                self.git_files = list(self.pr.get_files())\n            return self.git_files\n\n    def get_num_of_files(self):\n        if hasattr(self.git_files, \"totalCount\"):\n            return self.git_files.totalCount\n        else:\n            try:\n                return len(self.git_files)\n            except Exception as e:\n                return -1\n\n    @retry(exceptions=RateLimitExceeded,\n           tries=get_settings().github.ratelimit_retries, delay=2, backoff=2, jitter=(1, 3))\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in GitHub,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n        try:\n            try:\n                diff_files = context.get(\"diff_files\", None)\n                if diff_files:\n                    return diff_files\n            except Exception:\n                pass\n\n            if self.diff_files:\n                return self.diff_files\n\n            # filter files using [ignore] patterns\n            files_original = self.get_files()\n            files = filter_ignored(files_original)\n            if files_original != files:\n                try:\n                    names_original = [file.filename for file in files_original]\n                    names_new = [file.filename for file in files]\n                    get_logger().info(f\"Filtered out [ignore] files for pull request:\", extra=\n                    {\"files\": names_original,\n                     \"filtered_files\": names_new})\n                except Exception:\n                    pass\n\n            diff_files = []\n            invalid_files_names = []\n            is_close_to_rate_limit = False\n\n            # The base.sha will point to the current state of the base branch (including parallel merges), not the original base commit when the PR was created\n            # We can fix this by finding the merge base commit between the PR head and base branches\n            # Note that The pr.head.sha is actually correct as is - it points to the latest commit in your PR branch.\n            # This SHA isn't affected by parallel merges to the base branch since it's specific to your PR's branch.\n            repo = self.repo_obj\n            pr = self.pr\n            try:\n                compare = repo.compare(pr.base.sha, pr.head.sha) # communication with GitHub\n                merge_base_commit = compare.merge_base_commit\n            except Exception as e:\n                get_logger().error(f\"Failed to get merge base commit: {e}\")\n                merge_base_commit = pr.base\n            if merge_base_commit.sha != pr.base.sha:\n                get_logger().info(\n                    f\"Using merge base commit {merge_base_commit.sha} instead of base commit \")\n\n            counter_valid = 0\n            for file in files:\n                if not is_valid_file(file.filename):\n                    invalid_files_names.append(file.filename)\n                    continue\n\n                patch = file.patch\n                if is_close_to_rate_limit:\n                    new_file_content_str = \"\"\n                    original_file_content_str = \"\"\n                else:\n                    # allow only a limited number of files to be fully loaded. We can manage the rest with diffs only\n                    counter_valid += 1\n                    avoid_load = False\n                    if counter_valid >= MAX_FILES_ALLOWED_FULL and patch and not self.incremental.is_incremental:\n                        avoid_load = True\n                        if counter_valid == MAX_FILES_ALLOWED_FULL:\n                            get_logger().info(f\"Too many files in PR, will avoid loading full content for rest of files\")\n\n                    if avoid_load:\n                        new_file_content_str = \"\"\n                    else:\n                        new_file_content_str = self._get_pr_file_content(file, self.pr.head.sha)  # communication with GitHub\n\n                    if self.incremental.is_incremental and self.unreviewed_files_set:\n                        original_file_content_str = self._get_pr_file_content(file, self.incremental.last_seen_commit_sha)\n                        patch = load_large_diff(file.filename, new_file_content_str, original_file_content_str)\n                        self.unreviewed_files_set[file.filename] = patch\n                    else:\n                        if avoid_load:\n                            original_file_content_str = \"\"\n                        else:\n                            original_file_content_str = self._get_pr_file_content(file, merge_base_commit.sha)\n                            # original_file_content_str = self._get_pr_file_content(file, self.pr.base.sha)\n                        if not patch:\n                            patch = load_large_diff(file.filename, new_file_content_str, original_file_content_str)\n\n\n                if file.status == 'added':\n                    edit_type = EDIT_TYPE.ADDED\n                elif file.status == 'removed':\n                    edit_type = EDIT_TYPE.DELETED\n                elif file.status == 'renamed':\n                    edit_type = EDIT_TYPE.RENAMED\n                elif file.status == 'modified':\n                    edit_type = EDIT_TYPE.MODIFIED\n                else:\n                    get_logger().error(f\"Unknown edit type: {file.status}\")\n                    edit_type = EDIT_TYPE.UNKNOWN\n\n                # count number of lines added and removed\n                if hasattr(file, 'additions') and hasattr(file, 'deletions'):\n                    num_plus_lines = file.additions\n                    num_minus_lines = file.deletions\n                else:\n                    patch_lines = patch.splitlines(keepends=True)\n                    num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n                    num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n\n                file_patch_canonical_structure = FilePatchInfo(original_file_content_str, new_file_content_str, patch,\n                                                               file.filename, edit_type=edit_type,\n                                                               num_plus_lines=num_plus_lines,\n                                                               num_minus_lines=num_minus_lines,)\n                diff_files.append(file_patch_canonical_structure)\n            if invalid_files_names:\n                get_logger().info(f\"Filtered out files with invalid extensions: {invalid_files_names}\")\n\n            self.diff_files = diff_files\n            try:\n                context[\"diff_files\"] = diff_files\n            except Exception:\n                pass\n\n            return diff_files\n\n        except Exception as e:\n            get_logger().error(f\"Failing to get diff files: {e}\",\n                               artifact={\"traceback\": traceback.format_exc()})\n            raise RateLimitExceeded(\"Rate limit exceeded for GitHub API.\") from e\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        self.pr.edit(title=pr_title, body=pr_body)\n\n    def get_latest_commit_url(self) -> str:\n        return self.last_commit_id.html_url\n\n    def get_comment_url(self, comment) -> str:\n        return comment.html_url\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_persistent_comment_full(pr_comment, initial_header, update_header, name, final_update_message)\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        if not self.pr and not self.issue_main:\n            get_logger().error(\"Cannot publish a comment if missing PR/Issue context\")\n            return None\n\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {pr_comment}\")\n            return None\n        pr_comment = self.limit_output_characters(pr_comment, self.max_comment_chars)\n\n        # In case this is an issue, can publish the comment on the issue.\n        if self.issue_main:\n            return self.issue_main.create_comment(pr_comment)\n\n        response = self.pr.create_issue_comment(pr_comment)\n        if hasattr(response, \"user\") and hasattr(response.user, \"login\"):\n            self.github_user_id = response.user.login\n        response.is_temporary = is_temporary\n        if not hasattr(self.pr, 'comments_list'):\n            self.pr.comments_list = []\n        self.pr.comments_list.append(response)\n        return response\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        self.publish_inline_comments([self.create_inline_comment(body, relevant_file, relevant_line_in_file)])\n\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str,\n                              absolute_position: int = None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        position, absolute_position = find_line_number_of_relevant_line_in_file(self.diff_files,\n                                                                                relevant_file.strip('`'),\n                                                                                relevant_line_in_file,\n                                                                                absolute_position)\n        if position == -1:\n            get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n            subject_type = \"FILE\"\n        else:\n            subject_type = \"LINE\"\n        path = relevant_file.strip()\n        return dict(body=body, path=path, position=position) if subject_type == \"LINE\" else {}\n\n    def publish_inline_comments(self, comments: list[dict], disable_fallback: bool = False):\n        try:\n            # publish all comments in a single message\n            self.pr.create_review(commit=self.last_commit_id, comments=comments)\n        except Exception as e:\n            get_logger().info(f\"Initially failed to publish inline comments as committable\")\n\n            if (getattr(e, \"status\", None) == 422 and not disable_fallback):\n                pass  # continue to try _publish_inline_comments_fallback_with_verification\n            else:\n                raise e # will end up with publishing the comments one by one\n\n            try:\n                self._publish_inline_comments_fallback_with_verification(comments)\n            except Exception as e:\n                get_logger().error(f\"Failed to publish inline code comments fallback, error: {e}\")\n                raise e\n\n    def _publish_inline_comments_fallback_with_verification(self, comments: list[dict]):\n        \"\"\"\n        Check each inline comment separately against the GitHub API and discard of invalid comments,\n        then publish all the remaining valid comments in a single review.\n        For invalid comments, also try removing the suggestion part and posting the comment just on the first line.\n        \"\"\"\n        verified_comments, invalid_comments = self._verify_code_comments(comments)\n\n        # publish as a group the verified comments\n        if verified_comments:\n            try:\n                self.pr.create_review(commit=self.last_commit_id, comments=verified_comments)\n            except:\n                pass\n\n        # try to publish one by one the invalid comments as a one-line code comment\n        if invalid_comments and get_settings().github.try_fix_invalid_inline_comments:\n            fixed_comments_as_one_liner = self._try_fix_invalid_inline_comments(\n                [comment for comment, _ in invalid_comments])\n            for comment in fixed_comments_as_one_liner:\n                try:\n                    self.publish_inline_comments([comment], disable_fallback=True)\n                    get_logger().info(f\"Published invalid comment as a single line comment: {comment}\")\n                except:\n                    get_logger().error(f\"Failed to publish invalid comment as a single line comment: {comment}\")\n\n    def _verify_code_comment(self, comment: dict):\n        is_verified = False\n        e = None\n        try:\n            # event =\"\" # By leaving this blank, you set the review action state to PENDING\n            input = dict(commit_id=self.last_commit_id.sha, comments=[comment])\n            headers, data = self.pr._requester.requestJsonAndCheck(\n                \"POST\", f\"{self.pr.url}/reviews\", input=input)\n            pending_review_id = data[\"id\"]\n            is_verified = True\n        except Exception as err:\n            is_verified = False\n            pending_review_id = None\n            e = err\n        if pending_review_id is not None:\n            try:\n                self.pr._requester.requestJsonAndCheck(\"DELETE\", f\"{self.pr.url}/reviews/{pending_review_id}\")\n            except Exception:\n                pass\n        return is_verified, e\n\n    def _verify_code_comments(self, comments: list[dict]) -> tuple[list[dict], list[tuple[dict, Exception]]]:\n        \"\"\"Very each comment against the GitHub API and return 2 lists: 1 of verified and 1 of invalid comments\"\"\"\n        verified_comments = []\n        invalid_comments = []\n        for comment in comments:\n            time.sleep(1)  # for avoiding secondary rate limit\n            is_verified, e = self._verify_code_comment(comment)\n            if is_verified:\n                verified_comments.append(comment)\n            else:\n                invalid_comments.append((comment, e))\n        return verified_comments, invalid_comments\n\n    def _try_fix_invalid_inline_comments(self, invalid_comments: list[dict]) -> list[dict]:\n        \"\"\"\n        Try fixing invalid comments by removing the suggestion part and setting the comment just on the first line.\n        Return only comments that have been modified in some way.\n        This is a best-effort attempt to fix invalid comments, and should be verified accordingly.\n        \"\"\"\n        import copy\n        fixed_comments = []\n        for comment in invalid_comments:\n            try:\n                fixed_comment = copy.deepcopy(comment)  # avoid modifying the original comment dict for later logging\n                if \"```suggestion\" in comment[\"body\"]:\n                    fixed_comment[\"body\"] = comment[\"body\"].split(\"```suggestion\")[0]\n                if \"start_line\" in comment:\n                    fixed_comment[\"line\"] = comment[\"start_line\"]\n                    del fixed_comment[\"start_line\"]\n                if \"start_side\" in comment:\n                    fixed_comment[\"side\"] = comment[\"start_side\"]\n                    del fixed_comment[\"start_side\"]\n                if fixed_comment != comment:\n                    fixed_comments.append(fixed_comment)\n            except Exception as e:\n                get_logger().error(f\"Failed to fix inline comment, error: {e}\")\n        return fixed_comments\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        \"\"\"\n        Publishes code suggestions as comments on the PR.\n        \"\"\"\n        post_parameters_list = []\n\n        code_suggestions_validated = self.validate_comments_inside_hunks(code_suggestions)\n\n        for suggestion in code_suggestions_validated:\n            body = suggestion['body']\n            relevant_file = suggestion['relevant_file']\n            relevant_lines_start = suggestion['relevant_lines_start']\n            relevant_lines_end = suggestion['relevant_lines_end']\n\n            if not relevant_lines_start or relevant_lines_start == -1:\n                get_logger().exception(\n                    f\"Failed to publish code suggestion, relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end < relevant_lines_start:\n                get_logger().exception(f\"Failed to publish code suggestion, \"\n                                  f\"relevant_lines_end is {relevant_lines_end} and \"\n                                  f\"relevant_lines_start is {relevant_lines_start}\")\n                continue\n\n            if relevant_lines_end > relevant_lines_start:\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_end,\n                    \"start_line\": relevant_lines_start,\n                    \"start_side\": \"RIGHT\",\n                }\n            else:  # API is different for single line comments\n                post_parameters = {\n                    \"body\": body,\n                    \"path\": relevant_file,\n                    \"line\": relevant_lines_start,\n                    \"side\": \"RIGHT\",\n                }\n            post_parameters_list.append(post_parameters)\n\n        try:\n            self.publish_inline_comments(post_parameters_list)\n            return True\n        except Exception as e:\n            get_logger().error(f\"Failed to publish code suggestion, error: {e}\")\n            return False\n\n    def edit_comment(self, comment, body: str):\n        try:\n            body = self.limit_output_characters(body, self.max_comment_chars)\n            comment.edit(body=body)\n        except GithubException as e:\n            if hasattr(e, \"status\") and e.status == 403:\n                # Log as warning for permission-related issues (usually due to polling)\n                get_logger().warning(\n                    \"Failed to edit github comment due to permission restrictions\",\n                    artifact={\"error\": e})\n            else:\n                get_logger().exception(f\"Failed to edit github comment\", artifact={\"error\": e})\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        try:\n            # self.pr.get_issue_comment(comment_id).edit(body)\n            body = self.limit_output_characters(body, self.max_comment_chars)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"PATCH\", f\"{self.base_url}/repos/{self.repo}/issues/comments/{comment_id}\",\n                input={\"body\": body}\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to edit comment, error: {e}\")\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        try:\n            # self.pr.get_issue_comment(comment_id).edit(body)\n            body = self.limit_output_characters(body, self.max_comment_chars)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"POST\", f\"{self.base_url}/repos/{self.repo}/pulls/{self.pr_num}/comments/{comment_id}/replies\",\n                input={\"body\": body}\n            )\n        except Exception as e:\n            get_logger().exception(f\"Failed to reply comment, error: {e}\")\n\n    def get_comment_body_from_comment_id(self, comment_id: int):\n        try:\n            # self.pr.get_issue_comment(comment_id).edit(body)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"GET\", f\"{self.base_url}/repos/{self.repo}/issues/comments/{comment_id}\"\n            )\n            return data_patch.get(\"body\",\"\")\n        except Exception as e:\n            get_logger().exception(f\"Failed to edit comment, error: {e}\")\n            return None\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        try:\n            headers, existing_comments = self.pr._requester.requestJsonAndCheck(\n                \"GET\", f\"{self.pr.url}/comments\"\n            )\n            for comment in file_comments:\n                comment['commit_id'] = self.last_commit_id.sha\n                comment['body'] = self.limit_output_characters(comment['body'], self.max_comment_chars)\n\n                found = False\n                for existing_comment in existing_comments:\n                    comment['commit_id'] = self.last_commit_id.sha\n                    our_app_name = get_settings().get(\"GITHUB.APP_NAME\", \"\")\n                    same_comment_creator = False\n                    if self.deployment_type == 'app':\n                        same_comment_creator = our_app_name.lower() in existing_comment['user']['login'].lower()\n                    elif self.deployment_type == 'user':\n                        same_comment_creator = self.github_user_id == existing_comment['user']['login']\n                    if existing_comment['subject_type'] == 'file' and comment['path'] == existing_comment['path'] and same_comment_creator:\n\n                        headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                            \"PATCH\", f\"{self.base_url}/repos/{self.repo}/pulls/comments/{existing_comment['id']}\", input={\"body\":comment['body']}\n                        )\n                        found = True\n                        break\n                if not found:\n                    headers, data_post = self.pr._requester.requestJsonAndCheck(\n                        \"POST\", f\"{self.pr.url}/comments\", input=comment\n                    )\n            return True\n        except Exception as e:\n            get_logger().error(f\"Failed to publish diffview file summary, error: {e}\")\n            return False\n\n    def remove_initial_comment(self):\n        try:\n            for comment in getattr(self.pr, 'comments_list', []):\n                if comment.is_temporary:\n                    self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove initial comment, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            comment.delete()\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def get_title(self):\n        return self.pr.title\n\n    def get_languages(self):\n        languages = self._get_repo().get_languages()\n        return languages\n\n    def get_pr_branch(self):\n        return self.pr.head.ref\n\n    def get_pr_owner_id(self) -> str | None:\n        if not self.repo:\n            return None\n        return self.repo.split('/')[0]\n\n    def get_pr_description_full(self):\n        return self.pr.body\n\n    def get_user_id(self):\n        if not self.github_user_id:\n            try:\n                self.github_user_id = self.github_client.get_user().raw_data['login']\n            except Exception as e:\n                self.github_user_id = \"\"\n                # logging.exception(f\"Failed to get user id, error: {e}\")\n        return self.github_user_id\n\n    def get_notifications(self, since: datetime):\n        deployment_type = get_settings().get(\"GITHUB.DEPLOYMENT_TYPE\", \"user\")\n\n        if deployment_type != 'user':\n            raise ValueError(\"Deployment mode must be set to 'user' to get notifications\")\n\n        notifications = self.github_client.get_user().get_notifications(since=since)\n        return notifications\n\n    def get_issue_comments(self):\n        return self.pr.get_issue_comments()\n\n    def get_repo_settings(self):\n        try:\n            # contents = self.repo_obj.get_contents(\".pr_agent.toml\", ref=self.pr.head.sha).decoded_content\n\n            # more logical to take 'pr_agent.toml' from the default branch\n            contents = self.repo_obj.get_contents(\".pr_agent.toml\").decoded_content\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_workspace_name(self):\n        return self.repo.split('/')[0]\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        if disable_eyes:\n            return None\n        try:\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"POST\", f\"{self.base_url}/repos/{self.repo}/issues/comments/{issue_comment_id}/reactions\",\n                input={\"content\": \"eyes\"}\n            )\n            return data_patch.get(\"id\", None)\n        except Exception as e:\n            get_logger().warning(f\"Failed to add eyes reaction, error: {e}\")\n            return None\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: str) -> bool:\n        try:\n            # self.pr.get_issue_comment(issue_comment_id).delete_reaction(reaction_id)\n            headers, data_patch = self.pr._requester.requestJsonAndCheck(\n                \"DELETE\",\n                f\"{self.base_url}/repos/{self.repo}/issues/comments/{issue_comment_id}/reactions/{reaction_id}\"\n            )\n            return True\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove eyes reaction, error: {e}\")\n            return False\n\n    def _parse_pr_url(self, pr_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(pr_url)\n\n        if parsed_url.path.startswith('/api/v3'):\n            parsed_url = urlparse(pr_url.replace(\"/api/v3\", \"\"))\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'api.github.com' in parsed_url.netloc or '/api/v3' in pr_url:\n            if len(path_parts) < 5 or path_parts[3] != 'pulls':\n                raise ValueError(\"The provided URL does not appear to be a GitHub PR URL\")\n            repo_name = '/'.join(path_parts[1:3])\n            try:\n                pr_number = int(path_parts[4])\n            except ValueError as e:\n                raise ValueError(\"Unable to convert PR number to integer\") from e\n            return repo_name, pr_number\n\n        if len(path_parts) < 4 or path_parts[2] != 'pull':\n            raise ValueError(\"The provided URL does not appear to be a GitHub PR URL\")\n\n        repo_name = '/'.join(path_parts[:2])\n        try:\n            pr_number = int(path_parts[3])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert PR number to integer\") from e\n\n        return repo_name, pr_number\n\n    def _parse_issue_url(self, issue_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(issue_url)\n\n        if parsed_url.path.startswith('/api/v3'): #Check if came from github app\n            parsed_url = urlparse(issue_url.replace(\"/api/v3\", \"\"))\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'api.github.com' in parsed_url.netloc or '/api/v3' in issue_url: #Check if came from github app\n            if len(path_parts) < 5 or path_parts[3] != 'issues':\n                raise ValueError(\"The provided URL does not appear to be a GitHub ISSUE URL\")\n            repo_name = '/'.join(path_parts[1:3])\n            try:\n                issue_number = int(path_parts[4])\n            except ValueError as e:\n                raise ValueError(\"Unable to convert issue number to integer\") from e\n            return repo_name, issue_number\n\n        if len(path_parts) < 4 or path_parts[2] != 'issues':\n            raise ValueError(\"The provided URL does not appear to be a GitHub PR issue\")\n\n        repo_name = '/'.join(path_parts[:2])\n        try:\n            issue_number = int(path_parts[3])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert issue number to integer\") from e\n\n        return repo_name, issue_number\n\n    def _get_github_client(self):\n        self.deployment_type = get_settings().get(\"GITHUB.DEPLOYMENT_TYPE\", \"user\")\n        self.auth = None\n        if self.deployment_type == 'app':\n            try:\n                private_key = get_settings().github.private_key\n                app_id = get_settings().github.app_id\n            except AttributeError as e:\n                raise ValueError(\"GitHub app ID and private key are required when using GitHub app deployment\") from e\n            if not self.installation_id:\n                raise ValueError(\"GitHub app installation ID is required when using GitHub app deployment\")\n            auth = AppAuthentication(app_id=app_id, private_key=private_key,\n                                     installation_id=self.installation_id)\n            self.auth = auth\n        elif self.deployment_type == 'user':\n            try:\n                token = get_settings().github.user_token\n            except AttributeError as e:\n                raise ValueError(\n                    \"GitHub token is required when using user deployment. See: \"\n                    \"https://github.com/Codium-ai/pr-agent#method-2-run-from-source\") from e\n            self.auth = Auth.Token(token)\n        if self.auth:\n            return Github(auth=self.auth, base_url=self.base_url)\n        else:\n            raise ValueError(\"Could not authenticate to GitHub\")\n\n    def _get_repo(self):\n        if hasattr(self, 'repo_obj') and \\\n                hasattr(self.repo_obj, 'full_name') and \\\n                self.repo_obj.full_name == self.repo:\n            return self.repo_obj\n        else:\n            self.repo_obj = self.github_client.get_repo(self.repo)\n            return self.repo_obj\n\n\n    def _get_pr(self):\n        return self._get_repo().get_pull(self.pr_num)\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            file_content_str = str(\n                self._get_repo()\n                .get_contents(file_path, ref=branch)\n                .decoded_content.decode()\n            )\n        except Exception:\n            file_content_str = \"\"\n        return file_content_str\n\n    def create_or_update_pr_file(\n        self, file_path: str, branch: str, contents=\"\", message=\"\"\n    ) -> None:\n        try:\n            file_obj = self._get_repo().get_contents(file_path, ref=branch)\n            sha1=file_obj.sha\n        except Exception:\n            sha1=\"\"\n        self.repo_obj.update_file(\n            path=file_path,\n            message=message,\n            content=contents,\n            sha=sha1,\n            branch=branch,\n        )\n\n    def _get_pr_file_content(self, file: FilePatchInfo, sha: str) -> str:\n        return self.get_pr_file_content(file.filename, sha)\n\n    def publish_labels(self, pr_types):\n        try:\n            label_color_map = {\"Bug fix\": \"1d76db\", \"Tests\": \"e99695\", \"Bug fix with tests\": \"c5def5\",\n                               \"Enhancement\": \"bfd4f2\", \"Documentation\": \"d4c5f9\",\n                               \"Other\": \"d1bcf9\"}\n            post_parameters = []\n            for p in pr_types:\n                color = label_color_map.get(p, \"d1bcf9\")  # default to \"Other\" color\n                post_parameters.append({\"name\": p, \"color\": color})\n            headers, data = self.pr._requester.requestJsonAndCheck(\n                \"PUT\", f\"{self.pr.issue_url}/labels\", input=post_parameters\n            )\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def get_pr_labels(self, update=False):\n        try:\n            if not update:\n                labels =self.pr.labels\n                return [label.name for label in labels]\n            else: # obtain the latest labels. Maybe they changed while the AI was running\n                headers, labels = self.pr._requester.requestJsonAndCheck(\n                    \"GET\", f\"{self.pr.issue_url}/labels\")\n                return [label['name'] for label in labels]\n\n        except Exception as e:\n            get_logger().exception(f\"Failed to get labels, error: {e}\")\n            return []\n\n    def get_repo_labels(self):\n        labels = self.repo_obj.get_labels()\n        return [label for label in itertools.islice(labels, 50)]\n\n    def get_commit_messages(self):\n        \"\"\"\n        Retrieves the commit messages of a pull request.\n\n        Returns:\n            str: A string containing the commit messages of the pull request.\n        \"\"\"\n        max_tokens = get_settings().get(\"CONFIG.MAX_COMMITS_TOKENS\", None)\n        try:\n            commit_list = self.pr.get_commits()\n            commit_messages = [commit.commit.message for commit in commit_list]\n            commit_messages_str = \"\\n\".join([f\"{i + 1}. {message}\" for i, message in enumerate(commit_messages)])\n        except Exception:\n            commit_messages_str = \"\"\n        if max_tokens:\n            commit_messages_str = clip_tokens(commit_messages_str, max_tokens)\n        return commit_messages_str\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").strip('\\n')\n            relevant_line_str = suggestion['relevant_line'].strip('\\n')\n            if not relevant_line_str:\n                return \"\"\n\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (self.diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                # # link to right file only\n                # link = f\"https://github.com/{self.repo}/blob/{self.pr.head.sha}/{relevant_file}\" \\\n                #        + \"#\" + f\"L{absolute_position}\"\n\n                # link to diff\n                sha_file = hashlib.sha256(relevant_file.encode('utf-8')).hexdigest()\n                link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}R{absolute_position}\"\n                return link\n        except Exception as e:\n            get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        sha_file = hashlib.sha256(relevant_file.encode('utf-8')).hexdigest()\n        if relevant_line_start == -1:\n            link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}\"\n        elif relevant_line_end:\n            link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}R{relevant_line_start}-R{relevant_line_end}\"\n        else:\n            link = f\"{self.base_url_html}/{self.repo}/pull/{self.pr_num}/files#diff-{sha_file}R{relevant_line_start}\"\n        return link\n\n    def get_lines_link_original_file(self, filepath: str, component_range: Range) -> str:\n        \"\"\"\n        Returns the link to the original file on GitHub that corresponds to the given filepath and component range.\n\n        Args:\n            filepath (str): The path of the file.\n            component_range (Range): The range of lines that represent the component.\n\n        Returns:\n            str: The link to the original file on GitHub.\n\n        Example:\n            >>> filepath = \"path/to/file.py\"\n            >>> component_range = Range(line_start=10, line_end=20)\n            >>> link = get_lines_link_original_file(filepath, component_range)\n            >>> print(link)\n            \"https://github.com/{repo}/blob/{commit_sha}/{filepath}/#L11-L21\"\n        \"\"\"\n        line_start = component_range.line_start + 1\n        line_end = component_range.line_end + 1\n        # link = (f\"https://github.com/{self.repo}/blob/{self.last_commit_id.sha}/{filepath}/\"\n        #         f\"#L{line_start}-L{line_end}\")\n        link = (f\"{self.base_url_html}/{self.repo}/blob/{self.last_commit_id.sha}/{filepath}/\"\n                f\"#L{line_start}-L{line_end}\")\n\n        return link\n\n    def get_pr_id(self):\n        try:\n            pr_id = f\"{self.repo}/{self.pr_num}\"\n            return pr_id\n        except:\n            return \"\"\n\n    def fetch_sub_issues(self, issue_url):\n        \"\"\"\n        Fetch sub-issues linked to the given GitHub issue URL using GraphQL via PyGitHub.\n        \"\"\"\n        sub_issues = set()\n\n        # Extract owner, repo, and issue number from URL\n        parts = issue_url.rstrip(\"/\").split(\"/\")\n        owner, repo, issue_number = parts[-4], parts[-3], parts[-1]\n\n        try:\n            # Gets Issue ID from Issue Number\n            query = f\"\"\"\n            query {{\n                repository(owner: \"{owner}\", name: \"{repo}\") {{\n                    issue(number: {issue_number}) {{\n                        id\n                    }}\n                }}\n            }}\n            \"\"\"\n            response_tuple = self.github_client._Github__requester.requestJson(\"POST\", \"/graphql\",\n                                                                               input={\"query\": query})\n\n            # Extract the JSON response from the tuple and parses it\n            if isinstance(response_tuple, tuple) and len(response_tuple) == 3:\n                response_json = json.loads(response_tuple[2])\n            else:\n                get_logger().error(f\"Unexpected response format: {response_tuple}\")\n                return sub_issues\n\n\n            issue_id = response_json.get(\"data\", {}).get(\"repository\", {}).get(\"issue\", {}).get(\"id\")\n\n            if not issue_id:\n                get_logger().warning(f\"Issue ID not found for {issue_url}\")\n                return sub_issues\n\n            # Fetch Sub-Issues\n            sub_issues_query = f\"\"\"\n            query {{\n                node(id: \"{issue_id}\") {{\n                    ... on Issue {{\n                        subIssues(first: 10) {{\n                            nodes {{\n                                url\n                            }}\n                        }}\n                    }}\n                }}\n            }}\n            \"\"\"\n            sub_issues_response_tuple = self.github_client._Github__requester.requestJson(\"POST\", \"/graphql\", input={\n                \"query\": sub_issues_query})\n\n            # Extract the JSON response from the tuple and parses it\n            if isinstance(sub_issues_response_tuple, tuple) and len(sub_issues_response_tuple) == 3:\n                sub_issues_response_json = json.loads(sub_issues_response_tuple[2])\n            else:\n                get_logger().error(\"Unexpected sub-issues response format\", artifact={\"response\": sub_issues_response_tuple})\n                return sub_issues\n\n            if not sub_issues_response_json.get(\"data\", {}).get(\"node\", {}).get(\"subIssues\"):\n                get_logger().error(\"Invalid sub-issues response structure\")\n                return sub_issues\n    \n            nodes = sub_issues_response_json.get(\"data\", {}).get(\"node\", {}).get(\"subIssues\", {}).get(\"nodes\", [])\n            get_logger().info(f\"Github Sub-issues fetched: {len(nodes)}\", artifact={\"nodes\": nodes})\n\n            for sub_issue in nodes:\n                if \"url\" in sub_issue:\n                    sub_issues.add(sub_issue[\"url\"])\n\n        except Exception as e:\n            get_logger().exception(f\"Failed to fetch sub-issues. Error: {e}\")\n\n        return sub_issues\n\n    def auto_approve(self) -> bool:\n        try:\n            res = self.pr.create_review(event=\"APPROVE\")\n            if res.state == \"APPROVED\":\n                return True\n            return False\n        except Exception as e:\n            get_logger().exception(f\"Failed to auto-approve, error: {e}\")\n            return False\n\n    def calc_pr_statistics(self, pull_request_data: dict):\n            return {}\n\n    def validate_comments_inside_hunks(self, code_suggestions):\n        \"\"\"\n        validate that all committable comments are inside PR hunks - this is a must for committable comments in GitHub\n        \"\"\"\n        code_suggestions_copy = copy.deepcopy(code_suggestions)\n        diff_files = self.get_diff_files()\n        RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n\n        diff_files = set_file_languages(diff_files)\n\n        for suggestion in code_suggestions_copy:\n            try:\n                relevant_file_path = suggestion['relevant_file']\n                for file in diff_files:\n                    if file.filename == relevant_file_path:\n\n                        # generate on-demand the patches range for the relevant file\n                        patch_str = file.patch\n                        if not hasattr(file, 'patches_range'):\n                            file.patches_range = []\n                            patch_lines = patch_str.splitlines()\n                            for i, line in enumerate(patch_lines):\n                                if line.startswith('@@'):\n                                    match = RE_HUNK_HEADER.match(line)\n                                    # identify hunk header\n                                    if match:\n                                        section_header, size1, size2, start1, start2 = extract_hunk_headers(match)\n                                        file.patches_range.append({'start': start2, 'end': start2 + size2 - 1})\n\n                        patches_range = file.patches_range\n                        comment_start_line = suggestion.get('relevant_lines_start', None)\n                        comment_end_line = suggestion.get('relevant_lines_end', None)\n                        original_suggestion = suggestion.get('original_suggestion', None) # needed for diff code\n                        if not comment_start_line or not comment_end_line or not original_suggestion:\n                            continue\n\n                        # check if the comment is inside a valid hunk\n                        is_valid_hunk = False\n                        min_distance = float('inf')\n                        patch_range_min = None\n                        # find the hunk that contains the comment, or the closest one\n                        for i, patch_range in enumerate(patches_range):\n                            d1 = comment_start_line - patch_range['start']\n                            d2 = patch_range['end'] - comment_end_line\n                            if d1 >= 0 and d2 >= 0:  # found a valid hunk\n                                is_valid_hunk = True\n                                min_distance = 0\n                                patch_range_min = patch_range\n                                break\n                            elif d1 * d2 <= 0:  # comment is possibly inside the hunk\n                                d1_clip = abs(min(0, d1))\n                                d2_clip = abs(min(0, d2))\n                                d = max(d1_clip, d2_clip)\n                                if d < min_distance:\n                                    patch_range_min = patch_range\n                                    min_distance = min(min_distance, d)\n                        if not is_valid_hunk:\n                            if min_distance < 10:  # 10 lines - a reasonable distance to consider the comment inside the hunk\n                                # make the suggestion non-committable, yet multi line\n                                suggestion['relevant_lines_start'] = max(suggestion['relevant_lines_start'], patch_range_min['start'])\n                                suggestion['relevant_lines_end'] = min(suggestion['relevant_lines_end'], patch_range_min['end'])\n                                body = suggestion['body'].strip()\n\n                                # present new diff code in collapsible\n                                existing_code = original_suggestion['existing_code'].rstrip() + \"\\n\"\n                                improved_code = original_suggestion['improved_code'].rstrip() + \"\\n\"\n                                diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                            improved_code.split('\\n'), n=999)\n                                patch_orig = \"\\n\".join(diff)\n                                patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                                diff_code = f\"\\n\\n<details><summary>New proposed code:</summary>\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                                # replace ```suggestion ... ``` with diff_code, using regex:\n                                body = re.sub(r'```suggestion.*?```', diff_code, body, flags=re.DOTALL)\n                                body += \"\\n\\n</details>\"\n                                suggestion['body'] = body\n                                get_logger().info(f\"Comment was moved to a valid hunk, \"\n                                                  f\"start_line={suggestion['relevant_lines_start']}, end_line={suggestion['relevant_lines_end']}, file={file.filename}\")\n                            else:\n                                get_logger().error(f\"Comment is not inside a valid hunk, \"\n                                                   f\"start_line={suggestion['relevant_lines_start']}, end_line={suggestion['relevant_lines_end']}, file={file.filename}\")\n            except Exception as e:\n                get_logger().error(f\"Failed to process patch for committable comment, error: {e}\")\n        return code_suggestions_copy\n\n    #Clone related\n    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        scheme = \"https://\"\n\n        #For example, to clone:\n        #https://github.com/Codium-ai/pr-agent-pro.git\n        #Need to embed inside the github token:\n        #https://<token>@github.com/Codium-ai/pr-agent-pro.git\n\n        github_token = self.auth.token\n        github_base_url = self.base_url_html\n        if not all([github_token, github_base_url]):\n            get_logger().error(\"Either missing auth token or missing base url\")\n            return None\n        if scheme not in github_base_url:\n            get_logger().error(f\"Base url: {github_base_url} is missing prefix: {scheme}\")\n            return None\n        github_com = github_base_url.split(scheme)[1]  # e.g. 'github.com' or github.<org>.com\n        if not github_com:\n            get_logger().error(f\"Base url: {github_base_url} has an empty base url\")\n            return None\n        if github_com not in repo_url_to_clone:\n            get_logger().error(f\"url to clone: {repo_url_to_clone} does not contain {github_com}\")\n            return None\n        repo_full_name = repo_url_to_clone.split(github_com)[-1]\n        if not repo_full_name:\n            get_logger().error(f\"url to clone: {repo_url_to_clone} is malformed\")\n            return None\n\n        clone_url = scheme\n        if self.deployment_type == 'app':\n            clone_url += \"git:\"\n        clone_url += f\"{github_token}@{github_com}{repo_full_name}\"\n        return clone_url",
    "start_line": 32,
    "end_line": 1191,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class GithubProvider",
    "component_id": "pr_agent.git_providers.github_provider.GithubProvider"
  },
  "pr_agent.git_providers.gitlab_provider.DiffNotFoundError": {
    "id": "pr_agent.git_providers.gitlab_provider.DiffNotFoundError",
    "name": "DiffNotFoundError",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gitlab_provider.py",
    "relative_path": "pr_agent/git_providers/gitlab_provider.py",
    "depends_on": [],
    "source_code": "class DiffNotFoundError(Exception):\n    \"\"\"Raised when the diff for a merge request cannot be found.\"\"\"\n    pass",
    "start_line": 23,
    "end_line": 25,
    "has_docstring": true,
    "docstring": "Raised when the diff for a merge request cannot be found.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Exception"
    ],
    "class_name": null,
    "display_name": "class DiffNotFoundError",
    "component_id": "pr_agent.git_providers.gitlab_provider.DiffNotFoundError"
  },
  "pr_agent.git_providers.gitlab_provider.GitLabProvider": {
    "id": "pr_agent.git_providers.gitlab_provider.GitLabProvider",
    "name": "GitLabProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/gitlab_provider.py",
    "relative_path": "pr_agent/git_providers/gitlab_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.limit_output_characters",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.git_providers.git_provider.get_line_link",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.publish_persistent_comment_full",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
      "pr_agent.git_providers.gitlab_provider.DiffNotFoundError",
      "pr_agent.algo.utils.load_large_diff",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.file_filter.filter_ignored",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class GitLabProvider(GitProvider):\n\n    def __init__(self, merge_request_url: Optional[str] = None, incremental: Optional[bool] = False):\n        gitlab_url = get_settings().get(\"GITLAB.URL\", None)\n        if not gitlab_url:\n            raise ValueError(\"GitLab URL is not set in the config file\")\n        self.gitlab_url = gitlab_url\n        gitlab_access_token = get_settings().get(\"GITLAB.PERSONAL_ACCESS_TOKEN\", None)\n        if not gitlab_access_token:\n            raise ValueError(\"GitLab personal access token is not set in the config file\")\n        self.gl = gitlab.Gitlab(\n            url=gitlab_url,\n            oauth_token=gitlab_access_token\n        )\n        self.max_comment_chars = 65000\n        self.id_project = None\n        self.id_mr = None\n        self.mr = None\n        self.diff_files = None\n        self.git_files = None\n        self.temp_comments = []\n        self.pr_url = merge_request_url\n        self._set_merge_request(merge_request_url)\n        self.RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n        self.incremental = incremental\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'create_inline_comment', 'publish_inline_comments',\n            'publish_file_comments']: # gfm_markdown is supported in gitlab !\n            return False\n        return True\n\n    def _get_project_path_from_pr_or_issue_url(self, pr_or_issue_url: str) -> str:\n        repo_project_path = None\n        if 'issues' in pr_or_issue_url:\n            #replace 'issues' with 'merge_requests', since gitlab provider does not support issue urls, just to get the git repo url:\n            pr_or_issue_url = pr_or_issue_url.replace('issues', 'merge_requests')\n        if 'merge_requests' in pr_or_issue_url:\n            repo_project_path, _ = self._parse_merge_request_url(pr_or_issue_url)\n        if not repo_project_path:\n            get_logger().error(f\"url is not a valid merge requests url: {pr_or_issue_url}\")\n            return \"\"\n        return repo_project_path\n\n    def get_git_repo_url(self, issues_or_pr_url: str) -> str:\n        provider_url = issues_or_pr_url\n        repo_path = self._get_project_path_from_pr_or_issue_url(provider_url)\n        if not repo_path or repo_path not in issues_or_pr_url:\n            get_logger().error(f\"Unable to retrieve project path from url: {issues_or_pr_url}\")\n            return \"\"\n        return f\"{issues_or_pr_url.split(repo_path)[0]}{repo_path}.git\"\n\n    # Given a git repo url, return prefix and suffix of the provider in order to view a given file belonging to that repo.\n    # Example: https://gitlab.com/codiumai/pr-agent.git and branch: t1 -> prefix: \"https://gitlab.com/codiumai/pr-agent/-/blob/t1\", suffix: \"?ref_type=heads\"\n    # In case git url is not provided, provider will use PR context (which includes branch) to determine the prefix and suffix.\n    def get_canonical_url_parts(self, repo_git_url:str=None, desired_branch:str=None) -> Tuple[str, str]:\n        repo_path = \"\"\n        if not repo_git_url and not self.pr_url:\n            get_logger().error(\"Cannot get canonical URL parts: missing either context PR URL or a repo GIT URL\")\n            return (\"\", \"\")\n        if not repo_git_url: #Use PR url as context\n            repo_path = self._get_project_path_from_pr_or_issue_url(self.pr_url)\n            desired_branch = self.get_pr_branch()\n        else: #Use repo git url\n            repo_path = repo_git_url.split('.git')[0].split('.com/')[-1]\n        prefix = f\"{self.gitlab_url}/{repo_path}/-/blob/{desired_branch}\"\n        suffix = \"?ref_type=heads\"  # gitlab cloud adds this suffix. gitlab server does not, but it is harmless.\n        return (prefix, suffix)\n\n    @property\n    def pr(self):\n        '''The GitLab terminology is merge request (MR) instead of pull request (PR)'''\n        return self.mr\n\n    def _set_merge_request(self, merge_request_url: str):\n        self.id_project, self.id_mr = self._parse_merge_request_url(merge_request_url)\n        self.mr = self._get_merge_request()\n        try:\n            self.last_diff = self.mr.diffs.list(get_all=True)[-1]\n        except IndexError as e:\n            get_logger().error(f\"Could not get diff for merge request {self.id_mr}\")\n            raise DiffNotFoundError(f\"Could not get diff for merge request {self.id_mr}\") from e\n\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            return self.gl.projects.get(self.id_project).files.get(file_path, branch).decode()\n        except GitlabGetError:\n            # In case of file creation the method returns GitlabGetError (404 file not found).\n            # In this case we return an empty string for the diff.\n            return ''\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in GitLab,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n\n        if self.diff_files:\n            return self.diff_files\n\n        # filter files using [ignore] patterns\n        diffs_original = self.mr.changes()['changes']\n        diffs = filter_ignored(diffs_original, 'gitlab')\n        if diffs != diffs_original:\n            try:\n                names_original = [diff['new_path'] for diff in diffs_original]\n                names_filtered = [diff['new_path'] for diff in diffs]\n                get_logger().info(f\"Filtered out [ignore] files for merge request {self.id_mr}\", extra={\n                    'original_files': names_original,\n                    'filtered_files': names_filtered\n                })\n            except Exception as e:\n                pass\n\n        diff_files = []\n        invalid_files_names = []\n        counter_valid = 0\n        for diff in diffs:\n            if not is_valid_file(diff['new_path']):\n                invalid_files_names.append(diff['new_path'])\n                continue\n\n            # allow only a limited number of files to be fully loaded. We can manage the rest with diffs only\n            counter_valid += 1\n            if counter_valid < MAX_FILES_ALLOWED_FULL or not diff['diff']:\n                original_file_content_str = self.get_pr_file_content(diff['old_path'], self.mr.diff_refs['base_sha'])\n                new_file_content_str = self.get_pr_file_content(diff['new_path'], self.mr.diff_refs['head_sha'])\n            else:\n                if counter_valid == MAX_FILES_ALLOWED_FULL:\n                    get_logger().info(f\"Too many files in PR, will avoid loading full content for rest of files\")\n                original_file_content_str = ''\n                new_file_content_str = ''\n\n            try:\n                if isinstance(original_file_content_str, bytes):\n                    original_file_content_str = bytes.decode(original_file_content_str, 'utf-8')\n                if isinstance(new_file_content_str, bytes):\n                    new_file_content_str = bytes.decode(new_file_content_str, 'utf-8')\n            except UnicodeDecodeError:\n                get_logger().warning(\n                    f\"Cannot decode file {diff['old_path']} or {diff['new_path']} in merge request {self.id_mr}\")\n\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff['new_file']:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff['deleted_file']:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff['renamed_file']:\n                edit_type = EDIT_TYPE.RENAMED\n\n            filename = diff['new_path']\n            patch = diff['diff']\n            if not patch:\n                patch = load_large_diff(filename, new_file_content_str, original_file_content_str)\n\n\n            # count number of lines added and removed\n            patch_lines = patch.splitlines(keepends=True)\n            num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n            num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n            diff_files.append(\n                FilePatchInfo(original_file_content_str, new_file_content_str,\n                              patch=patch,\n                              filename=filename,\n                              edit_type=edit_type,\n                              old_filename=None if diff['old_path'] == diff['new_path'] else diff['old_path'],\n                              num_plus_lines=num_plus_lines,\n                              num_minus_lines=num_minus_lines, ))\n        if invalid_files_names:\n            get_logger().info(f\"Filtered out files with invalid extensions: {invalid_files_names}\")\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self) -> list:\n        if not self.git_files:\n            self.git_files = [change['new_path'] for change in self.mr.changes()['changes']]\n        return self.git_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        try:\n            self.mr.title = pr_title\n            self.mr.description = pr_body\n            self.mr.save()\n        except Exception as e:\n            get_logger().exception(f\"Could not update merge request {self.id_mr} description: {e}\")\n\n    def get_latest_commit_url(self):\n        try:\n            return self.mr.commits().next().web_url\n        except StopIteration: # no commits\n            return \"\"\n        except Exception as e:\n            get_logger().exception(f\"Could not get latest commit URL: {e}\")\n            return \"\"\n\n    def get_comment_url(self, comment):\n        return f\"{self.mr.web_url}#note_{comment.id}\"\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_persistent_comment_full(pr_comment, initial_header, update_header, name, final_update_message)\n\n    def publish_comment(self, mr_comment: str, is_temporary: bool = False):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {mr_comment}\")\n            return None\n        mr_comment = self.limit_output_characters(mr_comment, self.max_comment_chars)\n        comment = self.mr.notes.create({'body': mr_comment})\n        if is_temporary:\n            self.temp_comments.append(comment)\n        return comment\n\n    def edit_comment(self, comment, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        self.mr.notes.update(comment.id,{'body': body} )\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        comment = self.mr.notes.get(comment_id)\n        comment.body = body\n        comment.save()\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        discussion = self.mr.discussions.get(comment_id)\n        discussion.notes.create({'body': body})\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        edit_type, found, source_line_no, target_file, target_line_no = self.search_line(relevant_file,\n                                                                                         relevant_line_in_file)\n        self.send_inline_comment(body, edit_type, found, relevant_file, relevant_line_in_file, source_line_no,\n                                 target_file, target_line_no, original_suggestion)\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, absolute_position: int = None):\n        raise NotImplementedError(\"Gitlab provider does not support creating inline comments yet\")\n\n    def create_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\"Gitlab provider does not support publishing inline comments yet\")\n\n    def get_comment_body_from_comment_id(self, comment_id: int):\n        comment = self.mr.notes.get(comment_id).body\n        return comment\n\n    def send_inline_comment(self, body: str, edit_type: str, found: bool, relevant_file: str,\n                            relevant_line_in_file: str,\n                            source_line_no: int, target_file: str, target_line_no: int,\n                            original_suggestion=None) -> None:\n        if not found:\n            get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n        else:\n            # in order to have exact sha's we have to find correct diff for this change\n            diff = self.get_relevant_diff(relevant_file, relevant_line_in_file)\n            if diff is None:\n                get_logger().error(f\"Could not get diff for merge request {self.id_mr}\")\n                raise DiffNotFoundError(f\"Could not get diff for merge request {self.id_mr}\")\n            pos_obj = {'position_type': 'text',\n                       'new_path': target_file.filename,\n                       'old_path': target_file.old_filename if target_file.old_filename else target_file.filename,\n                       'base_sha': diff.base_commit_sha, 'start_sha': diff.start_commit_sha, 'head_sha': diff.head_commit_sha}\n            if edit_type == 'deletion':\n                pos_obj['old_line'] = source_line_no - 1\n            elif edit_type == 'addition':\n                pos_obj['new_line'] = target_line_no - 1\n            else:\n                pos_obj['new_line'] = target_line_no - 1\n                pos_obj['old_line'] = source_line_no - 1\n            get_logger().debug(f\"Creating comment in MR {self.id_mr} with body {body} and position {pos_obj}\")\n            try:\n                self.mr.discussions.create({'body': body, 'position': pos_obj})\n            except Exception as e:\n                try:\n                    # fallback - create a general note on the file in the MR\n                    if 'suggestion_orig_location' in original_suggestion:\n                        line_start = original_suggestion['suggestion_orig_location']['start_line']\n                        line_end = original_suggestion['suggestion_orig_location']['end_line']\n                        old_code_snippet = original_suggestion['prev_code_snippet']\n                        new_code_snippet = original_suggestion['new_code_snippet']\n                        content = original_suggestion['suggestion_summary']\n                        label = original_suggestion['category']\n                        if 'score' in original_suggestion:\n                            score = original_suggestion['score']\n                        else:\n                            score = 7\n                    else:\n                        line_start = original_suggestion['relevant_lines_start']\n                        line_end = original_suggestion['relevant_lines_end']\n                        old_code_snippet = original_suggestion['existing_code']\n                        new_code_snippet = original_suggestion['improved_code']\n                        content = original_suggestion['suggestion_content']\n                        label = original_suggestion['label']\n                        score = original_suggestion.get('score', 7)\n\n                    if hasattr(self, 'main_language'):\n                        language = self.main_language\n                    else:\n                        language = ''\n                    link = self.get_line_link(relevant_file, line_start, line_end)\n                    body_fallback =f\"**Suggestion:** {content} [{label}, importance: {score}]\\n\\n\"\n                    body_fallback +=f\"\\n\\n<details><summary>[{target_file.filename} [{line_start}-{line_end}]]({link}):</summary>\\n\\n\"\n                    body_fallback += f\"\\n\\n___\\n\\n`(Cannot implement directly - GitLab API allows committable suggestions strictly on MR diff lines)`\"\n                    body_fallback+=\"</details>\\n\\n\"\n                    diff_patch = difflib.unified_diff(old_code_snippet.split('\\n'),\n                                                new_code_snippet.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff_patch)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    body_fallback += diff_code\n\n                    # Create a general note on the file in the MR\n                    self.mr.notes.create({\n                        'body': body_fallback,\n                        'position': {\n                            'base_sha': diff.base_commit_sha,\n                            'start_sha': diff.start_commit_sha,\n                            'head_sha': diff.head_commit_sha,\n                            'position_type': 'text',\n                            'file_path': f'{target_file.filename}',\n                        }\n                    })\n                    get_logger().debug(f\"Created fallback comment in MR {self.id_mr} with position {pos_obj}\")\n\n                    # get_logger().debug(\n                    #     f\"Failed to create comment in MR {self.id_mr} with position {pos_obj} (probably not a '+' line)\")\n                except Exception as e:\n                    get_logger().exception(f\"Failed to create comment in MR {self.id_mr}\")\n\n    def get_relevant_diff(self, relevant_file: str, relevant_line_in_file: str) -> Optional[dict]:\n        changes = self.mr.changes()  # Retrieve the changes for the merge request once\n        if not changes:\n            get_logger().error('No changes found for the merge request.')\n            return None\n        all_diffs = self.mr.diffs.list(get_all=True)\n        if not all_diffs:\n            get_logger().error('No diffs found for the merge request.')\n            return None\n        for diff in all_diffs:\n            for change in changes['changes']:\n                if change['new_path'] == relevant_file and relevant_line_in_file in change['diff']:\n                    return diff\n            get_logger().debug(\n                f'No relevant diff found for {relevant_file} {relevant_line_in_file}. Falling back to last diff.')\n        return self.last_diff  # fallback to last_diff if no relevant diff is found\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        for suggestion in code_suggestions:\n            try:\n                if suggestion and 'original_suggestion' in suggestion:\n                    original_suggestion = suggestion['original_suggestion']\n                else:\n                    original_suggestion = suggestion\n                body = suggestion['body']\n                relevant_file = suggestion['relevant_file']\n                relevant_lines_start = suggestion['relevant_lines_start']\n                relevant_lines_end = suggestion['relevant_lines_end']\n\n                diff_files = self.get_diff_files()\n                target_file = None\n                for file in diff_files:\n                    if file.filename == relevant_file:\n                        if file.filename == relevant_file:\n                            target_file = file\n                            break\n                range = relevant_lines_end - relevant_lines_start # no need to add 1\n                body = body.replace('```suggestion', f'```suggestion:-0+{range}')\n                lines = target_file.head_file.splitlines()\n                relevant_line_in_file = lines[relevant_lines_start - 1]\n\n                # edit_type, found, source_line_no, target_file, target_line_no = self.find_in_file(target_file,\n                #                                                                            relevant_line_in_file)\n                # for code suggestions, we want to edit the new code\n                source_line_no = -1\n                target_line_no = relevant_lines_start + 1\n                found = True\n                edit_type = 'addition'\n\n                self.send_inline_comment(body, edit_type, found, relevant_file, relevant_line_in_file, source_line_no,\n                                         target_file, target_line_no, original_suggestion)\n            except Exception as e:\n                get_logger().exception(f\"Could not publish code suggestion:\\nsuggestion: {suggestion}\\nerror: {e}\")\n\n        # note that we publish suggestions one-by-one. so, if one fails, the rest will still be published\n        return True\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def search_line(self, relevant_file, relevant_line_in_file):\n        target_file = None\n\n        edit_type = self.get_edit_type(relevant_line_in_file)\n        for file in self.get_diff_files():\n            if file.filename == relevant_file:\n                edit_type, found, source_line_no, target_file, target_line_no = self.find_in_file(file,\n                                                                                                  relevant_line_in_file)\n        return edit_type, found, source_line_no, target_file, target_line_no\n\n    def find_in_file(self, file, relevant_line_in_file):\n        edit_type = 'context'\n        source_line_no = 0\n        target_line_no = 0\n        found = False\n        target_file = file\n        patch = file.patch\n        patch_lines = patch.splitlines()\n        for line in patch_lines:\n            if line.startswith('@@'):\n                match = self.RE_HUNK_HEADER.match(line)\n                if not match:\n                    continue\n                start_old, size_old, start_new, size_new, _ = match.groups()\n                source_line_no = int(start_old)\n                target_line_no = int(start_new)\n                continue\n            if line.startswith('-'):\n                source_line_no += 1\n            elif line.startswith('+'):\n                target_line_no += 1\n            elif line.startswith(' '):\n                source_line_no += 1\n                target_line_no += 1\n            if relevant_line_in_file in line:\n                found = True\n                edit_type = self.get_edit_type(line)\n                break\n            elif relevant_line_in_file[0] == '+' and relevant_line_in_file[1:].lstrip() in line:\n                # The model often adds a '+' to the beginning of the relevant_line_in_file even if originally\n                # it's a context line\n                found = True\n                edit_type = self.get_edit_type(line)\n                break\n        return edit_type, found, source_line_no, target_file, target_line_no\n\n    def get_edit_type(self, relevant_line_in_file):\n        edit_type = 'context'\n        if relevant_line_in_file[0] == '-':\n            edit_type = 'deletion'\n        elif relevant_line_in_file[0] == '+':\n            edit_type = 'addition'\n        return edit_type\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            comment.delete()\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def get_title(self):\n        return self.mr.title\n\n    def get_languages(self):\n        languages = self.gl.projects.get(self.id_project).languages()\n        return languages\n\n    def get_pr_branch(self):\n        return self.mr.source_branch\n\n    def get_pr_owner_id(self) -> str | None:\n        if not self.gitlab_url or 'gitlab.com' in self.gitlab_url:\n            if not self.id_project:\n                return None\n            return self.id_project.split('/')[0]\n        # extract host name\n        host = urlparse(self.gitlab_url).hostname\n        return host\n\n    def get_pr_description_full(self):\n        return self.mr.description\n\n    def get_issue_comments(self):\n        return self.mr.notes.list(get_all=True)[::-1]\n\n    def get_repo_settings(self):\n        try:\n            contents = self.gl.projects.get(self.id_project).files.get(file_path='.pr_agent.toml', ref=self.mr.target_branch).decode()\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_workspace_name(self):\n        return self.id_project.split('/')[0]\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    def _parse_merge_request_url(self, merge_request_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(merge_request_url)\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'merge_requests' not in path_parts:\n            raise ValueError(\"The provided URL does not appear to be a GitLab merge request URL\")\n\n        mr_index = path_parts.index('merge_requests')\n        # Ensure there is an ID after 'merge_requests'\n        if len(path_parts) <= mr_index + 1:\n            raise ValueError(\"The provided URL does not contain a merge request ID\")\n\n        try:\n            mr_id = int(path_parts[mr_index + 1])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert merge request ID to integer\") from e\n\n        # Handle special delimiter (-)\n        project_path = \"/\".join(path_parts[:mr_index])\n        if project_path.endswith('/-'):\n            project_path = project_path[:-2]\n\n        # Return the path before 'merge_requests' and the ID\n        return project_path, mr_id\n\n    def _get_merge_request(self):\n        mr = self.gl.projects.get(self.id_project).mergerequests.get(self.id_mr)\n        return mr\n\n    def get_user_id(self):\n        return None\n\n    def publish_labels(self, pr_types):\n        try:\n            self.mr.labels = list(set(pr_types))\n            self.mr.save()\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def publish_inline_comments(self, comments: list[dict]):\n        pass\n\n    def get_pr_labels(self, update=False):\n        return self.mr.labels\n\n    def get_repo_labels(self):\n        return self.gl.projects.get(self.id_project).labels.list()\n\n    def get_commit_messages(self):\n        \"\"\"\n        Retrieves the commit messages of a pull request.\n\n        Returns:\n            str: A string containing the commit messages of the pull request.\n        \"\"\"\n        max_tokens = get_settings().get(\"CONFIG.MAX_COMMITS_TOKENS\", None)\n        try:\n            commit_messages_list = [commit['message'] for commit in self.mr.commits()._list]\n            commit_messages_str = \"\\n\".join([f\"{i + 1}. {message}\" for i, message in enumerate(commit_messages_list)])\n        except Exception:\n            commit_messages_str = \"\"\n        if max_tokens:\n            commit_messages_str = clip_tokens(commit_messages_str, max_tokens)\n        return commit_messages_str\n\n    def get_pr_id(self):\n        try:\n            pr_id = self.mr.web_url\n            return pr_id\n        except:\n            return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads\"\n        elif relevant_line_end:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{relevant_line_start}-{relevant_line_end}\"\n        else:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{relevant_line_start}\"\n        return link\n\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (self.diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                # link to right file only\n                link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{absolute_position}\"\n\n                # # link to diff\n                # sha_file = hashlib.sha1(relevant_file.encode('utf-8')).hexdigest()\n                # link = f\"{self.pr.web_url}/diffs#{sha_file}_{absolute_position}_{absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n    #Clone related\n    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        if \"gitlab.\" not in repo_url_to_clone:\n            get_logger().error(f\"Repo URL: {repo_url_to_clone} is not a valid gitlab URL.\")\n            return None\n        (scheme, base_url) = repo_url_to_clone.split(\"gitlab.\")\n        access_token = self.gl.oauth_token\n        if not all([scheme, access_token, base_url]):\n            get_logger().error(f\"Either no access token found, or repo URL: {repo_url_to_clone} \"\n                               f\"is missing prefix: {scheme} and/or base URL: {base_url}.\")\n            return None\n\n        #Note that the \"\"official\"\" method found here:\n        # https://docs.gitlab.com/user/profile/personal_access_tokens/#clone-repository-using-personal-access-token\n        # requires a username, which may not be applicable.\n        # The following solution is taken from: https://stackoverflow.com/questions/25409700/using-gitlab-token-to-clone-without-authentication/35003812#35003812\n        # For example: For repo url: https://gitlab.codium-inc.com/qodo/autoscraper.git\n        # Then to clone one will issue: 'git clone https://oauth2:<access token>@gitlab.codium-inc.com/qodo/autoscraper.git'\n\n        clone_url = f\"{scheme}oauth2:{access_token}@gitlab.{base_url}\"\n        return clone_url",
    "start_line": 27,
    "end_line": 657,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class GitLabProvider",
    "component_id": "pr_agent.git_providers.gitlab_provider.GitLabProvider"
  },
  "pr_agent.git_providers.local_git_provider.PullRequestMimic": {
    "id": "pr_agent.git_providers.local_git_provider.PullRequestMimic",
    "name": "PullRequestMimic",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/local_git_provider.py",
    "relative_path": "pr_agent/git_providers/local_git_provider.py",
    "depends_on": [],
    "source_code": "class PullRequestMimic:\n    \"\"\"\n    This class mimics the PullRequest class from the PyGithub library for the LocalGitProvider.\n    \"\"\"\n\n    def __init__(self, title: str, diff_files: List[FilePatchInfo]):\n        self.title = title\n        self.diff_files = diff_files",
    "start_line": 13,
    "end_line": 20,
    "has_docstring": true,
    "docstring": "This class mimics the PullRequest class from the PyGithub library for the LocalGitProvider.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PullRequestMimic",
    "component_id": "pr_agent.git_providers.local_git_provider.PullRequestMimic"
  },
  "pr_agent.git_providers.local_git_provider.LocalGitProvider": {
    "id": "pr_agent.git_providers.local_git_provider.LocalGitProvider",
    "name": "LocalGitProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/local_git_provider.py",
    "relative_path": "pr_agent/git_providers/local_git_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.local_git_provider.PullRequestMimic",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.gerrit_provider.diff",
      "pr_agent.config_loader._find_repository_root"
    ],
    "source_code": "class LocalGitProvider(GitProvider):\n    \"\"\"\n    This class implements the GitProvider interface for local git repositories.\n    It mimics the PR functionality of the GitProvider interface,\n    but does not require a hosted git repository.\n    Instead of providing a PR url, the user provides a local branch path to generate a diff-patch.\n    For the MVP it only supports the /review and /describe capabilities.\n    \"\"\"\n\n    def __init__(self, target_branch_name, incremental=False):\n        self.repo_path = _find_repository_root()\n        if self.repo_path is None:\n            raise ValueError('Could not find repository root')\n        self.repo = Repo(self.repo_path)\n        self.head_branch_name = self.repo.head.ref.name\n        self.target_branch_name = target_branch_name\n        self._prepare_repo()\n        self.diff_files = None\n        self.pr = PullRequestMimic(self.get_pr_title(), self.get_diff_files())\n        self.description_path = get_settings().get('local.description_path') \\\n            if get_settings().get('local.description_path') is not None else self.repo_path / 'description.md'\n        self.review_path = get_settings().get('local.review_path') \\\n            if get_settings().get('local.review_path') is not None else self.repo_path / 'review.md'\n        # inline code comments are not supported for local git repositories\n        get_settings().pr_reviewer.inline_code_comments = False\n\n    def _prepare_repo(self):\n        \"\"\"\n        Prepare the repository for PR-mimic generation.\n        \"\"\"\n        get_logger().debug('Preparing repository for PR-mimic generation...')\n        if self.repo.is_dirty():\n            raise ValueError('The repository is not in a clean state. Please commit or stash pending changes.')\n        if self.target_branch_name not in self.repo.heads:\n            raise KeyError(f'Branch: {self.target_branch_name} does not exist')\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'create_inline_comment', 'publish_inline_comments', 'get_labels',\n                          'gfm_markdown']:\n            return False\n        return True\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        diffs = self.repo.head.commit.diff(\n            self.repo.merge_base(self.repo.head, self.repo.branches[self.target_branch_name]),\n            create_patch=True,\n            R=True\n        )\n        diff_files = []\n        for diff_item in diffs:\n            if diff_item.a_blob is not None:\n                original_file_content_str = diff_item.a_blob.data_stream.read().decode('utf-8')\n            else:\n                original_file_content_str = \"\"  # empty file\n            if diff_item.b_blob is not None:\n                new_file_content_str = diff_item.b_blob.data_stream.read().decode('utf-8')\n            else:\n                new_file_content_str = \"\"  # empty file\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff_item.new_file:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff_item.deleted_file:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff_item.renamed_file:\n                edit_type = EDIT_TYPE.RENAMED\n            diff_files.append(\n                FilePatchInfo(original_file_content_str,\n                              new_file_content_str,\n                              diff_item.diff.decode('utf-8'),\n                              diff_item.b_path,\n                              edit_type=edit_type,\n                              old_filename=None if diff_item.a_path == diff_item.b_path else diff_item.a_path\n                              )\n            )\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self) -> List[str]:\n        \"\"\"\n        Returns a list of files with changes in the diff.\n        \"\"\"\n        diff_index = self.repo.head.commit.diff(\n            self.repo.merge_base(self.repo.head, self.repo.branches[self.target_branch_name]),\n            R=True\n        )\n        # Get the list of changed files\n        diff_files = [item.a_path for item in diff_index]\n        return diff_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        with open(self.description_path, \"w\") as file:\n            # Write the string to the file\n            file.write(pr_title + '\\n' + pr_body)\n\n    def publish_comment(self, pr_comment: str, is_temporary: bool = False):\n        with open(self.review_path, \"w\") as file:\n            # Write the string to the file\n            file.write(pr_comment)\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        raise NotImplementedError('Publishing inline comments is not implemented for the local git provider')\n\n    def publish_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError('Publishing inline comments is not implemented for the local git provider')\n\n    def publish_code_suggestion(self, body: str, relevant_file: str,\n                                relevant_lines_start: int, relevant_lines_end: int):\n        raise NotImplementedError('Publishing code suggestions is not implemented for the local git provider')\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        raise NotImplementedError('Publishing code suggestions is not implemented for the local git provider')\n\n    def publish_labels(self, labels):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def remove_initial_comment(self):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def remove_comment(self, comment):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def add_eyes_reaction(self, comment):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def get_commit_messages(self):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def get_repo_settings(self):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def remove_reaction(self, comment):\n        pass  # Not applicable to the local git provider, but required by the interface\n\n    def get_languages(self):\n        \"\"\"\n        Calculate percentage of languages in repository. Used for hunk prioritisation.\n        \"\"\"\n        # Get all files in repository\n        filepaths = [Path(item.path) for item in self.repo.tree().traverse() if item.type == 'blob']\n        # Identify language by file extension and count\n        lang_count = Counter(ext.lstrip('.') for filepath in filepaths for ext in [filepath.suffix.lower()])\n        # Convert counts to percentages\n        total_files = len(filepaths)\n        lang_percentage = {lang: count / total_files * 100 for lang, count in lang_count.items()}\n        return lang_percentage\n\n    def get_pr_branch(self):\n        return self.repo.head\n\n    def get_user_id(self):\n        return -1  # Not used anywhere for the local provider, but required by the interface\n\n    def get_pr_description_full(self):\n        commits_diff = list(self.repo.iter_commits(self.target_branch_name + '..HEAD'))\n        # Get the commit messages and concatenate\n        commit_messages = \" \".join([commit.message for commit in commits_diff])\n        # TODO Handle the description better - maybe use gpt-3.5 summarisation here?\n        return commit_messages[:200]  # Use max 200 characters\n\n    def get_pr_title(self):\n        \"\"\"\n        Substitutes the branch-name as the PR-mimic title.\n        \"\"\"\n        return self.head_branch_name\n\n    def get_issue_comments(self):\n        raise NotImplementedError('Getting issue comments is not implemented for the local git provider')\n\n    def get_pr_labels(self, update=False):\n        raise NotImplementedError('Getting labels is not implemented for the local git provider')",
    "start_line": 23,
    "end_line": 192,
    "has_docstring": true,
    "docstring": "This class implements the GitProvider interface for local git repositories.\nIt mimics the PR functionality of the GitProvider interface,\nbut does not require a hosted git repository.\nInstead of providing a PR url, the user provides a local branch path to generate a diff-patch.\nFor the MVP it only supports the /review and /describe capabilities.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class LocalGitProvider",
    "component_id": "pr_agent.git_providers.local_git_provider.LocalGitProvider"
  },
  "pr_agent.git_providers.utils.apply_repo_settings": {
    "id": "pr_agent.git_providers.utils.apply_repo_settings",
    "name": "apply_repo_settings",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/utils.py",
    "relative_path": "pr_agent/git_providers/utils.py",
    "depends_on": [
      "pr_agent.git_providers.utils.handle_configurations_errors",
      "pr_agent.git_providers.git_provider.get_repo_settings",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.utils.set_claude_model",
      "pr_agent.git_providers.__init__.get_git_provider_with_context"
    ],
    "source_code": "def apply_repo_settings(pr_url):\n    git_provider = get_git_provider_with_context(pr_url)\n    if get_settings().config.use_repo_settings_file:\n        repo_settings_file = None\n        try:\n            try:\n                repo_settings = context.get(\"repo_settings\", None)\n            except Exception:\n                repo_settings = None\n                pass\n            if repo_settings is None:  # None is different from \"\", which is a valid value\n                repo_settings = git_provider.get_repo_settings()\n                try:\n                    context[\"repo_settings\"] = repo_settings\n                except Exception:\n                    pass\n\n            error_local = None\n            if repo_settings:\n                repo_settings_file = None\n                category = 'local'\n                try:\n                    fd, repo_settings_file = tempfile.mkstemp(suffix='.toml')\n                    os.write(fd, repo_settings)\n                    new_settings = Dynaconf(settings_files=[repo_settings_file])\n                    for section, contents in new_settings.as_dict().items():\n                        section_dict = copy.deepcopy(get_settings().as_dict().get(section, {}))\n                        for key, value in contents.items():\n                            section_dict[key] = value\n                        get_settings().unset(section)\n                        get_settings().set(section, section_dict, merge=False)\n                    get_logger().info(f\"Applying repo settings:\\n{new_settings.as_dict()}\")\n                except Exception as e:\n                    get_logger().warning(f\"Failed to apply repo {category} settings, error: {str(e)}\")\n                    error_local = {'error': str(e), 'settings': repo_settings, 'category': category}\n\n                if error_local:\n                    handle_configurations_errors([error_local], git_provider)\n        except Exception as e:\n            get_logger().exception(\"Failed to apply repo settings\", e)\n        finally:\n            if repo_settings_file:\n                try:\n                    os.remove(repo_settings_file)\n                except Exception as e:\n                    get_logger().error(f\"Failed to remove temporary settings file {repo_settings_file}\", e)\n\n    # enable switching models with a short definition\n    if get_settings().config.model.lower() == 'claude-3-5-sonnet':\n        set_claude_model()",
    "start_line": 14,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_url"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function apply_repo_settings",
    "component_id": "pr_agent.git_providers.utils.apply_repo_settings"
  },
  "pr_agent.git_providers.utils.handle_configurations_errors": {
    "id": "pr_agent.git_providers.utils.handle_configurations_errors",
    "name": "handle_configurations_errors",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/utils.py",
    "relative_path": "pr_agent/git_providers/utils.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.publish_persistent_comment",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.git_provider.publish_comment"
    ],
    "source_code": "def handle_configurations_errors(config_errors, git_provider):\n    try:\n        if not any(config_errors):\n            return\n\n        for err in config_errors:\n            if err:\n                configuration_file_content = err['settings'].decode()\n                err_message = err['error']\n                config_type = err['category']\n                header = f\" **PR-Agent failed to apply '{config_type}' repo settings**\"\n                body = f\"{header}\\n\\nThe configuration file needs to be a valid [TOML](https://qodo-merge-docs.qodo.ai/usage-guide/configuration_options/), please fix it.\\n\\n\"\n                body += f\"___\\n\\n**Error message:**\\n`{err_message}`\\n\\n\"\n                if git_provider.is_supported(\"gfm_markdown\"):\n                    body += f\"\\n\\n<details><summary>Configuration content:</summary>\\n\\n```toml\\n{configuration_file_content}\\n```\\n\\n</details>\"\n                else:\n                    body += f\"\\n\\n**Configuration content:**\\n\\n```toml\\n{configuration_file_content}\\n```\\n\\n\"\n                get_logger().warning(f\"Sending a 'configuration error' comment to the PR\", artifact={'body': body})\n                # git_provider.publish_comment(body)\n                if hasattr(git_provider, 'publish_persistent_comment'):\n                    git_provider.publish_persistent_comment(body,\n                                                            initial_header=header,\n                                                            update_header=False,\n                                                            final_update_message=False)\n                else:\n                    git_provider.publish_comment(body)\n    except Exception as e:\n        get_logger().exception(f\"Failed to handle configurations errors\", e)",
    "start_line": 66,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "config_errors",
      "git_provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_configurations_errors",
    "component_id": "pr_agent.git_providers.utils.handle_configurations_errors"
  },
  "pr_agent.git_providers.utils.set_claude_model": {
    "id": "pr_agent.git_providers.utils.set_claude_model",
    "name": "set_claude_model",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/utils.py",
    "relative_path": "pr_agent/git_providers/utils.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def set_claude_model():\n    \"\"\"\n    set the claude-sonnet-3.5 model easily (even by users), just by stating: --config.model='claude-3-5-sonnet'\n    \"\"\"\n    model_claude = \"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"\n    get_settings().set('config.model', model_claude)\n    get_settings().set('config.model_weak', model_claude)\n    get_settings().set('config.fallback_models', [model_claude])",
    "start_line": 96,
    "end_line": 103,
    "has_docstring": true,
    "docstring": "set the claude-sonnet-3.5 model easily (even by users), just by stating: --config.model='claude-3-5-sonnet'",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function set_claude_model",
    "component_id": "pr_agent.git_providers.utils.set_claude_model"
  },
  "pr_agent.git_providers.vnpt_scm_provider.DiffNotFoundError": {
    "id": "pr_agent.git_providers.vnpt_scm_provider.DiffNotFoundError",
    "name": "DiffNotFoundError",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/vnpt_scm_provider.py",
    "relative_path": "pr_agent/git_providers/vnpt_scm_provider.py",
    "depends_on": [],
    "source_code": "class DiffNotFoundError(Exception):\n    \"\"\"Raised when the diff for a merge request cannot be found.\"\"\"\n    pass",
    "start_line": 23,
    "end_line": 25,
    "has_docstring": true,
    "docstring": "Raised when the diff for a merge request cannot be found.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Exception"
    ],
    "class_name": null,
    "display_name": "class DiffNotFoundError",
    "component_id": "pr_agent.git_providers.vnpt_scm_provider.DiffNotFoundError"
  },
  "pr_agent.git_providers.vnpt_scm_provider.VnptScmProvider": {
    "id": "pr_agent.git_providers.vnpt_scm_provider.VnptScmProvider",
    "name": "VnptScmProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/git_providers/vnpt_scm_provider.py",
    "relative_path": "pr_agent/git_providers/vnpt_scm_provider.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.limit_output_characters",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.git_providers.git_provider.get_line_link",
      "pr_agent.algo.types.FilePatchInfo",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.publish_persistent_comment_full",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.algo.utils.find_line_number_of_relevant_line_in_file",
      "pr_agent.algo.utils.load_large_diff",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.file_filter.filter_ignored",
      "pr_agent.git_providers.vnpt_scm_provider.DiffNotFoundError",
      "pr_agent.algo.language_handler.is_valid_file"
    ],
    "source_code": "class VnptScmProvider(GitProvider):\n\n    def __init__(self, merge_request_url: Optional[str] = None, incremental: Optional[bool] = False):\n        gitlab_url = get_settings().get(\"VNPT_SCM.URL\", None)\n        if not gitlab_url:\n            raise ValueError(\"GitLab URL is not set in the config file\")\n        self.gitlab_url = gitlab_url\n        gitlab_access_token = get_settings().get(\"VNPT_SCM.PERSONAL_ACCESS_TOKEN\", None)\n        if not gitlab_access_token:\n            raise ValueError(\"GitLab personal access token is not set in the config file\")\n        self.gl = gitlab.Gitlab(\n            url=gitlab_url,\n            oauth_token=gitlab_access_token\n        )\n        self.max_comment_chars = 65000\n        self.id_project = None\n        self.id_mr = None\n        self.mr = None\n        self.diff_files = None\n        self.git_files = None\n        self.temp_comments = []\n        self.pr_url = merge_request_url\n        self._set_merge_request(merge_request_url)\n        self.RE_HUNK_HEADER = re.compile(\n            r\"^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@[ ]?(.*)\")\n        self.incremental = incremental\n\n    def is_supported(self, capability: str) -> bool:\n        if capability in ['get_issue_comments', 'create_inline_comment', 'publish_inline_comments',\n            'publish_file_comments']: # gfm_markdown is supported in gitlab !\n            return False\n        return True\n\n    def _get_project_path_from_pr_or_issue_url(self, pr_or_issue_url: str) -> str:\n        repo_project_path = None\n        if 'issues' in pr_or_issue_url:\n            #replace 'issues' with 'merge_requests', since gitlab provider does not support issue urls, just to get the git repo url:\n            pr_or_issue_url = pr_or_issue_url.replace('issues', 'merge_requests')\n        if 'merge_requests' in pr_or_issue_url:\n            repo_project_path, _ = self._parse_merge_request_url(pr_or_issue_url)\n        if not repo_project_path:\n            get_logger().error(f\"url is not a valid merge requests url: {pr_or_issue_url}\")\n            return \"\"\n        return repo_project_path\n\n    def get_git_repo_url(self, issues_or_pr_url: str) -> str:\n        provider_url = issues_or_pr_url\n        repo_path = self._get_project_path_from_pr_or_issue_url(provider_url)\n        if not repo_path or repo_path not in issues_or_pr_url:\n            get_logger().error(f\"Unable to retrieve project path from url: {issues_or_pr_url}\")\n            return \"\"\n        return f\"{issues_or_pr_url.split(repo_path)[0]}{repo_path}.git\"\n\n    # Given a git repo url, return prefix and suffix of the provider in order to view a given file belonging to that repo.\n    # Example: https://gitlab.com/codiumai/pr-agent.git and branch: t1 -> prefix: \"https://gitlab.com/codiumai/pr-agent/-/blob/t1\", suffix: \"?ref_type=heads\"\n    # In case git url is not provided, provider will use PR context (which includes branch) to determine the prefix and suffix.\n    def get_canonical_url_parts(self, repo_git_url:str=None, desired_branch:str=None) -> Tuple[str, str]:\n        repo_path = \"\"\n        if not repo_git_url and not self.pr_url:\n            get_logger().error(\"Cannot get canonical URL parts: missing either context PR URL or a repo GIT URL\")\n            return (\"\", \"\")\n        if not repo_git_url: #Use PR url as context\n            repo_path = self._get_project_path_from_pr_or_issue_url(self.pr_url)\n            desired_branch = self.get_pr_branch()\n        else: #Use repo git url\n            repo_path = repo_git_url.split('.git')[0].split('.com/')[-1]\n        prefix = f\"{self.gitlab_url}/{repo_path}/-/blob/{desired_branch}\"\n        suffix = \"?ref_type=heads\"  # gitlab cloud adds this suffix. gitlab server does not, but it is harmless.\n        return (prefix, suffix)\n\n    @property\n    def pr(self):\n        '''The GitLab terminology is merge request (MR) instead of pull request (PR)'''\n        return self.mr\n\n    def _set_merge_request(self, merge_request_url: str):\n        self.id_project, self.id_mr = self._parse_merge_request_url(merge_request_url)\n        self.mr = self._get_merge_request()\n        try:\n            self.last_diff = self.mr.diffs.list(get_all=True)[-1]\n        except IndexError as e:\n            get_logger().error(f\"Could not get diff for merge request {self.id_mr}\")\n            raise DiffNotFoundError(f\"Could not get diff for merge request {self.id_mr}\") from e\n\n\n    def get_pr_file_content(self, file_path: str, branch: str) -> str:\n        try:\n            return self.gl.projects.get(self.id_project).files.get(file_path, branch).decode()\n        except GitlabGetError:\n            # In case of file creation the method returns GitlabGetError (404 file not found).\n            # In this case we return an empty string for the diff.\n            return ''\n\n    def get_diff_files(self) -> list[FilePatchInfo]:\n        \"\"\"\n        Retrieves the list of files that have been modified, added, deleted, or renamed in a pull request in GitLab,\n        along with their content and patch information.\n\n        Returns:\n            diff_files (List[FilePatchInfo]): List of FilePatchInfo objects representing the modified, added, deleted,\n            or renamed files in the merge request.\n        \"\"\"\n\n        if self.diff_files:\n            return self.diff_files\n\n        # filter files using [ignore] patterns\n        diffs_original = self.mr.changes()['changes']\n        diffs = filter_ignored(diffs_original, 'gitlab')\n        if diffs != diffs_original:\n            try:\n                names_original = [diff['new_path'] for diff in diffs_original]\n                names_filtered = [diff['new_path'] for diff in diffs]\n                get_logger().info(f\"Filtered out [ignore] files for merge request {self.id_mr}\", extra={\n                    'original_files': names_original,\n                    'filtered_files': names_filtered\n                })\n            except Exception as e:\n                pass\n\n        diff_files = []\n        invalid_files_names = []\n        counter_valid = 0\n        for diff in diffs:\n            if not is_valid_file(diff['new_path']):\n                invalid_files_names.append(diff['new_path'])\n                continue\n\n            # allow only a limited number of files to be fully loaded. We can manage the rest with diffs only\n            counter_valid += 1\n            if counter_valid < MAX_FILES_ALLOWED_FULL or not diff['diff']:\n                original_file_content_str = self.get_pr_file_content(diff['old_path'], self.mr.diff_refs['base_sha'])\n                new_file_content_str = self.get_pr_file_content(diff['new_path'], self.mr.diff_refs['head_sha'])\n            else:\n                if counter_valid == MAX_FILES_ALLOWED_FULL:\n                    get_logger().info(f\"Too many files in PR, will avoid loading full content for rest of files\")\n                original_file_content_str = ''\n                new_file_content_str = ''\n\n            try:\n                if isinstance(original_file_content_str, bytes):\n                    original_file_content_str = bytes.decode(original_file_content_str, 'utf-8')\n                if isinstance(new_file_content_str, bytes):\n                    new_file_content_str = bytes.decode(new_file_content_str, 'utf-8')\n            except UnicodeDecodeError:\n                get_logger().warning(\n                    f\"Cannot decode file {diff['old_path']} or {diff['new_path']} in merge request {self.id_mr}\")\n\n            edit_type = EDIT_TYPE.MODIFIED\n            if diff['new_file']:\n                edit_type = EDIT_TYPE.ADDED\n            elif diff['deleted_file']:\n                edit_type = EDIT_TYPE.DELETED\n            elif diff['renamed_file']:\n                edit_type = EDIT_TYPE.RENAMED\n\n            filename = diff['new_path']\n            patch = diff['diff']\n            if not patch:\n                patch = load_large_diff(filename, new_file_content_str, original_file_content_str)\n\n\n            # count number of lines added and removed\n            patch_lines = patch.splitlines(keepends=True)\n            num_plus_lines = len([line for line in patch_lines if line.startswith('+')])\n            num_minus_lines = len([line for line in patch_lines if line.startswith('-')])\n            diff_files.append(\n                FilePatchInfo(original_file_content_str, new_file_content_str,\n                              patch=patch,\n                              filename=filename,\n                              edit_type=edit_type,\n                              old_filename=None if diff['old_path'] == diff['new_path'] else diff['old_path'],\n                              num_plus_lines=num_plus_lines,\n                              num_minus_lines=num_minus_lines, ))\n        if invalid_files_names:\n            get_logger().info(f\"Filtered out files with invalid extensions: {invalid_files_names}\")\n\n        self.diff_files = diff_files\n        return diff_files\n\n    def get_files(self) -> list:\n        if not self.git_files:\n            self.git_files = [change['new_path'] for change in self.mr.changes()['changes']]\n        return self.git_files\n\n    def publish_description(self, pr_title: str, pr_body: str):\n        try:\n            self.mr.title = pr_title\n            self.mr.description = pr_body\n            self.mr.save()\n        except Exception as e:\n            get_logger().exception(f\"Could not update merge request {self.id_mr} description: {e}\")\n\n    def get_latest_commit_url(self):\n        try:\n            return self.mr.commits().next().web_url\n        except StopIteration: # no commits\n            return \"\"\n        except Exception as e:\n            get_logger().exception(f\"Could not get latest commit URL: {e}\")\n            return \"\"\n\n    def get_comment_url(self, comment):\n        return f\"{self.mr.web_url}#note_{comment.id}\"\n\n    def publish_persistent_comment(self, pr_comment: str,\n                                   initial_header: str,\n                                   update_header: bool = True,\n                                   name='review',\n                                   final_update_message=True):\n        self.publish_persistent_comment_full(pr_comment, initial_header, update_header, name, final_update_message)\n\n    def publish_comment(self, mr_comment: str, is_temporary: bool = False):\n        if is_temporary and not get_settings().config.publish_output_progress:\n            get_logger().debug(f\"Skipping publish_comment for temporary comment: {mr_comment}\")\n            return None\n        mr_comment = self.limit_output_characters(mr_comment, self.max_comment_chars)\n        comment = self.mr.notes.create({'body': mr_comment})\n        if is_temporary:\n            self.temp_comments.append(comment)\n        return comment\n\n    def edit_comment(self, comment, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        self.mr.notes.update(comment.id,{'body': body} )\n\n    def edit_comment_from_comment_id(self, comment_id: int, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        comment = self.mr.notes.get(comment_id)\n        comment.body = body\n        comment.save()\n\n    def reply_to_comment_from_comment_id(self, comment_id: int, body: str):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        discussion = self.mr.discussions.get(comment_id)\n        discussion.notes.create({'body': body})\n\n    def publish_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, original_suggestion=None):\n        body = self.limit_output_characters(body, self.max_comment_chars)\n        edit_type, found, source_line_no, target_file, target_line_no = self.search_line(relevant_file,\n                                                                                         relevant_line_in_file)\n        self.send_inline_comment(body, edit_type, found, relevant_file, relevant_line_in_file, source_line_no,\n                                 target_file, target_line_no, original_suggestion)\n\n    def create_inline_comment(self, body: str, relevant_file: str, relevant_line_in_file: str, absolute_position: int = None):\n        raise NotImplementedError(\"Gitlab provider does not support creating inline comments yet\")\n\n    def create_inline_comments(self, comments: list[dict]):\n        raise NotImplementedError(\"Gitlab provider does not support publishing inline comments yet\")\n\n    def get_comment_body_from_comment_id(self, comment_id: int):\n        comment = self.mr.notes.get(comment_id).body\n        return comment\n\n    def send_inline_comment(self, body: str, edit_type: str, found: bool, relevant_file: str,\n                            relevant_line_in_file: str,\n                            source_line_no: int, target_file: str, target_line_no: int,\n                            original_suggestion=None) -> None:\n        if not found:\n            get_logger().info(f\"Could not find position for {relevant_file} {relevant_line_in_file}\")\n        else:\n            # in order to have exact sha's we have to find correct diff for this change\n            diff = self.get_relevant_diff(relevant_file, relevant_line_in_file)\n            if diff is None:\n                get_logger().error(f\"Could not get diff for merge request {self.id_mr}\")\n                raise DiffNotFoundError(f\"Could not get diff for merge request {self.id_mr}\")\n            pos_obj = {'position_type': 'text',\n                       'new_path': target_file.filename,\n                       'old_path': target_file.old_filename if target_file.old_filename else target_file.filename,\n                       'base_sha': diff.base_commit_sha, 'start_sha': diff.start_commit_sha, 'head_sha': diff.head_commit_sha}\n            if edit_type == 'deletion':\n                pos_obj['old_line'] = source_line_no - 1\n            elif edit_type == 'addition':\n                pos_obj['new_line'] = target_line_no - 1\n            else:\n                pos_obj['new_line'] = target_line_no - 1\n                pos_obj['old_line'] = source_line_no - 1\n            get_logger().debug(f\"Creating comment in MR {self.id_mr} with body {body} and position {pos_obj}\")\n            try:\n                self.mr.discussions.create({'body': body, 'position': pos_obj})\n            except Exception as e:\n                try:\n                    # fallback - create a general note on the file in the MR\n                    if 'suggestion_orig_location' in original_suggestion:\n                        line_start = original_suggestion['suggestion_orig_location']['start_line']\n                        line_end = original_suggestion['suggestion_orig_location']['end_line']\n                        old_code_snippet = original_suggestion['prev_code_snippet']\n                        new_code_snippet = original_suggestion['new_code_snippet']\n                        content = original_suggestion['suggestion_summary']\n                        label = original_suggestion['category']\n                        if 'score' in original_suggestion:\n                            score = original_suggestion['score']\n                        else:\n                            score = 7\n                    else:\n                        line_start = original_suggestion['relevant_lines_start']\n                        line_end = original_suggestion['relevant_lines_end']\n                        old_code_snippet = original_suggestion['existing_code']\n                        new_code_snippet = original_suggestion['improved_code']\n                        content = original_suggestion['suggestion_content']\n                        label = original_suggestion['label']\n                        score = original_suggestion.get('score', 7)\n\n                    if hasattr(self, 'main_language'):\n                        language = self.main_language\n                    else:\n                        language = ''\n                    link = self.get_line_link(relevant_file, line_start, line_end)\n                    body_fallback =f\"**Suggestion:** {content} [{label}, importance: {score}]\\n\\n\"\n                    body_fallback +=f\"\\n\\n<details><summary>[{target_file.filename} [{line_start}-{line_end}]]({link}):</summary>\\n\\n\"\n                    body_fallback += f\"\\n\\n___\\n\\n`(Cannot implement directly - GitLab API allows committable suggestions strictly on MR diff lines)`\"\n                    body_fallback+=\"</details>\\n\\n\"\n                    diff_patch = difflib.unified_diff(old_code_snippet.split('\\n'),\n                                                new_code_snippet.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff_patch)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n                    diff_code = f\"\\n\\n```diff\\n{patch.rstrip()}\\n```\"\n                    body_fallback += diff_code\n\n                    # Create a general note on the file in the MR\n                    self.mr.notes.create({\n                        'body': body_fallback,\n                        'position': {\n                            'base_sha': diff.base_commit_sha,\n                            'start_sha': diff.start_commit_sha,\n                            'head_sha': diff.head_commit_sha,\n                            'position_type': 'text',\n                            'file_path': f'{target_file.filename}',\n                        }\n                    })\n                    get_logger().debug(f\"Created fallback comment in MR {self.id_mr} with position {pos_obj}\")\n\n                    # get_logger().debug(\n                    #     f\"Failed to create comment in MR {self.id_mr} with position {pos_obj} (probably not a '+' line)\")\n                except Exception as e:\n                    get_logger().exception(f\"Failed to create comment in MR {self.id_mr}\")\n\n    def get_relevant_diff(self, relevant_file: str, relevant_line_in_file: str) -> Optional[dict]:\n        changes = self.mr.changes()  # Retrieve the changes for the merge request once\n        if not changes:\n            get_logger().error('No changes found for the merge request.')\n            return None\n        all_diffs = self.mr.diffs.list(get_all=True)\n        if not all_diffs:\n            get_logger().error('No diffs found for the merge request.')\n            return None\n        for diff in all_diffs:\n            for change in changes['changes']:\n                if change['new_path'] == relevant_file and relevant_line_in_file in change['diff']:\n                    return diff\n            get_logger().debug(\n                f'No relevant diff found for {relevant_file} {relevant_line_in_file}. Falling back to last diff.')\n        return self.last_diff  # fallback to last_diff if no relevant diff is found\n\n    def publish_code_suggestions(self, code_suggestions: list) -> bool:\n        for suggestion in code_suggestions:\n            try:\n                if suggestion and 'original_suggestion' in suggestion:\n                    original_suggestion = suggestion['original_suggestion']\n                else:\n                    original_suggestion = suggestion\n                body = suggestion['body']\n                relevant_file = suggestion['relevant_file']\n                relevant_lines_start = suggestion['relevant_lines_start']\n                relevant_lines_end = suggestion['relevant_lines_end']\n\n                diff_files = self.get_diff_files()\n                target_file = None\n                for file in diff_files:\n                    if file.filename == relevant_file:\n                        if file.filename == relevant_file:\n                            target_file = file\n                            break\n                range = relevant_lines_end - relevant_lines_start # no need to add 1\n                body = body.replace('```suggestion', f'```suggestion:-0+{range}')\n                lines = target_file.head_file.splitlines()\n                relevant_line_in_file = lines[relevant_lines_start - 1]\n\n                # edit_type, found, source_line_no, target_file, target_line_no = self.find_in_file(target_file,\n                #                                                                            relevant_line_in_file)\n                # for code suggestions, we want to edit the new code\n                source_line_no = -1\n                target_line_no = relevant_lines_start + 1\n                found = True\n                edit_type = 'addition'\n\n                self.send_inline_comment(body, edit_type, found, relevant_file, relevant_line_in_file, source_line_no,\n                                         target_file, target_line_no, original_suggestion)\n            except Exception as e:\n                get_logger().exception(f\"Could not publish code suggestion:\\nsuggestion: {suggestion}\\nerror: {e}\")\n\n        # note that we publish suggestions one-by-one. so, if one fails, the rest will still be published\n        return True\n\n    def publish_file_comments(self, file_comments: list) -> bool:\n        pass\n\n    def search_line(self, relevant_file, relevant_line_in_file):\n        target_file = None\n\n        edit_type = self.get_edit_type(relevant_line_in_file)\n        for file in self.get_diff_files():\n            if file.filename == relevant_file:\n                edit_type, found, source_line_no, target_file, target_line_no = self.find_in_file(file,\n                                                                                                  relevant_line_in_file)\n        return edit_type, found, source_line_no, target_file, target_line_no\n\n    def find_in_file(self, file, relevant_line_in_file):\n        edit_type = 'context'\n        source_line_no = 0\n        target_line_no = 0\n        found = False\n        target_file = file\n        patch = file.patch\n        patch_lines = patch.splitlines()\n        for line in patch_lines:\n            if line.startswith('@@'):\n                match = self.RE_HUNK_HEADER.match(line)\n                if not match:\n                    continue\n                start_old, size_old, start_new, size_new, _ = match.groups()\n                source_line_no = int(start_old)\n                target_line_no = int(start_new)\n                continue\n            if line.startswith('-'):\n                source_line_no += 1\n            elif line.startswith('+'):\n                target_line_no += 1\n            elif line.startswith(' '):\n                source_line_no += 1\n                target_line_no += 1\n            if relevant_line_in_file in line:\n                found = True\n                edit_type = self.get_edit_type(line)\n                break\n            elif relevant_line_in_file[0] == '+' and relevant_line_in_file[1:].lstrip() in line:\n                # The model often adds a '+' to the beginning of the relevant_line_in_file even if originally\n                # it's a context line\n                found = True\n                edit_type = self.get_edit_type(line)\n                break\n        return edit_type, found, source_line_no, target_file, target_line_no\n\n    def get_edit_type(self, relevant_line_in_file):\n        edit_type = 'context'\n        if relevant_line_in_file[0] == '-':\n            edit_type = 'deletion'\n        elif relevant_line_in_file[0] == '+':\n            edit_type = 'addition'\n        return edit_type\n\n    def remove_initial_comment(self):\n        try:\n            for comment in self.temp_comments:\n                self.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove temp comments, error: {e}\")\n\n    def remove_comment(self, comment):\n        try:\n            comment.delete()\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove comment, error: {e}\")\n\n    def get_title(self):\n        return self.mr.title\n\n    def get_languages(self):\n        languages = self.gl.projects.get(self.id_project).languages()\n        return languages\n\n    def get_pr_branch(self):\n        return self.mr.source_branch\n\n    def get_pr_owner_id(self) -> str | None:\n        if not self.gitlab_url or 'scm.devops.vnpt.vn' in self.gitlab_url:\n            if not self.id_project:\n                return None\n            return self.id_project.split('/')[0]\n        # extract host name\n        host = urlparse(self.gitlab_url).hostname\n        return host\n\n    def get_pr_description_full(self):\n        return self.mr.description\n\n    def get_issue_comments(self):\n        return self.mr.notes.list(get_all=True)[::-1]\n\n    def get_repo_settings(self):\n        try:\n            contents = self.gl.projects.get(self.id_project).files.get(file_path='.pr_agent.toml', ref=self.mr.target_branch).decode()\n            return contents\n        except Exception:\n            return \"\"\n\n    def get_workspace_name(self):\n        return self.id_project.split('/')[0]\n\n    def add_eyes_reaction(self, issue_comment_id: int, disable_eyes: bool = False) -> Optional[int]:\n        return True\n\n    def remove_reaction(self, issue_comment_id: int, reaction_id: int) -> bool:\n        return True\n\n    def _parse_merge_request_url(self, merge_request_url: str) -> Tuple[str, int]:\n        parsed_url = urlparse(merge_request_url)\n\n        path_parts = parsed_url.path.strip('/').split('/')\n        if 'merge_requests' not in path_parts:\n            raise ValueError(\"The provided URL does not appear to be a GitLab merge request URL\")\n\n        mr_index = path_parts.index('merge_requests')\n        # Ensure there is an ID after 'merge_requests'\n        if len(path_parts) <= mr_index + 1:\n            raise ValueError(\"The provided URL does not contain a merge request ID\")\n\n        try:\n            mr_id = int(path_parts[mr_index + 1])\n        except ValueError as e:\n            raise ValueError(\"Unable to convert merge request ID to integer\") from e\n\n        # Handle special delimiter (-)\n        project_path = \"/\".join(path_parts[:mr_index])\n        if project_path.endswith('/-'):\n            project_path = project_path[:-2]\n\n        # Return the path before 'merge_requests' and the ID\n        return project_path, mr_id\n\n    def _get_merge_request(self):\n        mr = self.gl.projects.get(self.id_project).mergerequests.get(self.id_mr)\n        return mr\n\n    def get_user_id(self):\n        return None\n\n    def publish_labels(self, pr_types):\n        try:\n            self.mr.labels = list(set(pr_types))\n            self.mr.save()\n        except Exception as e:\n            get_logger().warning(f\"Failed to publish labels, error: {e}\")\n\n    def publish_inline_comments(self, comments: list[dict]):\n        pass\n\n    def get_pr_labels(self, update=False):\n        return self.mr.labels\n\n    def get_repo_labels(self):\n        return self.gl.projects.get(self.id_project).labels.list()\n\n    def get_commit_messages(self):\n        \"\"\"\n        Retrieves the commit messages of a pull request.\n\n        Returns:\n            str: A string containing the commit messages of the pull request.\n        \"\"\"\n        max_tokens = get_settings().get(\"CONFIG.MAX_COMMITS_TOKENS\", None)\n        try:\n            commit_messages_list = [commit['message'] for commit in self.mr.commits()._list]\n            commit_messages_str = \"\\n\".join([f\"{i + 1}. {message}\" for i, message in enumerate(commit_messages_list)])\n        except Exception:\n            commit_messages_str = \"\"\n        if max_tokens:\n            commit_messages_str = clip_tokens(commit_messages_str, max_tokens)\n        return commit_messages_str\n\n    def get_pr_id(self):\n        try:\n            pr_id = self.mr.web_url\n            return pr_id\n        except:\n            return \"\"\n\n    def get_line_link(self, relevant_file: str, relevant_line_start: int, relevant_line_end: int = None) -> str:\n        if relevant_line_start == -1:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads\"\n        elif relevant_line_end:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{relevant_line_start}-{relevant_line_end}\"\n        else:\n            link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{relevant_line_start}\"\n        return link\n\n\n    def generate_link_to_relevant_line_number(self, suggestion) -> str:\n        try:\n            relevant_file = suggestion['relevant_file'].strip('`').strip(\"'\").rstrip()\n            relevant_line_str = suggestion['relevant_line'].rstrip()\n            if not relevant_line_str:\n                return \"\"\n\n            position, absolute_position = find_line_number_of_relevant_line_in_file \\\n                (self.diff_files, relevant_file, relevant_line_str)\n\n            if absolute_position != -1:\n                # link to right file only\n                link = f\"{self.gl.url}/{self.id_project}/-/blob/{self.mr.source_branch}/{relevant_file}?ref_type=heads#L{absolute_position}\"\n\n                # # link to diff\n                # sha_file = hashlib.sha1(relevant_file.encode('utf-8')).hexdigest()\n                # link = f\"{self.pr.web_url}/diffs#{sha_file}_{absolute_position}_{absolute_position}\"\n                return link\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Failed adding line link, error: {e}\")\n\n        return \"\"\n    #Clone related\n    def _prepare_clone_url_with_token(self, repo_url_to_clone: str) -> str | None:\n        if \"gitlab.\" not in repo_url_to_clone:\n            get_logger().error(f\"Repo URL: {repo_url_to_clone} is not a valid gitlab URL.\")\n            return None\n        (scheme, base_url) = repo_url_to_clone.split(\"gitlab.\")\n        access_token = self.gl.oauth_token\n        if not all([scheme, access_token, base_url]):\n            get_logger().error(f\"Either no access token found, or repo URL: {repo_url_to_clone} \"\n                               f\"is missing prefix: {scheme} and/or base URL: {base_url}.\")\n            return None\n\n        #Note that the \"\"official\"\" method found here:\n        # https://docs.gitlab.com/user/profile/personal_access_tokens/#clone-repository-using-personal-access-token\n        # requires a username, which may not be applicable.\n        # The following solution is taken from: https://stackoverflow.com/questions/25409700/using-gitlab-token-to-clone-without-authentication/35003812#35003812\n        # For example: For repo url: https://gitlab.codium-inc.com/qodo/autoscraper.git\n        # Then to clone one will issue: 'git clone https://oauth2:<access token>@gitlab.codium-inc.com/qodo/autoscraper.git'\n\n        clone_url = f\"{scheme}oauth2:{access_token}@gitlab.{base_url}\"\n        return clone_url",
    "start_line": 27,
    "end_line": 657,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "GitProvider"
    ],
    "class_name": null,
    "display_name": "class VnptScmProvider",
    "component_id": "pr_agent.git_providers.vnpt_scm_provider.VnptScmProvider"
  },
  "pr_agent.identity_providers.__init__.get_identity_provider": {
    "id": "pr_agent.identity_providers.__init__.get_identity_provider",
    "name": "get_identity_provider",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/identity_providers/__init__.py",
    "relative_path": "pr_agent/identity_providers/__init__.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_identity_provider():\n    identity_provider_id = get_settings().get(\"CONFIG.IDENTITY_PROVIDER\", \"default\")\n    if identity_provider_id not in _IDENTITY_PROVIDERS:\n        raise ValueError(f\"Unknown identity provider: {identity_provider_id}\")\n    return _IDENTITY_PROVIDERS[identity_provider_id]()",
    "start_line": 10,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_identity_provider",
    "component_id": "pr_agent.identity_providers.__init__.get_identity_provider"
  },
  "pr_agent.identity_providers.default_identity_provider.DefaultIdentityProvider": {
    "id": "pr_agent.identity_providers.default_identity_provider.DefaultIdentityProvider",
    "name": "DefaultIdentityProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/identity_providers/default_identity_provider.py",
    "relative_path": "pr_agent/identity_providers/default_identity_provider.py",
    "depends_on": [],
    "source_code": "class DefaultIdentityProvider(IdentityProvider):\n    def verify_eligibility(self, git_provider, git_provider_id, pr_url):\n        return Eligibility.ELIGIBLE\n\n    def inc_invocation_count(self, git_provider, git_provider_id):\n        pass",
    "start_line": 5,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "IdentityProvider"
    ],
    "class_name": null,
    "display_name": "class DefaultIdentityProvider",
    "component_id": "pr_agent.identity_providers.default_identity_provider.DefaultIdentityProvider"
  },
  "pr_agent.identity_providers.identity_provider.Eligibility": {
    "id": "pr_agent.identity_providers.identity_provider.Eligibility",
    "name": "Eligibility",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/identity_providers/identity_provider.py",
    "relative_path": "pr_agent/identity_providers/identity_provider.py",
    "depends_on": [],
    "source_code": "class Eligibility(Enum):\n    NOT_ELIGIBLE = 0\n    ELIGIBLE = 1\n    TRIAL = 2",
    "start_line": 5,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Enum"
    ],
    "class_name": null,
    "display_name": "class Eligibility",
    "component_id": "pr_agent.identity_providers.identity_provider.Eligibility"
  },
  "pr_agent.identity_providers.identity_provider.IdentityProvider": {
    "id": "pr_agent.identity_providers.identity_provider.IdentityProvider",
    "name": "IdentityProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/identity_providers/identity_provider.py",
    "relative_path": "pr_agent/identity_providers/identity_provider.py",
    "depends_on": [],
    "source_code": "class IdentityProvider(ABC):\n    @abstractmethod\n    def verify_eligibility(self, git_provider, git_provier_id, pr_url):\n        pass\n\n    @abstractmethod\n    def inc_invocation_count(self, git_provider, git_provider_id):\n        pass",
    "start_line": 11,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ABC"
    ],
    "class_name": null,
    "display_name": "class IdentityProvider",
    "component_id": "pr_agent.identity_providers.identity_provider.IdentityProvider"
  },
  "pr_agent.log.__init__.LoggingFormat": {
    "id": "pr_agent.log.__init__.LoggingFormat",
    "name": "LoggingFormat",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/log/__init__.py",
    "relative_path": "pr_agent/log/__init__.py",
    "depends_on": [],
    "source_code": "class LoggingFormat(str, Enum):\n    CONSOLE = \"CONSOLE\"\n    JSON = \"JSON\"",
    "start_line": 12,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class LoggingFormat",
    "component_id": "pr_agent.log.__init__.LoggingFormat"
  },
  "pr_agent.log.__init__.json_format": {
    "id": "pr_agent.log.__init__.json_format",
    "name": "json_format",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/log/__init__.py",
    "relative_path": "pr_agent/log/__init__.py",
    "depends_on": [],
    "source_code": "def json_format(record: dict) -> str:\n    return record[\"message\"]",
    "start_line": 17,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "record"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function json_format",
    "component_id": "pr_agent.log.__init__.json_format"
  },
  "pr_agent.log.__init__.analytics_filter": {
    "id": "pr_agent.log.__init__.analytics_filter",
    "name": "analytics_filter",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/log/__init__.py",
    "relative_path": "pr_agent/log/__init__.py",
    "depends_on": [],
    "source_code": "def analytics_filter(record: dict) -> bool:\n    return record.get(\"extra\", {}).get(\"analytics\", False)",
    "start_line": 21,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "record"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analytics_filter",
    "component_id": "pr_agent.log.__init__.analytics_filter"
  },
  "pr_agent.log.__init__.inv_analytics_filter": {
    "id": "pr_agent.log.__init__.inv_analytics_filter",
    "name": "inv_analytics_filter",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/log/__init__.py",
    "relative_path": "pr_agent/log/__init__.py",
    "depends_on": [],
    "source_code": "def inv_analytics_filter(record: dict) -> bool:\n    return not record.get(\"extra\", {}).get(\"analytics\", False)",
    "start_line": 25,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "record"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function inv_analytics_filter",
    "component_id": "pr_agent.log.__init__.inv_analytics_filter"
  },
  "pr_agent.log.__init__.setup_logger": {
    "id": "pr_agent.log.__init__.setup_logger",
    "name": "setup_logger",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/log/__init__.py",
    "relative_path": "pr_agent/log/__init__.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def setup_logger(level: str = \"INFO\", fmt: LoggingFormat = LoggingFormat.CONSOLE):\n    level: int = logging.getLevelName(level.upper())\n    if type(level) is not int:\n        level = logging.INFO\n\n    if fmt == LoggingFormat.JSON and os.getenv(\"LOG_SANE\", \"0\").lower() == \"0\":  # better debugging github_app\n        logger.remove(None)\n        logger.add(\n            sys.stdout,\n            filter=inv_analytics_filter,\n            level=level,\n            format=\"{message}\",\n            colorize=False,\n            serialize=True,\n        )\n    elif fmt == LoggingFormat.CONSOLE: # does not print the 'extra' fields\n        logger.remove(None)\n        logger.add(sys.stdout, level=level, colorize=True, filter=inv_analytics_filter)\n\n    log_folder = get_settings().get(\"CONFIG.ANALYTICS_FOLDER\", \"\")\n    if log_folder:\n        pid = os.getpid()\n        log_file = os.path.join(log_folder, f\"pr-agent.{pid}.log\")\n        logger.add(\n            log_file,\n            filter=analytics_filter,\n            level=level,\n            format=\"{message}\",\n            colorize=False,\n            serialize=True,\n        )\n\n    return logger",
    "start_line": 29,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "level",
      "fmt"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setup_logger",
    "component_id": "pr_agent.log.__init__.setup_logger"
  },
  "pr_agent.log.__init__.get_logger": {
    "id": "pr_agent.log.__init__.get_logger",
    "name": "get_logger",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/log/__init__.py",
    "relative_path": "pr_agent/log/__init__.py",
    "depends_on": [],
    "source_code": "def get_logger(*args, **kwargs):\n    return logger",
    "start_line": 64,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_logger",
    "component_id": "pr_agent.log.__init__.get_logger"
  },
  "pr_agent.secret_providers.__init__.get_secret_provider": {
    "id": "pr_agent.secret_providers.__init__.get_secret_provider",
    "name": "get_secret_provider",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/secret_providers/__init__.py",
    "relative_path": "pr_agent/secret_providers/__init__.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings",
      "pr_agent.secret_providers.google_cloud_storage_secret_provider.GoogleCloudStorageSecretProvider"
    ],
    "source_code": "def get_secret_provider():\n    if not get_settings().get(\"CONFIG.SECRET_PROVIDER\"):\n        return None\n\n    provider_id = get_settings().config.secret_provider\n    if provider_id == 'google_cloud_storage':\n        try:\n            from pr_agent.secret_providers.google_cloud_storage_secret_provider import \\\n                GoogleCloudStorageSecretProvider\n            return GoogleCloudStorageSecretProvider()\n        except Exception as e:\n            raise ValueError(f\"Failed to initialize google_cloud_storage secret provider {provider_id}\") from e\n    else:\n        raise ValueError(\"Unknown SECRET_PROVIDER\")",
    "start_line": 4,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_secret_provider",
    "component_id": "pr_agent.secret_providers.__init__.get_secret_provider"
  },
  "pr_agent.secret_providers.google_cloud_storage_secret_provider.GoogleCloudStorageSecretProvider": {
    "id": "pr_agent.secret_providers.google_cloud_storage_secret_provider.GoogleCloudStorageSecretProvider",
    "name": "GoogleCloudStorageSecretProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/secret_providers/google_cloud_storage_secret_provider.py",
    "relative_path": "pr_agent/secret_providers/google_cloud_storage_secret_provider.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class GoogleCloudStorageSecretProvider(SecretProvider):\n    def __init__(self):\n        try:\n            self.client = storage.Client.from_service_account_info(ujson.loads(get_settings().google_cloud_storage.\n                                                                               service_account))\n            self.bucket_name = get_settings().google_cloud_storage.bucket_name\n            self.bucket = self.client.bucket(self.bucket_name)\n        except Exception as e:\n            get_logger().error(f\"Failed to initialize Google Cloud Storage Secret Provider: {e}\")\n            raise e\n\n    def get_secret(self, secret_name: str) -> str:\n        try:\n            blob = self.bucket.blob(secret_name)\n            return blob.download_as_string()\n        except Exception as e:\n            get_logger().warning(f\"Failed to get secret {secret_name} from Google Cloud Storage: {e}\")\n            return \"\"\n\n    def store_secret(self, secret_name: str, secret_value: str):\n        try:\n            blob = self.bucket.blob(secret_name)\n            blob.upload_from_string(secret_value)\n        except Exception as e:\n            get_logger().error(f\"Failed to store secret {secret_name} in Google Cloud Storage: {e}\")\n            raise e",
    "start_line": 9,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SecretProvider"
    ],
    "class_name": null,
    "display_name": "class GoogleCloudStorageSecretProvider",
    "component_id": "pr_agent.secret_providers.google_cloud_storage_secret_provider.GoogleCloudStorageSecretProvider"
  },
  "pr_agent.secret_providers.secret_provider.SecretProvider": {
    "id": "pr_agent.secret_providers.secret_provider.SecretProvider",
    "name": "SecretProvider",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/secret_providers/secret_provider.py",
    "relative_path": "pr_agent/secret_providers/secret_provider.py",
    "depends_on": [],
    "source_code": "class SecretProvider(ABC):\n\n    @abstractmethod\n    def get_secret(self, secret_name: str) -> str:\n        pass\n\n    @abstractmethod\n    def store_secret(self, secret_name: str, secret_value: str):\n        pass",
    "start_line": 4,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ABC"
    ],
    "class_name": null,
    "display_name": "class SecretProvider",
    "component_id": "pr_agent.secret_providers.secret_provider.SecretProvider"
  },
  "pr_agent.servers.azuredevops_server_webhook.handle_request_comment": {
    "id": "pr_agent.servers.azuredevops_server_webhook.handle_request_comment",
    "name": "handle_request_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.agent.pr_agent.PRAgent"
    ],
    "source_code": "async def handle_request_comment( url: str, body: str, log_context: dict\n):\n    log_context[\"action\"] = body\n    log_context[\"api_url\"] = url\n\n    try:\n        with get_logger().contextualize(**log_context):\n            await PRAgent().handle_request(url, body)\n    except Exception as e:\n        get_logger().exception(f\"Failed to handle webhook\", artifact={\"url\": url, \"body\": body}, error=str(e))",
    "start_line": 36,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "url",
      "body",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_request_comment",
    "component_id": "pr_agent.servers.azuredevops_server_webhook.handle_request_comment"
  },
  "pr_agent.servers.azuredevops_server_webhook.authorize": {
    "id": "pr_agent.servers.azuredevops_server_webhook.authorize",
    "name": "authorize",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [],
    "source_code": "def authorize(credentials: HTTPBasicCredentials = Depends(security)):\n        is_user_ok = secrets.compare_digest(credentials.username, WEBHOOK_USERNAME)\n        is_pass_ok = secrets.compare_digest(credentials.password, WEBHOOK_PASSWORD)\n        if not (is_user_ok and is_pass_ok):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail='Incorrect username or password.',\n                headers={'WWW-Authenticate': 'Basic'},\n            )",
    "start_line": 50,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "credentials"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function authorize",
    "component_id": "pr_agent.servers.azuredevops_server_webhook.authorize"
  },
  "pr_agent.servers.azuredevops_server_webhook._perform_commands_azure": {
    "id": "pr_agent.servers.azuredevops_server_webhook._perform_commands_azure",
    "name": "_perform_commands_azure",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.update_settings_from_args",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "async def _perform_commands_azure(commands_conf: str, agent: PRAgent, api_url: str, log_context: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\", **log_context)\n        return\n    commands = get_settings().get(f\"azure_devops_server.{commands_conf}\")\n    if not commands:\n        return\n\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        try:\n            split_command = command.split(\" \")\n            command = split_command[0]\n            args = split_command[1:]\n            other_args = update_settings_from_args(args)\n            new_command = ' '.join([command] + other_args)\n            get_logger().info(f\"Performing command: {new_command}\")\n            with get_logger().contextualize(**log_context):\n                await agent.handle_request(api_url, new_command)\n        except Exception as e:\n            get_logger().error(f\"Failed to perform command {command}: {e}\")",
    "start_line": 61,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands_conf",
      "agent",
      "api_url",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _perform_commands_azure",
    "component_id": "pr_agent.servers.azuredevops_server_webhook._perform_commands_azure"
  },
  "pr_agent.servers.azuredevops_server_webhook.handle_request_azure": {
    "id": "pr_agent.servers.azuredevops_server_webhook.handle_request_azure",
    "name": "handle_request_azure",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.servers.azuredevops_server_webhook._perform_commands_azure",
      "pr_agent.servers.azuredevops_server_webhook.handle_request_comment"
    ],
    "source_code": "async def handle_request_azure(data, log_context):\n    actions = []\n    if data[\"eventType\"] == \"git.pullrequest.created\":\n        # API V1 (latest)\n        pr_url = unquote(data[\"resource\"][\"_links\"][\"web\"][\"href\"].replace(\"_apis/git/repositories\", \"_git\"))\n        log_context[\"event\"] = data[\"eventType\"]\n        log_context[\"api_url\"] = pr_url\n        await _perform_commands_azure(\"pr_commands\", PRAgent(), pr_url, log_context)\n        return JSONResponse(\n            status_code=status.HTTP_202_ACCEPTED,\n            content=jsonable_encoder({\"message\": \"webhook triggered successfully\"})\n        )\n    elif data[\"eventType\"] == \"ms.vss-code.git-pullrequest-comment-event\" and \"content\" in data[\"resource\"][\"comment\"]:\n        if available_commands_rgx.match(data[\"resource\"][\"comment\"][\"content\"]):\n            if(data[\"resourceVersion\"] == \"2.0\"):\n                repo = data[\"resource\"][\"pullRequest\"][\"repository\"][\"webUrl\"]\n                pr_url = unquote(f'{repo}/pullrequest/{data[\"resource\"][\"pullRequest\"][\"pullRequestId\"]}')\n                actions = [data[\"resource\"][\"comment\"][\"content\"]]\n            else:\n                # API V1 not supported as it does not contain the PR URL\n                return JSONResponse(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    content=json.dumps({\"message\": \"version 1.0 webhook for Azure Devops PR comment is not supported. please upgrade to version 2.0\"})),\n        else:\n            return JSONResponse(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                content=json.dumps({\"message\": \"Unsupported command\"}),\n            )\n    else:\n        return JSONResponse(\n            status_code=status.HTTP_204_NO_CONTENT,\n            content=json.dumps({\"message\": \"Unsupported event\"}),\n        )\n\n    log_context[\"event\"] = data[\"eventType\"]\n    log_context[\"api_url\"] = pr_url\n\n    for action in actions:\n        try:\n            await handle_request_comment(pr_url, action, log_context)\n        except Exception as e:\n            get_logger().error(\"Azure DevOps Trigger failed. Error:\" + str(e))\n            return JSONResponse(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                content=json.dumps({\"message\": \"Internal server error\"}),\n            )\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED, content=jsonable_encoder({\"message\": \"webhook triggered successfully\"})\n    )",
    "start_line": 85,
    "end_line": 133,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_request_azure",
    "component_id": "pr_agent.servers.azuredevops_server_webhook.handle_request_azure"
  },
  "pr_agent.servers.azuredevops_server_webhook.handle_webhook": {
    "id": "pr_agent.servers.azuredevops_server_webhook.handle_webhook",
    "name": "handle_webhook",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [],
    "source_code": "async def handle_webhook(background_tasks: BackgroundTasks, request: Request):\n    log_context = {\"server_type\": \"azure_devops_server\"}\n    data = await request.json()\n    # get_logger().info(json.dumps(data))\n\n    background_tasks.add_task(handle_request_azure, data, log_context)\n\n    return JSONResponse(\n        status_code=status.HTTP_202_ACCEPTED, content=jsonable_encoder({\"message\": \"webhook triggered successfully\"})\n    )",
    "start_line": 136,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "background_tasks",
      "request"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_webhook",
    "component_id": "pr_agent.servers.azuredevops_server_webhook.handle_webhook"
  },
  "pr_agent.servers.azuredevops_server_webhook.root": {
    "id": "pr_agent.servers.azuredevops_server_webhook.root",
    "name": "root",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [],
    "source_code": "async def root():\n    return {\"status\": \"ok\"}",
    "start_line": 148,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function root",
    "component_id": "pr_agent.servers.azuredevops_server_webhook.root"
  },
  "pr_agent.servers.azuredevops_server_webhook.start": {
    "id": "pr_agent.servers.azuredevops_server_webhook.start",
    "name": "start",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/azuredevops_server_webhook.py",
    "relative_path": "pr_agent/servers/azuredevops_server_webhook.py",
    "depends_on": [
      "pr_agent.cli.run"
    ],
    "source_code": "def start():\n    app = FastAPI(middleware=[Middleware(RawContextMiddleware)])\n    app.include_router(router)\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", \"3000\")))",
    "start_line": 151,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function start",
    "component_id": "pr_agent.servers.azuredevops_server_webhook.start"
  },
  "pr_agent.servers.bitbucket_app.get_bearer_token": {
    "id": "pr_agent.servers.bitbucket_app.get_bearer_token",
    "name": "get_bearer_token",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "async def get_bearer_token(shared_secret: str, client_key: str):\n    try:\n        now = int(time.time())\n        url = \"https://bitbucket.org/site/oauth2/access_token\"\n        canonical_url = \"GET&/site/oauth2/access_token&\"\n        qsh = hashlib.sha256(canonical_url.encode(\"utf-8\")).hexdigest()\n        app_key = get_settings().bitbucket.app_key\n\n        payload = {\n            \"iss\": app_key,\n            \"iat\": now,\n            \"exp\": now + 240,\n            \"qsh\": qsh,\n            \"sub\": client_key,\n            }\n        token = jwt.encode(payload, shared_secret, algorithm=\"HS256\")\n        payload = 'grant_type=urn%3Abitbucket%3Aoauth2%3Ajwt'\n        headers = {\n            'Authorization': f'JWT {token}',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        response = requests.request(\"POST\", url, headers=headers, data=payload)\n        bearer_token = response.json()[\"access_token\"]\n        return bearer_token\n    except Exception as e:\n        get_logger().error(f\"Failed to get bearer token: {e}\")\n        raise e",
    "start_line": 33,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "shared_secret",
      "client_key"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_bearer_token",
    "component_id": "pr_agent.servers.bitbucket_app.get_bearer_token"
  },
  "pr_agent.servers.bitbucket_app.handle_manifest": {
    "id": "pr_agent.servers.bitbucket_app.handle_manifest",
    "name": "handle_manifest",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "async def handle_manifest(request: Request, response: Response):\n    cur_dir = os.path.dirname(os.path.abspath(__file__))\n    manifest = open(os.path.join(cur_dir, \"atlassian-connect.json\"), \"rt\").read()\n    try:\n        manifest = manifest.replace(\"app_key\", get_settings().bitbucket.app_key)\n        manifest = manifest.replace(\"base_url\", get_settings().bitbucket.base_url)\n    except:\n        get_logger().error(\"Failed to replace api_key in Bitbucket manifest, trying to continue\")\n    manifest_obj = json.loads(manifest)\n    return JSONResponse(manifest_obj)",
    "start_line": 62,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request",
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_manifest",
    "component_id": "pr_agent.servers.bitbucket_app.handle_manifest"
  },
  "pr_agent.servers.bitbucket_app._get_username": {
    "id": "pr_agent.servers.bitbucket_app._get_username",
    "name": "_get_username",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [],
    "source_code": "def _get_username(data):\n    actor = data.get(\"data\", {}).get(\"actor\", {})\n    if actor:\n        if \"username\" in actor:\n            return actor[\"username\"]\n        elif \"display_name\" in actor:\n            return actor[\"display_name\"]\n        elif \"nickname\" in actor:\n            return actor[\"nickname\"]\n    return \"\"",
    "start_line": 74,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _get_username",
    "component_id": "pr_agent.servers.bitbucket_app._get_username"
  },
  "pr_agent.servers.bitbucket_app._perform_commands_bitbucket": {
    "id": "pr_agent.servers.bitbucket_app._perform_commands_bitbucket",
    "name": "_perform_commands_bitbucket",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.servers.gitlab_webhook.should_process_pr_logic",
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.update_settings_from_args",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "async def _perform_commands_bitbucket(commands_conf: str, agent: PRAgent, api_url: str, log_context: dict, data: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\")\n        return\n    if data.get(\"event\", \"\") == \"pullrequest:created\":\n        if not should_process_pr_logic(data):\n            return\n    commands = get_settings().get(f\"bitbucket_app.{commands_conf}\", {})\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        try:\n            split_command = command.split(\" \")\n            command = split_command[0]\n            args = split_command[1:]\n            other_args = update_settings_from_args(args)\n            new_command = ' '.join([command] + other_args)\n            get_logger().info(f\"Performing command: {new_command}\")\n            with get_logger().contextualize(**log_context):\n                await agent.handle_request(api_url, new_command)\n        except Exception as e:\n            get_logger().error(f\"Failed to perform command {command}: {e}\")",
    "start_line": 86,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands_conf",
      "agent",
      "api_url",
      "log_context",
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _perform_commands_bitbucket",
    "component_id": "pr_agent.servers.bitbucket_app._perform_commands_bitbucket"
  },
  "pr_agent.servers.bitbucket_app.is_bot_user": {
    "id": "pr_agent.servers.bitbucket_app.is_bot_user",
    "name": "is_bot_user",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def is_bot_user(data) -> bool:\n    try:\n        actor = data.get(\"data\", {}).get(\"actor\", {})\n        # allow actor type: user . if it's \"AppUser\" or \"team\" then it is a bot user\n        allowed_actor_types = {\"user\"}\n        if actor and actor[\"type\"].lower() not in allowed_actor_types:\n            get_logger().info(f\"BitBucket actor type is not 'user', skipping: {actor}\")\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_bot_user' logic: {e}\")\n    return False",
    "start_line": 110,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_bot_user",
    "component_id": "pr_agent.servers.bitbucket_app.is_bot_user"
  },
  "pr_agent.servers.bitbucket_app.should_process_pr_logic": {
    "id": "pr_agent.servers.bitbucket_app.should_process_pr_logic",
    "name": "should_process_pr_logic",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.servers.bitbucket_app._get_username",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def should_process_pr_logic(data) -> bool:\n    try:\n        pr_data = data.get(\"data\", {}).get(\"pullrequest\", {})\n        title = pr_data.get(\"title\", \"\")\n        source_branch = pr_data.get(\"source\", {}).get(\"branch\", {}).get(\"name\", \"\")\n        target_branch = pr_data.get(\"destination\", {}).get(\"branch\", {}).get(\"name\", \"\")\n        sender = _get_username(data)\n\n        # logic to ignore PRs from specific users\n        ignore_pr_users = get_settings().get(\"CONFIG.IGNORE_PR_AUTHORS\", [])\n        if ignore_pr_users and sender:\n            if sender in ignore_pr_users:\n                get_logger().info(f\"Ignoring PR from user '{sender}' due to 'config.ignore_pr_authors' setting\")\n                return False\n\n        # logic to ignore PRs with specific titles\n        if title:\n            ignore_pr_title_re = get_settings().get(\"CONFIG.IGNORE_PR_TITLE\", [])\n            if not isinstance(ignore_pr_title_re, list):\n                ignore_pr_title_re = [ignore_pr_title_re]\n            if ignore_pr_title_re and any(re.search(regex, title) for regex in ignore_pr_title_re):\n                get_logger().info(f\"Ignoring PR with title '{title}' due to config.ignore_pr_title setting\")\n                return False\n\n        ignore_pr_source_branches = get_settings().get(\"CONFIG.IGNORE_PR_SOURCE_BRANCHES\", [])\n        ignore_pr_target_branches = get_settings().get(\"CONFIG.IGNORE_PR_TARGET_BRANCHES\", [])\n        if (ignore_pr_source_branches or ignore_pr_target_branches):\n            if any(re.search(regex, source_branch) for regex in ignore_pr_source_branches):\n                get_logger().info(\n                    f\"Ignoring PR with source branch '{source_branch}' due to config.ignore_pr_source_branches settings\")\n                return False\n            if any(re.search(regex, target_branch) for regex in ignore_pr_target_branches):\n                get_logger().info(\n                    f\"Ignoring PR with target branch '{target_branch}' due to config.ignore_pr_target_branches settings\")\n                return False\n    except Exception as e:\n        get_logger().error(f\"Failed 'should_process_pr_logic': {e}\")\n    return True",
    "start_line": 123,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function should_process_pr_logic",
    "component_id": "pr_agent.servers.bitbucket_app.should_process_pr_logic"
  },
  "pr_agent.servers.bitbucket_app.handle_github_webhooks": {
    "id": "pr_agent.servers.bitbucket_app.handle_github_webhooks",
    "name": "handle_github_webhooks",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "async def handle_github_webhooks(request: Request, response: Response):\n    return \"Webhook server online!\"",
    "start_line": 230,
    "end_line": 231,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request",
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_github_webhooks",
    "component_id": "pr_agent.servers.bitbucket_app.handle_github_webhooks"
  },
  "pr_agent.servers.bitbucket_app.inner": {
    "id": "pr_agent.servers.bitbucket_app.inner",
    "name": "inner",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.servers.bitbucket_app._get_username",
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.servers.bitbucket_app.should_process_pr_logic",
      "pr_agent.servers.bitbucket_app.get_bearer_token",
      "pr_agent.servers.bitbucket_app.is_bot_user",
      "pr_agent.config_loader.get_settings",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.identity_providers.__init__.get_identity_provider",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.servers.bitbucket_app._perform_commands_bitbucket"
    ],
    "source_code": "    async def inner():\n        try:\n            # ignore bot users\n            if is_bot_user(data):\n                return \"OK\"\n\n            # Check if the PR should be processed\n            if data.get(\"event\", \"\") == \"pullrequest:created\":\n                if not should_process_pr_logic(data):\n                    return \"OK\"\n\n            # Get the username of the sender\n            log_context[\"sender\"] = _get_username(data)\n\n            sender_id = data.get(\"data\", {}).get(\"actor\", {}).get(\"account_id\", \"\")\n            log_context[\"sender_id\"] = sender_id\n            jwt_parts = input_jwt.split(\".\")\n            claim_part = jwt_parts[1]\n            claim_part += \"=\" * (-len(claim_part) % 4)\n            decoded_claims = base64.urlsafe_b64decode(claim_part)\n            claims = json.loads(decoded_claims)\n            client_key = claims[\"iss\"]\n            secrets = json.loads(secret_provider.get_secret(client_key))\n            shared_secret = secrets[\"shared_secret\"]\n            jwt.decode(input_jwt, shared_secret, audience=client_key, algorithms=[\"HS256\"])\n            bearer_token = await get_bearer_token(shared_secret, client_key)\n            context['bitbucket_bearer_token'] = bearer_token\n            context[\"settings\"] = copy.deepcopy(global_settings)\n            event = data[\"event\"]\n            agent = PRAgent()\n            if event == \"pullrequest:created\":\n                pr_url = data[\"data\"][\"pullrequest\"][\"links\"][\"html\"][\"href\"]\n                log_context[\"api_url\"] = pr_url\n                log_context[\"event\"] = \"pull_request\"\n                if pr_url:\n                    with get_logger().contextualize(**log_context):\n                        apply_repo_settings(pr_url)\n                        if get_identity_provider().verify_eligibility(\"bitbucket\",\n                                                        sender_id, pr_url) is not Eligibility.NOT_ELIGIBLE:\n                            if get_settings().get(\"bitbucket_app.pr_commands\"):\n                                await _perform_commands_bitbucket(\"pr_commands\", PRAgent(), pr_url, log_context, data)\n            elif event == \"pullrequest:comment_created\":\n                pr_url = data[\"data\"][\"pullrequest\"][\"links\"][\"html\"][\"href\"]\n                log_context[\"api_url\"] = pr_url\n                log_context[\"event\"] = \"comment\"\n                comment_body = data[\"data\"][\"comment\"][\"content\"][\"raw\"]\n                with get_logger().contextualize(**log_context):\n                    if get_identity_provider().verify_eligibility(\"bitbucket\",\n                                                                     sender_id, pr_url) is not Eligibility.NOT_ELIGIBLE:\n                        await agent.handle_request(pr_url, comment_body)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")",
    "start_line": 174,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function inner",
    "component_id": "pr_agent.servers.bitbucket_app.inner"
  },
  "pr_agent.servers.bitbucket_app.handle_installed_webhooks": {
    "id": "pr_agent.servers.bitbucket_app.handle_installed_webhooks",
    "name": "handle_installed_webhooks",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "async def handle_installed_webhooks(request: Request, response: Response):\n    try:\n        get_logger().info(\"handle_installed_webhooks\")\n        get_logger().info(request.headers)\n        data = await request.json()\n        get_logger().info(data)\n        shared_secret = data[\"sharedSecret\"]\n        client_key = data[\"clientKey\"]\n        username = data[\"principal\"][\"username\"]\n        secrets = {\n            \"shared_secret\": shared_secret,\n            \"client_key\": client_key\n        }\n        secret_provider.store_secret(username, json.dumps(secrets))\n    except Exception as e:\n        get_logger().error(f\"Failed to register user: {e}\")\n        return JSONResponse({\"error\": \"Unable to register user\"}, status_code=500)",
    "start_line": 234,
    "end_line": 250,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request",
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_installed_webhooks",
    "component_id": "pr_agent.servers.bitbucket_app.handle_installed_webhooks"
  },
  "pr_agent.servers.bitbucket_app.handle_uninstalled_webhooks": {
    "id": "pr_agent.servers.bitbucket_app.handle_uninstalled_webhooks",
    "name": "handle_uninstalled_webhooks",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "async def handle_uninstalled_webhooks(request: Request, response: Response):\n    get_logger().info(\"handle_uninstalled_webhooks\")\n\n    data = await request.json()\n    get_logger().info(data)",
    "start_line": 253,
    "end_line": 257,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request",
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_uninstalled_webhooks",
    "component_id": "pr_agent.servers.bitbucket_app.handle_uninstalled_webhooks"
  },
  "pr_agent.servers.bitbucket_app.start": {
    "id": "pr_agent.servers.bitbucket_app.start",
    "name": "start",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_app.py",
    "relative_path": "pr_agent/servers/bitbucket_app.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings",
      "pr_agent.cli.run"
    ],
    "source_code": "def start():\n    get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\n    get_settings().set(\"CONFIG.GIT_PROVIDER\", \"bitbucket\")\n    get_settings().set(\"PR_DESCRIPTION.PUBLISH_DESCRIPTION_AS_COMMENT\", True)\n    middleware = [Middleware(RawContextMiddleware)]\n    app = FastAPI(middleware=middleware)\n    app.include_router(router)\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.getenv(\"PORT\", \"3000\")))",
    "start_line": 260,
    "end_line": 268,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function start",
    "component_id": "pr_agent.servers.bitbucket_app.start"
  },
  "pr_agent.servers.bitbucket_server_webhook.handle_request": {
    "id": "pr_agent.servers.bitbucket_server_webhook.handle_request",
    "name": "handle_request",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [],
    "source_code": "def handle_request(\n    background_tasks: BackgroundTasks, url: str, body: str, log_context: dict\n):\n    log_context[\"action\"] = body\n    log_context[\"api_url\"] = url\n\n    async def inner():\n        try:\n            with get_logger().contextualize(**log_context):\n                await PRAgent().handle_request(url, body)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")\n\n    background_tasks.add_task(inner)",
    "start_line": 28,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "background_tasks",
      "url",
      "body",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_request",
    "component_id": "pr_agent.servers.bitbucket_server_webhook.handle_request"
  },
  "pr_agent.servers.bitbucket_server_webhook.inner": {
    "id": "pr_agent.servers.bitbucket_server_webhook.inner",
    "name": "inner",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [
      "pr_agent.servers.bitbucket_server_webhook._run_commands_sequentially",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.servers.bitbucket_server_webhook.handle_request"
    ],
    "source_code": "    async def inner():\n        try:\n            await _run_commands_sequentially(commands_to_run, pr_url, log_context)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")",
    "start_line": 89,
    "end_line": 93,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function inner",
    "component_id": "pr_agent.servers.bitbucket_server_webhook.inner"
  },
  "pr_agent.servers.bitbucket_server_webhook.redirect_to_webhook": {
    "id": "pr_agent.servers.bitbucket_server_webhook.redirect_to_webhook",
    "name": "redirect_to_webhook",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [],
    "source_code": "async def redirect_to_webhook():\n    return RedirectResponse(url=\"/webhook\")",
    "start_line": 44,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function redirect_to_webhook",
    "component_id": "pr_agent.servers.bitbucket_server_webhook.redirect_to_webhook"
  },
  "pr_agent.servers.bitbucket_server_webhook.handle_webhook": {
    "id": "pr_agent.servers.bitbucket_server_webhook.handle_webhook",
    "name": "handle_webhook",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.config_loader.get_settings",
      "pr_agent.servers.bitbucket_server_webhook._get_commands_list_from_settings",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.utils.verify_signature"
    ],
    "source_code": "async def handle_webhook(background_tasks: BackgroundTasks, request: Request):\n    log_context = {\"server_type\": \"bitbucket_server\"}\n    data = await request.json()\n    get_logger().info(json.dumps(data))\n\n    webhook_secret = get_settings().get(\"BITBUCKET_SERVER.WEBHOOK_SECRET\", None)\n    if webhook_secret:\n        body_bytes = await request.body()\n        if body_bytes.decode('utf-8') == '{\"test\": true}':\n            return JSONResponse(\n                status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"connection test successful\"})\n            )\n        signature_header = request.headers.get(\"x-hub-signature\", None)\n        verify_signature(body_bytes, webhook_secret, signature_header)\n\n    pr_id = data[\"pullRequest\"][\"id\"]\n    repository_name = data[\"pullRequest\"][\"toRef\"][\"repository\"][\"slug\"]\n    project_name = data[\"pullRequest\"][\"toRef\"][\"repository\"][\"project\"][\"key\"]\n    bitbucket_server = get_settings().get(\"BITBUCKET_SERVER.URL\")\n    pr_url = f\"{bitbucket_server}/projects/{project_name}/repos/{repository_name}/pull-requests/{pr_id}\"\n\n    log_context[\"api_url\"] = pr_url\n    log_context[\"event\"] = \"pull_request\"\n\n    commands_to_run = []\n\n    if data[\"eventKey\"] == \"pr:opened\":\n        apply_repo_settings(pr_url)\n        if get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n            get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {pr_url}\", **log_context)\n            return\n        get_settings().set(\"config.is_auto_command\", True)\n        commands_to_run.extend(_get_commands_list_from_settings('BITBUCKET_SERVER.PR_COMMANDS'))\n    elif data[\"eventKey\"] == \"pr:comment:added\":\n        commands_to_run.append(data[\"comment\"][\"text\"])\n    else:\n        return JSONResponse(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            content=json.dumps({\"message\": \"Unsupported event\"}),\n        )\n\n    async def inner():\n        try:\n            await _run_commands_sequentially(commands_to_run, pr_url, log_context)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle webhook: {e}\")\n\n    background_tasks.add_task(inner)\n\n    return JSONResponse(\n        status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"})\n    )",
    "start_line": 48,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "background_tasks",
      "request"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_webhook",
    "component_id": "pr_agent.servers.bitbucket_server_webhook.handle_webhook"
  },
  "pr_agent.servers.bitbucket_server_webhook._run_commands_sequentially": {
    "id": "pr_agent.servers.bitbucket_server_webhook._run_commands_sequentially",
    "name": "_run_commands_sequentially",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [
      "pr_agent.servers.bitbucket_server_webhook._process_command",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.servers.bitbucket_server_webhook.handle_request"
    ],
    "source_code": "async def _run_commands_sequentially(commands: List[str], url: str, log_context: dict):\n    get_logger().info(f\"Running commands sequentially: {commands}\")\n    if commands is None:\n        return\n\n    for command in commands:\n        try:\n            body = _process_command(command, url)\n\n            log_context[\"action\"] = body\n            log_context[\"api_url\"] = url\n\n            with get_logger().contextualize(**log_context):\n                await PRAgent().handle_request(url, body)\n        except Exception as e:\n            get_logger().error(f\"Failed to handle command: {command} , error: {e}\")",
    "start_line": 102,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands",
      "url",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _run_commands_sequentially",
    "component_id": "pr_agent.servers.bitbucket_server_webhook._run_commands_sequentially"
  },
  "pr_agent.servers.bitbucket_server_webhook._process_command": {
    "id": "pr_agent.servers.bitbucket_server_webhook._process_command",
    "name": "_process_command",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [
      "pr_agent.algo.utils.update_settings_from_args",
      "pr_agent.git_providers.utils.apply_repo_settings"
    ],
    "source_code": "def _process_command(command: str, url) -> str:\n    # don't think we need this\n    apply_repo_settings(url)\n    # Process the command string\n    split_command = command.split(\" \")\n    command = split_command[0]\n    args = split_command[1:]\n    # do I need this? if yes, shouldn't this be done in PRAgent?\n    other_args = update_settings_from_args(args)\n    new_command = ' '.join([command] + other_args)\n    return new_command",
    "start_line": 119,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command",
      "url"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _process_command",
    "component_id": "pr_agent.servers.bitbucket_server_webhook._process_command"
  },
  "pr_agent.servers.bitbucket_server_webhook._to_list": {
    "id": "pr_agent.servers.bitbucket_server_webhook._to_list",
    "name": "_to_list",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [],
    "source_code": "def _to_list(command_string: str) -> list:\n    try:\n        # Use ast.literal_eval to safely parse the string into a list\n        commands = ast.literal_eval(command_string)\n        # Check if the parsed object is a list of strings\n        if isinstance(commands, list) and all(isinstance(cmd, str) for cmd in commands):\n            return commands\n        else:\n            raise ValueError(\"Parsed data is not a list of strings.\")\n    except (SyntaxError, ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid command string: {e}\")",
    "start_line": 132,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "command_string"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _to_list",
    "component_id": "pr_agent.servers.bitbucket_server_webhook._to_list"
  },
  "pr_agent.servers.bitbucket_server_webhook._get_commands_list_from_settings": {
    "id": "pr_agent.servers.bitbucket_server_webhook._get_commands_list_from_settings",
    "name": "_get_commands_list_from_settings",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def _get_commands_list_from_settings(setting_key:str ) -> list:\n    try:\n        return get_settings().get(setting_key, [])\n    except ValueError as e:\n        get_logger().error(f\"Failed to get commands list from settings {setting_key}: {e}\")",
    "start_line": 145,
    "end_line": 149,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "setting_key"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _get_commands_list_from_settings",
    "component_id": "pr_agent.servers.bitbucket_server_webhook._get_commands_list_from_settings"
  },
  "pr_agent.servers.bitbucket_server_webhook.root": {
    "id": "pr_agent.servers.bitbucket_server_webhook.root",
    "name": "root",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [],
    "source_code": "async def root():\n    return {\"status\": \"ok\"}",
    "start_line": 153,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function root",
    "component_id": "pr_agent.servers.bitbucket_server_webhook.root"
  },
  "pr_agent.servers.bitbucket_server_webhook.start": {
    "id": "pr_agent.servers.bitbucket_server_webhook.start",
    "name": "start",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/bitbucket_server_webhook.py",
    "relative_path": "pr_agent/servers/bitbucket_server_webhook.py",
    "depends_on": [
      "pr_agent.cli.run"
    ],
    "source_code": "def start():\n    app = FastAPI(middleware=[Middleware(RawContextMiddleware)])\n    app.include_router(router)\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", \"3000\")))",
    "start_line": 157,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function start",
    "component_id": "pr_agent.servers.bitbucket_server_webhook.start"
  },
  "pr_agent.servers.gerrit_server.Action": {
    "id": "pr_agent.servers.gerrit_server.Action",
    "name": "Action",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gerrit_server.py",
    "relative_path": "pr_agent/servers/gerrit_server.py",
    "depends_on": [],
    "source_code": "class Action(str, Enum):\n    review = \"review\"\n    describe = \"describe\"\n    ask = \"ask\"\n    improve = \"improve\"\n    reflect = \"reflect\"\n    answer = \"answer\"",
    "start_line": 20,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class Action",
    "component_id": "pr_agent.servers.gerrit_server.Action"
  },
  "pr_agent.servers.gerrit_server.Item": {
    "id": "pr_agent.servers.gerrit_server.Item",
    "name": "Item",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gerrit_server.py",
    "relative_path": "pr_agent/servers/gerrit_server.py",
    "depends_on": [],
    "source_code": "class Item(BaseModel):\n    refspec: str\n    project: str\n    msg: str",
    "start_line": 29,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class Item",
    "component_id": "pr_agent.servers.gerrit_server.Item"
  },
  "pr_agent.servers.gerrit_server.handle_gerrit_request": {
    "id": "pr_agent.servers.gerrit_server.handle_gerrit_request",
    "name": "handle_gerrit_request",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gerrit_server.py",
    "relative_path": "pr_agent/servers/gerrit_server.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.agent.pr_agent.PRAgent"
    ],
    "source_code": "async def handle_gerrit_request(action: Action, item: Item):\n    get_logger().debug(\"Received a Gerrit request\")\n    context[\"settings\"] = copy.deepcopy(global_settings)\n\n    if action == Action.ask:\n        if not item.msg:\n            return HTTPException(\n                status_code=400,\n                detail=\"msg is required for ask command\"\n            )\n    await PRAgent().handle_request(\n        f\"{item.project}:{item.refspec}\",\n        f\"/{item.msg.strip()}\"\n    )",
    "start_line": 36,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "action",
      "item"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_gerrit_request",
    "component_id": "pr_agent.servers.gerrit_server.handle_gerrit_request"
  },
  "pr_agent.servers.gerrit_server.get_body": {
    "id": "pr_agent.servers.gerrit_server.get_body",
    "name": "get_body",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gerrit_server.py",
    "relative_path": "pr_agent/servers/gerrit_server.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "async def get_body(request):\n    try:\n        body = await request.json()\n    except JSONDecodeError as e:\n        get_logger().error(\"Error parsing request body\", e)\n        return {}\n    return body",
    "start_line": 52,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_body",
    "component_id": "pr_agent.servers.gerrit_server.get_body"
  },
  "pr_agent.servers.gerrit_server.root": {
    "id": "pr_agent.servers.gerrit_server.root",
    "name": "root",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gerrit_server.py",
    "relative_path": "pr_agent/servers/gerrit_server.py",
    "depends_on": [],
    "source_code": "async def root():\n    return {\"status\": \"ok\"}",
    "start_line": 62,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function root",
    "component_id": "pr_agent.servers.gerrit_server.root"
  },
  "pr_agent.servers.gerrit_server.start": {
    "id": "pr_agent.servers.gerrit_server.start",
    "name": "start",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gerrit_server.py",
    "relative_path": "pr_agent/servers/gerrit_server.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings",
      "pr_agent.cli.run"
    ],
    "source_code": "def start():\n    # to prevent adding help messages with the output\n    get_settings().set(\"CONFIG.CLI_MODE\", True)\n    middleware = [Middleware(RawContextMiddleware)]\n    app = FastAPI(middleware=middleware)\n    app.include_router(router)\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=3000)",
    "start_line": 66,
    "end_line": 73,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function start",
    "component_id": "pr_agent.servers.gerrit_server.start"
  },
  "pr_agent.servers.github_action_runner.is_true": {
    "id": "pr_agent.servers.github_action_runner.is_true",
    "name": "is_true",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_action_runner.py",
    "relative_path": "pr_agent/servers/github_action_runner.py",
    "depends_on": [],
    "source_code": "def is_true(value: Union[str, bool]) -> bool:\n    if isinstance(value, bool):\n        return value\n    if isinstance(value, str):\n        return value.lower() == 'true'\n    return False",
    "start_line": 17,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_true",
    "component_id": "pr_agent.servers.github_action_runner.is_true"
  },
  "pr_agent.servers.github_action_runner.get_setting_or_env": {
    "id": "pr_agent.servers.github_action_runner.get_setting_or_env",
    "name": "get_setting_or_env",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_action_runner.py",
    "relative_path": "pr_agent/servers/github_action_runner.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_setting_or_env(key: str, default: Union[str, bool] = None) -> Union[str, bool]:\n    try:\n        value = get_settings().get(key, default)\n    except AttributeError:  # TBD still need to debug why this happens on GitHub Actions\n        value = os.getenv(key, None) or os.getenv(key.upper(), None) or os.getenv(key.lower(), None) or default\n    return value",
    "start_line": 25,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "key",
      "default"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_setting_or_env",
    "component_id": "pr_agent.servers.github_action_runner.get_setting_or_env"
  },
  "pr_agent.servers.github_action_runner.run_action": {
    "id": "pr_agent.servers.github_action_runner.run_action",
    "name": "run_action",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_action_runner.py",
    "relative_path": "pr_agent/servers/github_action_runner.py",
    "depends_on": [
      "pr_agent.tools.pr_description.PRDescription",
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_action_runner.get_setting_or_env",
      "pr_agent.config_loader.get_settings",
      "pr_agent.servers.github_app.handle_line_comments",
      "pr_agent.git_providers.git_provider.add_eyes_reaction",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.tools.pr_reviewer.PRReviewer",
      "pr_agent.cli.run",
      "pr_agent.servers.github_action_runner.is_true",
      "pr_agent.tools.pr_code_suggestions.PRCodeSuggestions",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "async def run_action():\n    # Get environment variables\n    GITHUB_EVENT_NAME = os.environ.get('GITHUB_EVENT_NAME')\n    GITHUB_EVENT_PATH = os.environ.get('GITHUB_EVENT_PATH')\n    OPENAI_KEY = os.environ.get('OPENAI_KEY') or os.environ.get('OPENAI.KEY')\n    OPENAI_ORG = os.environ.get('OPENAI_ORG') or os.environ.get('OPENAI.ORG')\n    GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN')\n    # get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\n\n    # Check if required environment variables are set\n    if not GITHUB_EVENT_NAME:\n        print(\"GITHUB_EVENT_NAME not set\")\n        return\n    if not GITHUB_EVENT_PATH:\n        print(\"GITHUB_EVENT_PATH not set\")\n        return\n    if not GITHUB_TOKEN:\n        print(\"GITHUB_TOKEN not set\")\n        return\n\n    # Set the environment variables in the settings\n    if OPENAI_KEY:\n        get_settings().set(\"OPENAI.KEY\", OPENAI_KEY)\n    else:\n        # Might not be set if the user is using models not from OpenAI\n        print(\"OPENAI_KEY not set\")\n    if OPENAI_ORG:\n        get_settings().set(\"OPENAI.ORG\", OPENAI_ORG)\n    get_settings().set(\"GITHUB.USER_TOKEN\", GITHUB_TOKEN)\n    get_settings().set(\"GITHUB.DEPLOYMENT_TYPE\", \"user\")\n    enable_output = get_setting_or_env(\"GITHUB_ACTION_CONFIG.ENABLE_OUTPUT\", True)\n    get_settings().set(\"GITHUB_ACTION_CONFIG.ENABLE_OUTPUT\", enable_output)\n\n    # Load the event payload\n    try:\n        with open(GITHUB_EVENT_PATH, 'r') as f:\n            event_payload = json.load(f)\n    except json.decoder.JSONDecodeError as e:\n        print(f\"Failed to parse JSON: {e}\")\n        return\n\n    try:\n        get_logger().info(\"Applying repo settings\")\n        pr_url = event_payload.get(\"pull_request\", {}).get(\"html_url\")\n        if pr_url:\n            apply_repo_settings(pr_url)\n            get_logger().info(f\"enable_custom_labels: {get_settings().config.enable_custom_labels}\")\n    except Exception as e:\n        get_logger().info(f\"github action: failed to apply repo settings: {e}\")\n\n    # Handle pull request opened event\n    if GITHUB_EVENT_NAME == \"pull_request\" or GITHUB_EVENT_NAME == \"pull_request_target\":\n        action = event_payload.get(\"action\")\n\n        # Retrieve the list of actions from the configuration\n        pr_actions = get_settings().get(\"GITHUB_ACTION_CONFIG.PR_ACTIONS\", [\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"])\n\n        if action in pr_actions:\n            pr_url = event_payload.get(\"pull_request\", {}).get(\"url\")\n            if pr_url:\n                # legacy - supporting both GITHUB_ACTION and GITHUB_ACTION_CONFIG\n                auto_review = get_setting_or_env(\"GITHUB_ACTION.AUTO_REVIEW\", None)\n                if auto_review is None:\n                    auto_review = get_setting_or_env(\"GITHUB_ACTION_CONFIG.AUTO_REVIEW\", None)\n                auto_describe = get_setting_or_env(\"GITHUB_ACTION.AUTO_DESCRIBE\", None)\n                if auto_describe is None:\n                    auto_describe = get_setting_or_env(\"GITHUB_ACTION_CONFIG.AUTO_DESCRIBE\", None)\n                auto_improve = get_setting_or_env(\"GITHUB_ACTION.AUTO_IMPROVE\", None)\n                if auto_improve is None:\n                    auto_improve = get_setting_or_env(\"GITHUB_ACTION_CONFIG.AUTO_IMPROVE\", None)\n\n                # Set the configuration for auto actions\n                get_settings().config.is_auto_command = True # Set the flag to indicate that the command is auto\n                get_settings().pr_description.final_update_message = False  # No final update message when auto_describe is enabled\n                get_logger().info(f\"Running auto actions: auto_describe={auto_describe}, auto_review={auto_review}, auto_improve={auto_improve}\")\n\n                # invoke by default all three tools\n                if auto_describe is None or is_true(auto_describe):\n                    await PRDescription(pr_url).run()\n                if auto_review is None or is_true(auto_review):\n                    await PRReviewer(pr_url).run()\n                if auto_improve is None or is_true(auto_improve):\n                    await PRCodeSuggestions(pr_url).run()\n        else:\n            get_logger().info(f\"Skipping action: {action}\")\n\n    # Handle issue comment event\n    elif GITHUB_EVENT_NAME == \"issue_comment\" or GITHUB_EVENT_NAME == \"pull_request_review_comment\":\n        action = event_payload.get(\"action\")\n        if action in [\"created\", \"edited\"]:\n            comment_body = event_payload.get(\"comment\", {}).get(\"body\")\n            try:\n                if GITHUB_EVENT_NAME == \"pull_request_review_comment\":\n                    if '/ask' in comment_body:\n                        comment_body = handle_line_comments(event_payload, comment_body)\n            except Exception as e:\n                get_logger().error(f\"Failed to handle line comments: {e}\")\n                return\n            if comment_body:\n                is_pr = False\n                disable_eyes = False\n                # check if issue is pull request\n                if event_payload.get(\"issue\", {}).get(\"pull_request\"):\n                    url = event_payload.get(\"issue\", {}).get(\"pull_request\", {}).get(\"url\")\n                    is_pr = True\n                elif event_payload.get(\"comment\", {}).get(\"pull_request_url\"):  # for 'pull_request_review_comment\n                    url = event_payload.get(\"comment\", {}).get(\"pull_request_url\")\n                    is_pr = True\n                    disable_eyes = True\n                else:\n                    url = event_payload.get(\"issue\", {}).get(\"url\")\n\n                if url:\n                    body = comment_body.strip().lower()\n                    comment_id = event_payload.get(\"comment\", {}).get(\"id\")\n                    provider = get_git_provider()(pr_url=url)\n                    if is_pr:\n                        await PRAgent().handle_request(\n                            url, body, notify=lambda: provider.add_eyes_reaction(\n                                comment_id, disable_eyes=disable_eyes\n                            )\n                        )\n                    else:\n                        await PRAgent().handle_request(url, body)",
    "start_line": 33,
    "end_line": 156,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run_action",
    "component_id": "pr_agent.servers.github_action_runner.run_action"
  },
  "pr_agent.servers.github_app.handle_github_webhooks": {
    "id": "pr_agent.servers.github_app.handle_github_webhooks",
    "name": "handle_github_webhooks",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_app.get_body"
    ],
    "source_code": "async def handle_github_webhooks(background_tasks: BackgroundTasks, request: Request, response: Response):\n    \"\"\"\n    Receives and processes incoming GitHub webhook requests.\n    Verifies the request signature, parses the request body, and passes it to the handle_request function for further\n    processing.\n    \"\"\"\n    get_logger().debug(\"Received a GitHub webhook\")\n\n    body = await get_body(request)\n\n    installation_id = body.get(\"installation\", {}).get(\"id\")\n    context[\"installation_id\"] = installation_id\n    context[\"settings\"] = copy.deepcopy(global_settings)\n    context[\"git_provider\"] = {}\n    background_tasks.add_task(handle_request, body, event=request.headers.get(\"X-GitHub-Event\", None))\n    return {}",
    "start_line": 39,
    "end_line": 54,
    "has_docstring": true,
    "docstring": "Receives and processes incoming GitHub webhook requests.\nVerifies the request signature, parses the request body, and passes it to the handle_request function for further\nprocessing.",
    "parameters": [
      "background_tasks",
      "request",
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_github_webhooks",
    "component_id": "pr_agent.servers.github_app.handle_github_webhooks"
  },
  "pr_agent.servers.github_app.handle_marketplace_webhooks": {
    "id": "pr_agent.servers.github_app.handle_marketplace_webhooks",
    "name": "handle_marketplace_webhooks",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_app.get_body"
    ],
    "source_code": "async def handle_marketplace_webhooks(request: Request, response: Response):\n    body = await get_body(request)\n    get_logger().info(f'Request body:\\n{body}')",
    "start_line": 58,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request",
      "response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_marketplace_webhooks",
    "component_id": "pr_agent.servers.github_app.handle_marketplace_webhooks"
  },
  "pr_agent.servers.github_app.get_body": {
    "id": "pr_agent.servers.github_app.get_body",
    "name": "get_body",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.utils.verify_signature"
    ],
    "source_code": "async def get_body(request):\n    try:\n        body = await request.json()\n    except Exception as e:\n        get_logger().error(\"Error parsing request body\", artifact={'error': e})\n        raise HTTPException(status_code=400, detail=\"Error parsing request body\") from e\n    webhook_secret = getattr(get_settings().github, 'webhook_secret', None)\n    if webhook_secret:\n        body_bytes = await request.body()\n        signature_header = request.headers.get('x-hub-signature-256', None)\n        verify_signature(body_bytes, webhook_secret, signature_header)\n    return body",
    "start_line": 63,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "request"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_body",
    "component_id": "pr_agent.servers.github_app.get_body"
  },
  "pr_agent.servers.github_app.handle_comments_on_pr": {
    "id": "pr_agent.servers.github_app.handle_comments_on_pr",
    "name": "handle_comments_on_pr",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_app.handle_line_comments",
      "pr_agent.git_providers.git_provider.add_eyes_reaction",
      "pr_agent.identity_providers.__init__.get_identity_provider",
      "pr_agent.git_providers.__init__.get_git_provider_with_context",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "async def handle_comments_on_pr(body: Dict[str, Any],\n                                event: str,\n                                sender: str,\n                                sender_id: str,\n                                action: str,\n                                log_context: Dict[str, Any],\n                                agent: PRAgent):\n    if \"comment\" not in body:\n        return {}\n    comment_body = body.get(\"comment\", {}).get(\"body\")\n    if comment_body and isinstance(comment_body, str) and not comment_body.lstrip().startswith(\"/\"):\n        if '/ask' in comment_body and comment_body.strip().startswith('> ![image]'):\n            comment_body_split = comment_body.split('/ask')\n            comment_body = '/ask' + comment_body_split[1] +' \\n' +comment_body_split[0].strip().lstrip('>')\n            get_logger().info(f\"Reformatting comment_body so command is at the beginning: {comment_body}\")\n        else:\n            get_logger().info(\"Ignoring comment not starting with /\")\n            return {}\n    disable_eyes = False\n    if \"issue\" in body and \"pull_request\" in body[\"issue\"] and \"url\" in body[\"issue\"][\"pull_request\"]:\n        api_url = body[\"issue\"][\"pull_request\"][\"url\"]\n    elif \"comment\" in body and \"pull_request_url\" in body[\"comment\"]:\n        api_url = body[\"comment\"][\"pull_request_url\"]\n        try:\n            if ('/ask' in comment_body and\n                    'subject_type' in body[\"comment\"] and body[\"comment\"][\"subject_type\"] == \"line\"):\n                # comment on a code line in the \"files changed\" tab\n                comment_body = handle_line_comments(body, comment_body)\n                disable_eyes = True\n        except Exception as e:\n            get_logger().error(\"Failed to get log context\", artifact={'error': e})\n    else:\n        return {}\n    log_context[\"api_url\"] = api_url\n    comment_id = body.get(\"comment\", {}).get(\"id\")\n    provider = get_git_provider_with_context(pr_url=api_url)\n    with get_logger().contextualize(**log_context):\n        if get_identity_provider().verify_eligibility(\"github\", sender_id, api_url) is not Eligibility.NOT_ELIGIBLE:\n            get_logger().info(f\"Processing comment on PR {api_url=}, comment_body={comment_body}\")\n            await agent.handle_request(api_url, comment_body,\n                        notify=lambda: provider.add_eyes_reaction(comment_id, disable_eyes=disable_eyes))\n        else:\n            get_logger().info(f\"User {sender=} is not eligible to process comment on PR {api_url=}\")",
    "start_line": 80,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "event",
      "sender",
      "sender_id",
      "action",
      "log_context",
      "agent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_comments_on_pr",
    "component_id": "pr_agent.servers.github_app.handle_comments_on_pr"
  },
  "pr_agent.servers.github_app.handle_new_pr_opened": {
    "id": "pr_agent.servers.github_app.handle_new_pr_opened",
    "name": "handle_new_pr_opened",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.servers.github_app._check_pull_request_event",
      "pr_agent.config_loader.get_settings",
      "pr_agent.identity_providers.__init__.get_identity_provider",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_app._perform_auto_commands_github"
    ],
    "source_code": "async def handle_new_pr_opened(body: Dict[str, Any],\n                               event: str,\n                               sender: str,\n                               sender_id: str,\n                               action: str,\n                               log_context: Dict[str, Any],\n                               agent: PRAgent):\n    title = body.get(\"pull_request\", {}).get(\"title\", \"\")\n\n    pull_request, api_url = _check_pull_request_event(action, body, log_context)\n    if not (pull_request and api_url):\n        get_logger().info(f\"Invalid PR event: {action=} {api_url=}\")\n        return {}\n    if action in get_settings().github_app.handle_pr_actions:  # ['opened', 'reopened', 'ready_for_review']\n        # logic to ignore PRs with specific titles (e.g. \"[Auto] ...\")\n        apply_repo_settings(api_url)\n        if get_identity_provider().verify_eligibility(\"github\", sender_id, api_url) is not Eligibility.NOT_ELIGIBLE:\n            await _perform_auto_commands_github(\"pr_commands\", agent, body, api_url, log_context)\n        else:\n            get_logger().info(f\"User {sender=} is not eligible to process PR {api_url=}\")",
    "start_line": 124,
    "end_line": 143,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "event",
      "sender",
      "sender_id",
      "action",
      "log_context",
      "agent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_new_pr_opened",
    "component_id": "pr_agent.servers.github_app.handle_new_pr_opened"
  },
  "pr_agent.servers.github_app.handle_push_trigger_for_new_commits": {
    "id": "pr_agent.servers.github_app.handle_push_trigger_for_new_commits",
    "name": "handle_push_trigger_for_new_commits",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.servers.github_app._check_pull_request_event",
      "pr_agent.config_loader.get_settings",
      "pr_agent.identity_providers.__init__.get_identity_provider",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_app._perform_auto_commands_github"
    ],
    "source_code": "async def handle_push_trigger_for_new_commits(body: Dict[str, Any],\n                        event: str,\n                        sender: str,\n                        sender_id: str,\n                        action: str,\n                        log_context: Dict[str, Any],\n                        agent: PRAgent):\n    pull_request, api_url = _check_pull_request_event(action, body, log_context)\n    if not (pull_request and api_url):\n        return {}\n\n    apply_repo_settings(api_url) # we need to apply the repo settings to get the correct settings for the PR. This is quite expensive - a call to the git provider is made for each PR event.\n    if not get_settings().github_app.handle_push_trigger:\n        return {}\n\n    # TODO: do we still want to get the list of commits to filter bot/merge commits?\n    before_sha = body.get(\"before\")\n    after_sha = body.get(\"after\")\n    merge_commit_sha = pull_request.get(\"merge_commit_sha\")\n    if before_sha == after_sha:\n        return {}\n    if get_settings().github_app.push_trigger_ignore_merge_commits and after_sha == merge_commit_sha:\n        return {}\n\n    # Prevent triggering multiple times for subsequent push triggers when one is enough:\n    # The first push will trigger the processing, and if there's a second push in the meanwhile it will wait.\n    # Any more events will be discarded, because they will all trigger the exact same processing on the PR.\n    # We let the second event wait instead of discarding it because while the first event was being processed,\n    # more commits may have been pushed that led to the subsequent events,\n    # so we keep just one waiting as a delegate to trigger the processing for the new commits when done waiting.\n    current_active_tasks = _duplicate_push_triggers.setdefault(api_url, 0)\n    max_active_tasks = 2 if get_settings().github_app.push_trigger_pending_tasks_backlog else 1\n    if current_active_tasks < max_active_tasks:\n        # first task can enter, and second tasks too if backlog is enabled\n        get_logger().info(\n            f\"Continue processing push trigger for {api_url=} because there are {current_active_tasks} active tasks\"\n        )\n        _duplicate_push_triggers[api_url] += 1\n    else:\n        get_logger().info(\n            f\"Skipping push trigger for {api_url=} because another event already triggered the same processing\"\n        )\n        return {}\n    async with _pending_task_duplicate_push_conditions[api_url]:\n        if current_active_tasks == 1:\n            # second task waits\n            get_logger().info(\n                f\"Waiting to process push trigger for {api_url=} because the first task is still in progress\"\n            )\n            await _pending_task_duplicate_push_conditions[api_url].wait()\n            get_logger().info(f\"Finished waiting to process push trigger for {api_url=} - continue with flow\")\n\n    try:\n        if get_identity_provider().verify_eligibility(\"github\", sender_id, api_url) is not Eligibility.NOT_ELIGIBLE:\n            get_logger().info(f\"Performing incremental review for {api_url=} because of {event=} and {action=}\")\n            await _perform_auto_commands_github(\"push_commands\", agent, body, api_url, log_context)\n\n    finally:\n        # release the waiting task block\n        async with _pending_task_duplicate_push_conditions[api_url]:\n            _pending_task_duplicate_push_conditions[api_url].notify(1)\n            _duplicate_push_triggers[api_url] -= 1",
    "start_line": 145,
    "end_line": 206,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "event",
      "sender",
      "sender_id",
      "action",
      "log_context",
      "agent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_push_trigger_for_new_commits",
    "component_id": "pr_agent.servers.github_app.handle_push_trigger_for_new_commits"
  },
  "pr_agent.servers.github_app.handle_closed_pr": {
    "id": "pr_agent.servers.github_app.handle_closed_pr",
    "name": "handle_closed_pr",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.calc_pr_statistics",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "def handle_closed_pr(body, event, action, log_context):\n    pull_request = body.get(\"pull_request\", {})\n    is_merged = pull_request.get(\"merged\", False)\n    if not is_merged:\n        return\n    api_url = pull_request.get(\"url\", \"\")\n    pr_statistics = get_git_provider()(pr_url=api_url).calc_pr_statistics(pull_request)\n    log_context[\"api_url\"] = api_url\n    get_logger().info(\"PR-Agent statistics for closed PR\", analytics=True, pr_statistics=pr_statistics, **log_context)",
    "start_line": 209,
    "end_line": 217,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "event",
      "action",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_closed_pr",
    "component_id": "pr_agent.servers.github_app.handle_closed_pr"
  },
  "pr_agent.servers.github_app.get_log_context": {
    "id": "pr_agent.servers.github_app.get_log_context",
    "name": "get_log_context",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_log_context(body, event, action, build_number):\n    sender = \"\"\n    sender_id = \"\"\n    sender_type = \"\"\n    try:\n        sender = body.get(\"sender\", {}).get(\"login\")\n        sender_id = body.get(\"sender\", {}).get(\"id\")\n        sender_type = body.get(\"sender\", {}).get(\"type\")\n        repo = body.get(\"repository\", {}).get(\"full_name\", \"\")\n        git_org = body.get(\"organization\", {}).get(\"login\", \"\")\n        installation_id = body.get(\"installation\", {}).get(\"id\", \"\")\n        app_name = get_settings().get(\"CONFIG.APP_NAME\", \"Unknown\")\n        log_context = {\"action\": action, \"event\": event, \"sender\": sender, \"server_type\": \"github_app\",\n                       \"request_id\": uuid.uuid4().hex, \"build_number\": build_number, \"app_name\": app_name,\n                        \"repo\": repo, \"git_org\": git_org, \"installation_id\": installation_id}\n    except Exception as e:\n        get_logger().error(f\"Failed to get log context\", artifact={'error': e})\n        log_context = {}\n    return log_context, sender, sender_id, sender_type",
    "start_line": 220,
    "end_line": 238,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "event",
      "action",
      "build_number"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_log_context",
    "component_id": "pr_agent.servers.github_app.get_log_context"
  },
  "pr_agent.servers.github_app.is_bot_user": {
    "id": "pr_agent.servers.github_app.is_bot_user",
    "name": "is_bot_user",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def is_bot_user(sender, sender_type):\n    try:\n        # logic to ignore PRs opened by bot\n        if get_settings().get(\"GITHUB_APP.IGNORE_BOT_PR\", False) and sender_type == \"Bot\":\n            if 'pr-agent' not in sender:\n                get_logger().info(f\"Ignoring PR from '{sender=}' because it is a bot\")\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_bot_user' logic: {e}\")\n    return False",
    "start_line": 241,
    "end_line": 250,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sender",
      "sender_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_bot_user",
    "component_id": "pr_agent.servers.github_app.is_bot_user"
  },
  "pr_agent.servers.github_app.should_process_pr_logic": {
    "id": "pr_agent.servers.github_app.should_process_pr_logic",
    "name": "should_process_pr_logic",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def should_process_pr_logic(body) -> bool:\n    try:\n        pull_request = body.get(\"pull_request\", {})\n        title = pull_request.get(\"title\", \"\")\n        pr_labels = pull_request.get(\"labels\", [])\n        source_branch = pull_request.get(\"head\", {}).get(\"ref\", \"\")\n        target_branch = pull_request.get(\"base\", {}).get(\"ref\", \"\")\n        sender = body.get(\"sender\", {}).get(\"login\")\n\n        # logic to ignore PRs from specific users\n        ignore_pr_users = get_settings().get(\"CONFIG.IGNORE_PR_AUTHORS\", [])\n        if ignore_pr_users and sender:\n            if sender in ignore_pr_users:\n                get_logger().info(f\"Ignoring PR from user '{sender}' due to 'config.ignore_pr_authors' setting\")\n                return False\n\n        # logic to ignore PRs with specific titles\n        if title:\n            ignore_pr_title_re = get_settings().get(\"CONFIG.IGNORE_PR_TITLE\", [])\n            if not isinstance(ignore_pr_title_re, list):\n                ignore_pr_title_re = [ignore_pr_title_re]\n            if ignore_pr_title_re and any(re.search(regex, title) for regex in ignore_pr_title_re):\n                get_logger().info(f\"Ignoring PR with title '{title}' due to config.ignore_pr_title setting\")\n                return False\n\n        # logic to ignore PRs with specific labels or source branches or target branches.\n        ignore_pr_labels = get_settings().get(\"CONFIG.IGNORE_PR_LABELS\", [])\n        if pr_labels and ignore_pr_labels:\n            labels = [label['name'] for label in pr_labels]\n            if any(label in ignore_pr_labels for label in labels):\n                labels_str = \", \".join(labels)\n                get_logger().info(f\"Ignoring PR with labels '{labels_str}' due to config.ignore_pr_labels settings\")\n                return False\n\n        # logic to ignore PRs with specific source or target branches\n        ignore_pr_source_branches = get_settings().get(\"CONFIG.IGNORE_PR_SOURCE_BRANCHES\", [])\n        ignore_pr_target_branches = get_settings().get(\"CONFIG.IGNORE_PR_TARGET_BRANCHES\", [])\n        if pull_request and (ignore_pr_source_branches or ignore_pr_target_branches):\n            if any(re.search(regex, source_branch) for regex in ignore_pr_source_branches):\n                get_logger().info(\n                    f\"Ignoring PR with source branch '{source_branch}' due to config.ignore_pr_source_branches settings\")\n                return False\n            if any(re.search(regex, target_branch) for regex in ignore_pr_target_branches):\n                get_logger().info(\n                    f\"Ignoring PR with target branch '{target_branch}' due to config.ignore_pr_target_branches settings\")\n                return False\n    except Exception as e:\n        get_logger().error(f\"Failed 'should_process_pr_logic': {e}\")\n    return True",
    "start_line": 253,
    "end_line": 301,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function should_process_pr_logic",
    "component_id": "pr_agent.servers.github_app.should_process_pr_logic"
  },
  "pr_agent.servers.github_app.handle_request": {
    "id": "pr_agent.servers.github_app.handle_request",
    "name": "handle_request",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.servers.github_app.get_log_context",
      "pr_agent.servers.github_app.should_process_pr_logic",
      "pr_agent.servers.github_app.handle_new_pr_opened",
      "pr_agent.servers.github_app.handle_push_trigger_for_new_commits",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.github_app.is_bot_user",
      "pr_agent.config_loader.get_settings",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.servers.github_app.handle_closed_pr",
      "pr_agent.servers.github_app.handle_comments_on_pr"
    ],
    "source_code": "async def handle_request(body: Dict[str, Any], event: str):\n    \"\"\"\n    Handle incoming GitHub webhook requests.\n\n    Args:\n        body: The request body.\n        event: The GitHub event type (e.g. \"pull_request\", \"issue_comment\", etc.).\n    \"\"\"\n    action = body.get(\"action\")  # \"created\", \"opened\", \"reopened\", \"ready_for_review\", \"review_requested\", \"synchronize\"\n    get_logger().debug(f\"Handling request with event: {event}, action: {action}\")\n    if not action:\n        get_logger().debug(f\"No action found in request body, exiting handle_request\")\n        return {}\n    agent = PRAgent()\n    log_context, sender, sender_id, sender_type = get_log_context(body, event, action, build_number)\n\n    # logic to ignore PRs opened by bot, PRs with specific titles, labels, source branches, or target branches\n    if is_bot_user(sender, sender_type) and 'check_run' not in body:\n        get_logger().debug(f\"Request ignored: bot user detected\")\n        return {}\n    if action != 'created' and 'check_run' not in body:\n        if not should_process_pr_logic(body):\n            get_logger().debug(f\"Request ignored: PR logic filtering\")\n            return {}\n\n    if 'check_run' in body:  # handle failed checks\n        # get_logger().debug(f'Request body', artifact=body, event=event) # added inside handle_checks\n        pass\n    # handle comments on PRs\n    elif action == 'created':\n        get_logger().debug(f'Request body', artifact=body, event=event)\n        await handle_comments_on_pr(body, event, sender, sender_id, action, log_context, agent)\n    # handle new PRs\n    elif event == 'pull_request' and action != 'synchronize' and action != 'closed':\n        get_logger().debug(f'Request body', artifact=body, event=event)\n        await handle_new_pr_opened(body, event, sender, sender_id, action, log_context, agent)\n    elif event == \"issue_comment\" and 'edited' in action:\n        pass # handle_checkbox_clicked\n    # handle pull_request event with synchronize action - \"push trigger\" for new commits\n    elif event == 'pull_request' and action == 'synchronize':\n        await handle_push_trigger_for_new_commits(body, event, sender,sender_id,  action, log_context, agent)\n    elif event == 'pull_request' and action == 'closed':\n        if get_settings().get(\"CONFIG.ANALYTICS_FOLDER\", \"\"):\n            handle_closed_pr(body, event, action, log_context)\n    else:\n        get_logger().info(f\"event {event=} action {action=} does not require any handling\")\n    return {}",
    "start_line": 304,
    "end_line": 350,
    "has_docstring": true,
    "docstring": "Handle incoming GitHub webhook requests.\n\nArgs:\n    body: The request body.\n    event: The GitHub event type (e.g. \"pull_request\", \"issue_comment\", etc.).",
    "parameters": [
      "body",
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_request",
    "component_id": "pr_agent.servers.github_app.handle_request"
  },
  "pr_agent.servers.github_app.handle_line_comments": {
    "id": "pr_agent.servers.github_app.handle_line_comments",
    "name": "handle_line_comments",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def handle_line_comments(body: Dict, comment_body: [str, Any]) -> str:\n    if not comment_body:\n        return \"\"\n    start_line = body[\"comment\"][\"start_line\"]\n    end_line = body[\"comment\"][\"line\"]\n    start_line = end_line if not start_line else start_line\n    question = comment_body.replace('/ask', '').strip()\n    diff_hunk = body[\"comment\"][\"diff_hunk\"]\n    get_settings().set(\"ask_diff_hunk\", diff_hunk)\n    path = body[\"comment\"][\"path\"]\n    side = body[\"comment\"][\"side\"]\n    comment_id = body[\"comment\"][\"id\"]\n    if '/ask' in comment_body:\n        comment_body = f\"/ask_line --line_start={start_line} --line_end={end_line} --side={side} --file_name={path} --comment_id={comment_id} {question}\"\n    return comment_body",
    "start_line": 353,
    "end_line": 367,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "comment_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_line_comments",
    "component_id": "pr_agent.servers.github_app.handle_line_comments"
  },
  "pr_agent.servers.github_app._check_pull_request_event": {
    "id": "pr_agent.servers.github_app._check_pull_request_event",
    "name": "_check_pull_request_event",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [],
    "source_code": "def _check_pull_request_event(action: str, body: dict, log_context: dict) -> Tuple[Dict[str, Any], str]:\n    invalid_result = {}, \"\"\n    pull_request = body.get(\"pull_request\")\n    if not pull_request:\n        return invalid_result\n    api_url = pull_request.get(\"url\")\n    if not api_url:\n        return invalid_result\n    log_context[\"api_url\"] = api_url\n    if pull_request.get(\"draft\", True) or pull_request.get(\"state\") != \"open\":\n        return invalid_result\n    if action in (\"review_requested\", \"synchronize\") and pull_request.get(\"created_at\") == pull_request.get(\"updated_at\"):\n        # avoid double reviews when opening a PR for the first time\n        return invalid_result\n    return pull_request, api_url",
    "start_line": 370,
    "end_line": 384,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "action",
      "body",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _check_pull_request_event",
    "component_id": "pr_agent.servers.github_app._check_pull_request_event"
  },
  "pr_agent.servers.github_app._perform_auto_commands_github": {
    "id": "pr_agent.servers.github_app._perform_auto_commands_github",
    "name": "_perform_auto_commands_github",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.servers.github_app.should_process_pr_logic",
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.update_settings_from_args",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "async def _perform_auto_commands_github(commands_conf: str, agent: PRAgent, body: dict, api_url: str,\n                                        log_context: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\")\n        return\n    if not should_process_pr_logic(body): # Here we already updated the configuration with the repo settings\n        return {}\n    commands = get_settings().get(f\"github_app.{commands_conf}\")\n    if not commands:\n        get_logger().info(f\"New PR, but no auto commands configured\")\n        return\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        split_command = command.split(\" \")\n        command = split_command[0]\n        args = split_command[1:]\n        other_args = update_settings_from_args(args)\n        new_command = ' '.join([command] + other_args)\n        get_logger().info(f\"{commands_conf}. Performing auto command '{new_command}', for {api_url=}\")\n        await agent.handle_request(api_url, new_command)",
    "start_line": 387,
    "end_line": 407,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands_conf",
      "agent",
      "body",
      "api_url",
      "log_context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _perform_auto_commands_github",
    "component_id": "pr_agent.servers.github_app._perform_auto_commands_github"
  },
  "pr_agent.servers.github_app.root": {
    "id": "pr_agent.servers.github_app.root",
    "name": "root",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [],
    "source_code": "async def root():\n    return {\"status\": \"ok\"}",
    "start_line": 411,
    "end_line": 412,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function root",
    "component_id": "pr_agent.servers.github_app.root"
  },
  "pr_agent.servers.github_app.start": {
    "id": "pr_agent.servers.github_app.start",
    "name": "start",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_app.py",
    "relative_path": "pr_agent/servers/github_app.py",
    "depends_on": [
      "pr_agent.cli.run"
    ],
    "source_code": "def start():\n    uvicorn.run(app, host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", \"3000\")))",
    "start_line": 424,
    "end_line": 425,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function start",
    "component_id": "pr_agent.servers.github_app.start"
  },
  "pr_agent.servers.github_polling.mark_notification_as_read": {
    "id": "pr_agent.servers.github_polling.mark_notification_as_read",
    "name": "mark_notification_as_read",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "async def mark_notification_as_read(headers, notification, session):\n    async with session.patch(\n            f\"https://api.github.com/notifications/threads/{notification['id']}\",\n            headers=headers) as mark_read_response:\n        if mark_read_response.status != 205:\n            get_logger().error(\n                f\"Failed to mark notification as read. Status code: {mark_read_response.status}\")",
    "start_line": 20,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "headers",
      "notification",
      "session"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function mark_notification_as_read",
    "component_id": "pr_agent.servers.github_polling.mark_notification_as_read"
  },
  "pr_agent.servers.github_polling.now": {
    "id": "pr_agent.servers.github_polling.now",
    "name": "now",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.servers.github_polling.now"
    ],
    "source_code": "def now() -> str:\n    \"\"\"\n    Get the current UTC time in ISO 8601 format.\n\n    Returns:\n        str: The current UTC time in ISO 8601 format.\n    \"\"\"\n    now_utc = datetime.now(timezone.utc).isoformat()\n    now_utc = now_utc.replace(\"+00:00\", \"Z\")\n    return now_utc",
    "start_line": 29,
    "end_line": 38,
    "has_docstring": true,
    "docstring": "Get the current UTC time in ISO 8601 format.\n\nReturns:\n    str: The current UTC time in ISO 8601 format.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function now",
    "component_id": "pr_agent.servers.github_polling.now"
  },
  "pr_agent.servers.github_polling.async_handle_request": {
    "id": "pr_agent.servers.github_polling.async_handle_request",
    "name": "async_handle_request",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.add_eyes_reaction",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.agent.pr_agent.PRAgent"
    ],
    "source_code": "async def async_handle_request(pr_url, rest_of_comment, comment_id, git_provider):\n    agent = PRAgent()\n    success = await agent.handle_request(\n        pr_url,\n        rest_of_comment,\n        notify=lambda: git_provider.add_eyes_reaction(comment_id)\n    )\n    return success",
    "start_line": 40,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_url",
      "rest_of_comment",
      "comment_id",
      "git_provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function async_handle_request",
    "component_id": "pr_agent.servers.github_polling.async_handle_request"
  },
  "pr_agent.servers.github_polling.run_handle_request": {
    "id": "pr_agent.servers.github_polling.run_handle_request",
    "name": "run_handle_request",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.servers.github_polling.async_handle_request",
      "pr_agent.cli.run"
    ],
    "source_code": "def run_handle_request(pr_url, rest_of_comment, comment_id, git_provider):\n    return asyncio.run(async_handle_request(pr_url, rest_of_comment, comment_id, git_provider))",
    "start_line": 49,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_url",
      "rest_of_comment",
      "comment_id",
      "git_provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run_handle_request",
    "component_id": "pr_agent.servers.github_polling.run_handle_request"
  },
  "pr_agent.servers.github_polling.process_comment_sync": {
    "id": "pr_agent.servers.github_polling.process_comment_sync",
    "name": "process_comment_sync",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.servers.github_polling.run_handle_request",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "def process_comment_sync(pr_url, rest_of_comment, comment_id):\n    try:\n        # Run the async handle_request in a separate function\n        git_provider = get_git_provider()(pr_url=pr_url)\n        success = run_handle_request(pr_url, rest_of_comment, comment_id, git_provider)\n    except Exception as e:\n        get_logger().error(f\"Error processing comment: {e}\", artifact={\"traceback\": traceback.format_exc()})",
    "start_line": 53,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_url",
      "rest_of_comment",
      "comment_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_comment_sync",
    "component_id": "pr_agent.servers.github_polling.process_comment_sync"
  },
  "pr_agent.servers.github_polling.process_comment": {
    "id": "pr_agent.servers.github_polling.process_comment",
    "name": "process_comment",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.add_eyes_reaction",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "async def process_comment(pr_url, rest_of_comment, comment_id):\n    try:\n        git_provider = get_git_provider()(pr_url=pr_url)\n        git_provider.set_pr(pr_url)\n        agent = PRAgent()\n        success = await agent.handle_request(\n            pr_url,\n            rest_of_comment,\n            notify=lambda: git_provider.add_eyes_reaction(comment_id)\n        )\n        get_logger().info(f\"Finished processing comment for PR: {pr_url}\")\n    except Exception as e:\n        get_logger().error(f\"Error processing comment: {e}\", artifact={\"traceback\": traceback.format_exc()})",
    "start_line": 62,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "pr_url",
      "rest_of_comment",
      "comment_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_comment",
    "component_id": "pr_agent.servers.github_polling.process_comment"
  },
  "pr_agent.servers.github_polling.is_valid_notification": {
    "id": "pr_agent.servers.github_polling.is_valid_notification",
    "name": "is_valid_notification",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "async def is_valid_notification(notification, headers, handled_ids, session, user_id):\n    try:\n        if 'reason' in notification and notification['reason'] == 'mention':\n            if 'subject' in notification and notification['subject']['type'] == 'PullRequest':\n                pr_url = notification['subject']['url']\n                latest_comment = notification['subject']['latest_comment_url']\n                if not latest_comment or not isinstance(latest_comment, str):\n                    get_logger().debug(f\"no latest_comment\")\n                    return False, handled_ids\n                async with session.get(latest_comment, headers=headers) as comment_response:\n                    check_prev_comments = False\n                    user_tag = \"@\" + user_id\n                    if comment_response.status == 200:\n                        comment = await comment_response.json()\n                        if 'id' in comment:\n                            if comment['id'] in handled_ids:\n                                get_logger().debug(f\"comment['id'] in handled_ids\")\n                                return False, handled_ids\n                            else:\n                                handled_ids.add(comment['id'])\n                        if 'user' in comment and 'login' in comment['user']:\n                            if comment['user']['login'] == user_id:\n                                get_logger().debug(f\"comment['user']['login'] == user_id\")\n                                check_prev_comments = True\n                        comment_body = comment.get('body', '')\n                        if not comment_body:\n                            get_logger().debug(f\"no comment_body\")\n                            check_prev_comments = True\n                        else:\n                            if user_tag not in comment_body:\n                                get_logger().debug(f\"user_tag not in comment_body\")\n                                check_prev_comments = True\n                            else:\n                                get_logger().info(f\"Polling, pr_url: {pr_url}\",\n                                                  artifact={\"comment\": comment_body})\n\n                        if not check_prev_comments:\n                            return True, handled_ids, comment, comment_body, pr_url, user_tag\n                        else: # we could not find the user tag in the latest comment. Check previous comments\n                            # get all comments in the PR\n                            requests_url = f\"{pr_url}/comments\".replace(\"pulls\", \"issues\")\n                            comments_response = requests.get(requests_url, headers=headers)\n                            comments = comments_response.json()[::-1]\n                            max_comment_to_scan = 4\n                            for comment in comments[:max_comment_to_scan]:\n                                if 'user' in comment and 'login' in comment['user']:\n                                    if comment['user']['login'] == user_id:\n                                        continue\n                                comment_body = comment.get('body', '')\n                                if not comment_body:\n                                    continue\n                                if user_tag in comment_body:\n                                    get_logger().info(\"found user tag in previous comments\")\n                                    get_logger().info(f\"Polling, pr_url: {pr_url}\",\n                                                      artifact={\"comment\": comment_body})\n                                    return True, handled_ids, comment, comment_body, pr_url, user_tag\n\n                            get_logger().warning(f\"Failed to fetch comments for PR: {pr_url}\",\n                                                    artifact={\"comments\": comments})\n                            return False, handled_ids\n\n        return False, handled_ids\n    except Exception as e:\n        get_logger().exception(f\"Error processing polling notification\",\n                               artifact={\"notification\": notification, \"error\": e})\n        return False, handled_ids",
    "start_line": 76,
    "end_line": 141,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "notification",
      "headers",
      "handled_ids",
      "session",
      "user_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_valid_notification",
    "component_id": "pr_agent.servers.github_polling.is_valid_notification"
  },
  "pr_agent.servers.github_polling.polling_loop": {
    "id": "pr_agent.servers.github_polling.polling_loop",
    "name": "polling_loop",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/github_polling.py",
    "relative_path": "pr_agent/servers/github_polling.py",
    "depends_on": [
      "pr_agent.servers.github_polling.now",
      "pr_agent.servers.github_polling.mark_notification_as_read",
      "pr_agent.servers.gitlab_webhook.start",
      "pr_agent.servers.github_polling.is_valid_notification",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.get_user_id",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "async def polling_loop():\n    \"\"\"\n    Polls for notifications and handles them accordingly.\n    \"\"\"\n    handled_ids = set()\n    since = [now()]\n    last_modified = [None]\n    git_provider = get_git_provider()()\n    user_id = git_provider.get_user_id()\n    get_settings().set(\"CONFIG.PUBLISH_OUTPUT_PROGRESS\", False)\n    get_settings().set(\"pr_description.publish_description_as_comment\", True)\n\n    try:\n        deployment_type = get_settings().github.deployment_type\n        token = get_settings().github.user_token\n    except AttributeError:\n        deployment_type = 'none'\n        token = None\n\n    if deployment_type != 'user':\n        raise ValueError(\"Deployment mode must be set to 'user' to get notifications\")\n    if not token:\n        raise ValueError(\"User token must be set to get notifications\")\n\n    async with aiohttp.ClientSession() as session:\n        while True:\n            try:\n                await asyncio.sleep(5)\n                headers = {\n                    \"Accept\": \"application/vnd.github.v3+json\",\n                    \"Authorization\": f\"Bearer {token}\"\n                }\n                params = {\n                    \"participating\": \"true\"\n                }\n                if since[0]:\n                    params[\"since\"] = since[0]\n                if last_modified[0]:\n                    headers[\"If-Modified-Since\"] = last_modified[0]\n\n                async with session.get(NOTIFICATION_URL, headers=headers, params=params) as response:\n                    if response.status == 200:\n                        if 'Last-Modified' in response.headers:\n                            last_modified[0] = response.headers['Last-Modified']\n                            since[0] = None\n                        notifications = await response.json()\n                        if not notifications:\n                            continue\n                        get_logger().info(f\"Received {len(notifications)} notifications\")\n                        task_queue = deque()\n                        for notification in notifications:\n                            if not notification:\n                                continue\n                            # mark notification as read\n                            await mark_notification_as_read(headers, notification, session)\n\n                            handled_ids.add(notification['id'])\n                            output = await is_valid_notification(notification, headers, handled_ids, session, user_id)\n                            if output[0]:\n                                _, handled_ids, comment, comment_body, pr_url, user_tag = output\n                                rest_of_comment = comment_body.split(user_tag)[1].strip()\n                                comment_id = comment['id']\n\n                                # Add to the task queue\n                                get_logger().info(\n                                    f\"Adding comment processing to task queue for PR, {pr_url}, comment_body: {comment_body}\")\n                                task_queue.append((process_comment_sync, (pr_url, rest_of_comment, comment_id)))\n                                get_logger().info(f\"Queued comment processing for PR: {pr_url}\")\n                            else:\n                                get_logger().debug(f\"Skipping comment processing for PR\")\n\n                        max_allowed_parallel_tasks = 10\n                        if task_queue:\n                            processes = []\n                            for i, (func, args) in enumerate(task_queue):  # Create  parallel tasks\n                                p = multiprocessing.Process(target=func, args=args)\n                                processes.append(p)\n                                p.start()\n                                if i > max_allowed_parallel_tasks:\n                                    get_logger().error(\n                                        f\"Dropping {len(task_queue) - max_allowed_parallel_tasks} tasks from polling session\")\n                                    break\n                            task_queue.clear()\n\n                            # Dont wait for all processes to complete. Move on to the next iteration\n                            # for p in processes:\n                            #     p.join()\n\n                    elif response.status != 304:\n                        print(f\"Failed to fetch notifications. Status code: {response.status}\")\n\n            except Exception as e:\n                get_logger().error(f\"Polling exception during processing of a notification: {e}\",\n                                   artifact={\"traceback\": traceback.format_exc()})",
    "start_line": 145,
    "end_line": 238,
    "has_docstring": true,
    "docstring": "Polls for notifications and handles them accordingly.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function polling_loop",
    "component_id": "pr_agent.servers.github_polling.polling_loop"
  },
  "pr_agent.servers.gitlab_webhook.handle_request": {
    "id": "pr_agent.servers.gitlab_webhook.handle_request",
    "name": "handle_request",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.config_loader.get_settings",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "async def handle_request(api_url: str, body: str, log_context: dict, sender_id: str):\n    log_context[\"action\"] = body\n    log_context[\"event\"] = \"pull_request\" if body == \"/review\" else \"comment\"\n    log_context[\"api_url\"] = api_url\n    log_context[\"app_name\"] = get_settings().get(\"CONFIG.APP_NAME\", \"Unknown\")\n\n    with get_logger().contextualize(**log_context):\n        await PRAgent().handle_request(api_url, body)",
    "start_line": 28,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "api_url",
      "body",
      "log_context",
      "sender_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_request",
    "component_id": "pr_agent.servers.gitlab_webhook.handle_request"
  },
  "pr_agent.servers.gitlab_webhook._perform_commands_gitlab": {
    "id": "pr_agent.servers.gitlab_webhook._perform_commands_gitlab",
    "name": "_perform_commands_gitlab",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.servers.gitlab_webhook.should_process_pr_logic",
      "pr_agent.git_providers.utils.apply_repo_settings",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.update_settings_from_args",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "async def _perform_commands_gitlab(commands_conf: str, agent: PRAgent, api_url: str,\n                                   log_context: dict, data: dict):\n    apply_repo_settings(api_url)\n    if commands_conf == \"pr_commands\" and get_settings().config.disable_auto_feedback:  # auto commands for PR, and auto feedback is disabled\n        get_logger().info(f\"Auto feedback is disabled, skipping auto commands for PR {api_url=}\", **log_context)\n        return\n    if not should_process_pr_logic(data): # Here we already updated the configurations\n        return\n    commands = get_settings().get(f\"gitlab.{commands_conf}\", {})\n    get_settings().set(\"config.is_auto_command\", True)\n    for command in commands:\n        try:\n            split_command = command.split(\" \")\n            command = split_command[0]\n            args = split_command[1:]\n            other_args = update_settings_from_args(args)\n            new_command = ' '.join([command] + other_args)\n            get_logger().info(f\"Performing command: {new_command}\")\n            with get_logger().contextualize(**log_context):\n                await agent.handle_request(api_url, new_command)\n        except Exception as e:\n            get_logger().error(f\"Failed to perform command {command}: {e}\")",
    "start_line": 38,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "commands_conf",
      "agent",
      "api_url",
      "log_context",
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _perform_commands_gitlab",
    "component_id": "pr_agent.servers.gitlab_webhook._perform_commands_gitlab"
  },
  "pr_agent.servers.gitlab_webhook.is_bot_user": {
    "id": "pr_agent.servers.gitlab_webhook.is_bot_user",
    "name": "is_bot_user",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def is_bot_user(data) -> bool:\n    try:\n        # logic to ignore bot users (unlike Github, no direct flag for bot users in gitlab)\n        sender_name = data.get(\"user\", {}).get(\"name\", \"unknown\").lower()\n        bot_indicators = ['codium', 'bot_', 'bot-', '_bot', '-bot']\n        if any(indicator in sender_name for indicator in bot_indicators):\n            get_logger().info(f\"Skipping GitLab bot user: {sender_name}\")\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_bot_user' logic: {e}\")\n    return False",
    "start_line": 62,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_bot_user",
    "component_id": "pr_agent.servers.gitlab_webhook.is_bot_user"
  },
  "pr_agent.servers.gitlab_webhook.is_draft": {
    "id": "pr_agent.servers.gitlab_webhook.is_draft",
    "name": "is_draft",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def is_draft(data) -> bool:\n    try:\n        if 'draft' in data.get('object_attributes', {}):\n            return data['object_attributes']['draft']\n\n        # for gitlab server version before 16\n        elif 'Draft:' in data.get('object_attributes', {}).get('title'):\n            return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_draft' logic: {e}\")\n    return False",
    "start_line": 74,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_draft",
    "component_id": "pr_agent.servers.gitlab_webhook.is_draft"
  },
  "pr_agent.servers.gitlab_webhook.is_draft_ready": {
    "id": "pr_agent.servers.gitlab_webhook.is_draft_ready",
    "name": "is_draft_ready",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def is_draft_ready(data) -> bool:\n    try:\n        if 'draft' in data.get('changes', {}):\n            if data['changes']['draft']['previous'] == 'true' and data['changes']['draft']['current'] == 'false':\n                return True\n            \n        # for gitlab server version before 16\n        elif 'title' in data.get('changes', {}):\n            if 'Draft:' in data['changes']['title']['previous'] and 'Draft:' not in data['changes']['title']['current']:\n                return True\n    except Exception as e:\n        get_logger().error(f\"Failed 'is_draft_ready' logic: {e}\")\n    return False",
    "start_line": 86,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_draft_ready",
    "component_id": "pr_agent.servers.gitlab_webhook.is_draft_ready"
  },
  "pr_agent.servers.gitlab_webhook.should_process_pr_logic": {
    "id": "pr_agent.servers.gitlab_webhook.should_process_pr_logic",
    "name": "should_process_pr_logic",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def should_process_pr_logic(data) -> bool:\n    try:\n        if not data.get('object_attributes', {}):\n            return False\n        title = data['object_attributes'].get('title')\n        sender = data.get(\"user\", {}).get(\"username\", \"\")\n\n        # logic to ignore PRs from specific users\n        ignore_pr_users = get_settings().get(\"CONFIG.IGNORE_PR_AUTHORS\", [])\n        if ignore_pr_users and sender:\n            if sender in ignore_pr_users:\n                get_logger().info(f\"Ignoring PR from user '{sender}' due to 'config.ignore_pr_authors' settings\")\n                return False\n\n        # logic to ignore MRs for titles, labels and source, target branches.\n        ignore_mr_title = get_settings().get(\"CONFIG.IGNORE_PR_TITLE\", [])\n        ignore_mr_labels = get_settings().get(\"CONFIG.IGNORE_PR_LABELS\", [])\n        ignore_mr_source_branches = get_settings().get(\"CONFIG.IGNORE_PR_SOURCE_BRANCHES\", [])\n        ignore_mr_target_branches = get_settings().get(\"CONFIG.IGNORE_PR_TARGET_BRANCHES\", [])\n\n        #\n        if ignore_mr_source_branches:\n            source_branch = data['object_attributes'].get('source_branch')\n            if any(re.search(regex, source_branch) for regex in ignore_mr_source_branches):\n                get_logger().info(\n                    f\"Ignoring MR with source branch '{source_branch}' due to gitlab.ignore_mr_source_branches settings\")\n                return False\n\n        if ignore_mr_target_branches:\n            target_branch = data['object_attributes'].get('target_branch')\n            if any(re.search(regex, target_branch) for regex in ignore_mr_target_branches):\n                get_logger().info(\n                    f\"Ignoring MR with target branch '{target_branch}' due to gitlab.ignore_mr_target_branches settings\")\n                return False\n\n        if ignore_mr_labels:\n            labels = [label['title'] for label in data['object_attributes'].get('labels', [])]\n            if any(label in ignore_mr_labels for label in labels):\n                labels_str = \", \".join(labels)\n                get_logger().info(f\"Ignoring MR with labels '{labels_str}' due to gitlab.ignore_mr_labels settings\")\n                return False\n\n        if ignore_mr_title:\n            if any(re.search(regex, title) for regex in ignore_mr_title):\n                get_logger().info(f\"Ignoring MR with title '{title}' due to gitlab.ignore_mr_title settings\")\n                return False\n    except Exception as e:\n        get_logger().error(f\"Failed 'should_process_pr_logic': {e}\")\n    return True",
    "start_line": 100,
    "end_line": 148,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function should_process_pr_logic",
    "component_id": "pr_agent.servers.gitlab_webhook.should_process_pr_logic"
  },
  "pr_agent.servers.gitlab_webhook.gitlab_webhook": {
    "id": "pr_agent.servers.gitlab_webhook.gitlab_webhook",
    "name": "gitlab_webhook",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.servers.github_polling.now"
    ],
    "source_code": "async def gitlab_webhook(background_tasks: BackgroundTasks, request: Request):\n    start_time = datetime.now()\n    request_json = await request.json()\n    context[\"settings\"] = copy.deepcopy(global_settings)\n\n    async def inner(data: dict):\n        log_context = {\"server_type\": \"gitlab_app\"}\n        get_logger().debug(\"Received a GitLab webhook\")\n        if request.headers.get(\"X-Gitlab-Token\") and secret_provider:\n            request_token = request.headers.get(\"X-Gitlab-Token\")\n            secret = secret_provider.get_secret(request_token)\n            if not secret:\n                get_logger().warning(f\"Empty secret retrieved, request_token: {request_token}\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,\n                                    content=jsonable_encoder({\"message\": \"unauthorized\"}))\n            try:\n                secret_dict = json.loads(secret)\n                gitlab_token = secret_dict[\"gitlab_token\"]\n                log_context[\"token_id\"] = secret_dict.get(\"token_name\", secret_dict.get(\"id\", \"unknown\"))\n                context[\"settings\"].gitlab.personal_access_token = gitlab_token\n            except Exception as e:\n                get_logger().error(f\"Failed to validate secret {request_token}: {e}\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        elif get_settings().get(\"GITLAB.SHARED_SECRET\"):\n            secret = get_settings().get(\"GITLAB.SHARED_SECRET\")\n            if not request.headers.get(\"X-Gitlab-Token\") == secret:\n                get_logger().error(\"Failed to validate secret\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        else:\n            get_logger().error(\"Failed to validate secret\")\n            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        gitlab_token = get_settings().get(\"GITLAB.PERSONAL_ACCESS_TOKEN\", None)\n        if not gitlab_token:\n            get_logger().error(\"No gitlab token found\")\n            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n\n        get_logger().info(\"GitLab data\", artifact=data)\n        sender = data.get(\"user\", {}).get(\"username\", \"unknown\")\n        sender_id = data.get(\"user\", {}).get(\"id\", \"unknown\")\n\n        # ignore bot users\n        if is_bot_user(data):\n            return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n        log_context[\"sender\"] = sender\n        if data.get('object_kind') == 'merge_request':\n            # ignore MRs based on title, labels, source and target branches\n            if not should_process_pr_logic(data):\n                return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n            object_attributes = data.get('object_attributes', {})\n            if object_attributes.get('action') in ['open', 'reopen']:\n                url = object_attributes.get('url')\n                get_logger().info(f\"New merge request: {url}\")\n                if is_draft(data):\n                    get_logger().info(f\"Skipping draft MR: {url}\")\n                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n                await _perform_commands_gitlab(\"pr_commands\", PRAgent(), url, log_context, data)\n\n            # for push event triggered merge requests\n            elif object_attributes.get('action') == 'update' and object_attributes.get('oldrev'):\n                url = object_attributes.get('url')\n                get_logger().info(f\"New merge request: {url}\")\n                if is_draft(data):\n                    get_logger().info(f\"Skipping draft MR: {url}\")\n                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n                commands_on_push = get_settings().get(f\"gitlab.push_commands\", {})\n                handle_push_trigger = get_settings().get(f\"gitlab.handle_push_trigger\", False)\n                if not commands_on_push or not handle_push_trigger:\n                    get_logger().info(\"Push event, but no push commands found or push trigger is disabled\")\n                    return JSONResponse(status_code=status.HTTP_200_OK,\n                                        content=jsonable_encoder({\"message\": \"success\"}))\n\n                get_logger().debug(f'A push event has been received: {url}')\n                await _perform_commands_gitlab(\"push_commands\", PRAgent(), url, log_context, data)\n                \n            # for draft to ready triggered merge requests\n            elif object_attributes.get('action') == 'update' and is_draft_ready(data):\n                url = object_attributes.get('url')\n                get_logger().info(f\"Draft MR is ready: {url}\")\n\n                # same as open MR\n                await _perform_commands_gitlab(\"pr_commands\", PRAgent(), url, log_context, data)\n\n        elif data.get('object_kind') == 'note' and data.get('event_type') == 'note': # comment on MR\n            if 'merge_request' in data:\n                mr = data['merge_request']\n                url = mr.get('url')\n\n                get_logger().info(f\"A comment has been added to a merge request: {url}\")\n                body = data.get('object_attributes', {}).get('note')\n                if data.get('object_attributes', {}).get('type') == 'DiffNote' and '/ask' in body: # /ask_line\n                    body = handle_ask_line(body, data)\n\n                await handle_request(url, body, log_context, sender_id)\n\n    background_tasks.add_task(inner, request_json)\n    end_time = datetime.now()\n    get_logger().info(f\"Processing time: {end_time - start_time}\", request=request_json)\n    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))",
    "start_line": 152,
    "end_line": 252,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "background_tasks",
      "request"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function gitlab_webhook",
    "component_id": "pr_agent.servers.gitlab_webhook.gitlab_webhook"
  },
  "pr_agent.servers.gitlab_webhook.inner": {
    "id": "pr_agent.servers.gitlab_webhook.inner",
    "name": "inner",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.servers.gitlab_webhook.is_draft",
      "pr_agent.servers.gitlab_webhook._perform_commands_gitlab",
      "pr_agent.servers.gitlab_webhook.should_process_pr_logic",
      "pr_agent.servers.gitlab_webhook.is_draft_ready",
      "pr_agent.servers.gitlab_webhook.handle_ask_line",
      "pr_agent.config_loader.get_settings",
      "pr_agent.agent.pr_agent.PRAgent",
      "pr_agent.servers.gitlab_webhook.is_bot_user",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.servers.gitlab_webhook.handle_request"
    ],
    "source_code": "    async def inner(data: dict):\n        log_context = {\"server_type\": \"gitlab_app\"}\n        get_logger().debug(\"Received a GitLab webhook\")\n        if request.headers.get(\"X-Gitlab-Token\") and secret_provider:\n            request_token = request.headers.get(\"X-Gitlab-Token\")\n            secret = secret_provider.get_secret(request_token)\n            if not secret:\n                get_logger().warning(f\"Empty secret retrieved, request_token: {request_token}\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,\n                                    content=jsonable_encoder({\"message\": \"unauthorized\"}))\n            try:\n                secret_dict = json.loads(secret)\n                gitlab_token = secret_dict[\"gitlab_token\"]\n                log_context[\"token_id\"] = secret_dict.get(\"token_name\", secret_dict.get(\"id\", \"unknown\"))\n                context[\"settings\"].gitlab.personal_access_token = gitlab_token\n            except Exception as e:\n                get_logger().error(f\"Failed to validate secret {request_token}: {e}\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        elif get_settings().get(\"GITLAB.SHARED_SECRET\"):\n            secret = get_settings().get(\"GITLAB.SHARED_SECRET\")\n            if not request.headers.get(\"X-Gitlab-Token\") == secret:\n                get_logger().error(\"Failed to validate secret\")\n                return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        else:\n            get_logger().error(\"Failed to validate secret\")\n            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n        gitlab_token = get_settings().get(\"GITLAB.PERSONAL_ACCESS_TOKEN\", None)\n        if not gitlab_token:\n            get_logger().error(\"No gitlab token found\")\n            return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({\"message\": \"unauthorized\"}))\n\n        get_logger().info(\"GitLab data\", artifact=data)\n        sender = data.get(\"user\", {}).get(\"username\", \"unknown\")\n        sender_id = data.get(\"user\", {}).get(\"id\", \"unknown\")\n\n        # ignore bot users\n        if is_bot_user(data):\n            return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n        log_context[\"sender\"] = sender\n        if data.get('object_kind') == 'merge_request':\n            # ignore MRs based on title, labels, source and target branches\n            if not should_process_pr_logic(data):\n                return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n            object_attributes = data.get('object_attributes', {})\n            if object_attributes.get('action') in ['open', 'reopen']:\n                url = object_attributes.get('url')\n                get_logger().info(f\"New merge request: {url}\")\n                if is_draft(data):\n                    get_logger().info(f\"Skipping draft MR: {url}\")\n                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n                await _perform_commands_gitlab(\"pr_commands\", PRAgent(), url, log_context, data)\n\n            # for push event triggered merge requests\n            elif object_attributes.get('action') == 'update' and object_attributes.get('oldrev'):\n                url = object_attributes.get('url')\n                get_logger().info(f\"New merge request: {url}\")\n                if is_draft(data):\n                    get_logger().info(f\"Skipping draft MR: {url}\")\n                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({\"message\": \"success\"}))\n\n                commands_on_push = get_settings().get(f\"gitlab.push_commands\", {})\n                handle_push_trigger = get_settings().get(f\"gitlab.handle_push_trigger\", False)\n                if not commands_on_push or not handle_push_trigger:\n                    get_logger().info(\"Push event, but no push commands found or push trigger is disabled\")\n                    return JSONResponse(status_code=status.HTTP_200_OK,\n                                        content=jsonable_encoder({\"message\": \"success\"}))\n\n                get_logger().debug(f'A push event has been received: {url}')\n                await _perform_commands_gitlab(\"push_commands\", PRAgent(), url, log_context, data)\n                \n            # for draft to ready triggered merge requests\n            elif object_attributes.get('action') == 'update' and is_draft_ready(data):\n                url = object_attributes.get('url')\n                get_logger().info(f\"Draft MR is ready: {url}\")\n\n                # same as open MR\n                await _perform_commands_gitlab(\"pr_commands\", PRAgent(), url, log_context, data)\n\n        elif data.get('object_kind') == 'note' and data.get('event_type') == 'note': # comment on MR\n            if 'merge_request' in data:\n                mr = data['merge_request']\n                url = mr.get('url')\n\n                get_logger().info(f\"A comment has been added to a merge request: {url}\")\n                body = data.get('object_attributes', {}).get('note')\n                if data.get('object_attributes', {}).get('type') == 'DiffNote' and '/ask' in body: # /ask_line\n                    body = handle_ask_line(body, data)\n\n                await handle_request(url, body, log_context, sender_id)",
    "start_line": 157,
    "end_line": 247,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function inner",
    "component_id": "pr_agent.servers.gitlab_webhook.inner"
  },
  "pr_agent.servers.gitlab_webhook.handle_ask_line": {
    "id": "pr_agent.servers.gitlab_webhook.handle_ask_line",
    "name": "handle_ask_line",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def handle_ask_line(body, data):\n    try:\n        line_range_ = data['object_attributes']['position']['line_range']\n        # if line_range_['start']['type'] == 'new':\n        start_line = line_range_['start']['new_line']\n        end_line = line_range_['end']['new_line']\n        # else:\n        #     start_line = line_range_['start']['old_line']\n        #     end_line = line_range_['end']['old_line']\n        question = body.replace('/ask', '').strip()\n        path = data['object_attributes']['position']['new_path']\n        side = 'RIGHT'  # if line_range_['start']['type'] == 'new' else 'LEFT'\n        comment_id = data['object_attributes'][\"discussion_id\"]\n        get_logger().info(\"Handling line comment\")\n        body = f\"/ask_line --line_start={start_line} --line_end={end_line} --side={side} --file_name={path} --comment_id={comment_id} {question}\"\n    except Exception as e:\n        get_logger().error(f\"Failed to handle ask line comment: {e}\")\n    return body",
    "start_line": 255,
    "end_line": 272,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "body",
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_ask_line",
    "component_id": "pr_agent.servers.gitlab_webhook.handle_ask_line"
  },
  "pr_agent.servers.gitlab_webhook.root": {
    "id": "pr_agent.servers.gitlab_webhook.root",
    "name": "root",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [],
    "source_code": "async def root():\n    return {\"status\": \"ok\"}",
    "start_line": 276,
    "end_line": 277,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function root",
    "component_id": "pr_agent.servers.gitlab_webhook.root"
  },
  "pr_agent.servers.gitlab_webhook.start": {
    "id": "pr_agent.servers.gitlab_webhook.start",
    "name": "start",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/gitlab_webhook.py",
    "relative_path": "pr_agent/servers/gitlab_webhook.py",
    "depends_on": [
      "pr_agent.cli.run"
    ],
    "source_code": "def start():\n    uvicorn.run(app, host=\"0.0.0.0\", port=3000)",
    "start_line": 288,
    "end_line": 289,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function start",
    "component_id": "pr_agent.servers.gitlab_webhook.start"
  },
  "pr_agent.servers.help.HelpMessage": {
    "id": "pr_agent.servers.help.HelpMessage",
    "name": "HelpMessage",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/help.py",
    "relative_path": "pr_agent/servers/help.py",
    "depends_on": [],
    "source_code": "class HelpMessage:\n    @staticmethod\n    def get_general_commands_text():\n       commands_text = \"> - **/review**: Request a review of your Pull Request.   \\n\" \\\n                \"> - **/describe**: Update the PR title and description based on the contents of the PR.   \\n\" \\\n                \"> - **/improve [--extended]**: Suggest code improvements. Extended mode provides a higher quality feedback.   \\n\" \\\n                \"> - **/ask \\\\<QUESTION\\\\>**: Ask a question about the PR.   \\n\" \\\n                \"> - **/update_changelog**: Update the changelog based on the PR's contents.   \\n\" \\\n                \"> - **/help_docs \\\\<QUESTION\\\\>**: Given a path to documentation (either for this repository or for a given one), ask a question.   \\n\" \\\n                \"> - **/add_docs** : Generate docstring for new components introduced in the PR.   \\n\" \\\n                \"> - **/generate_labels** : Generate labels for the PR based on the PR's contents.   \\n\" \\\n                \"> - **/analyze** : Automatically analyzes the PR, and presents changes walkthrough for each component.   \\n\\n\" \\\n                \">See the [tools guide](https://pr-agent-docs.codium.ai/tools/) for more details.\\n\" \\\n                \">To list the possible configuration parameters, add a **/config** comment.   \\n\"\n       return commands_text\n\n\n    @staticmethod\n    def get_general_bot_help_text():\n        output = f\"> To invoke the PR-Agent, add a comment using one of the following commands:  \\n{HelpMessage.get_general_commands_text()} \\n\"\n        return output\n\n    @staticmethod\n    def get_review_usage_guide():\n        output =\"**Overview:**\\n\"\n        output +=(\"The `review` tool scans the PR code changes, and generates a PR review which includes several types of feedbacks, such as possible PR issues, security threats and relevant test in the PR. More feedbacks can be [added](https://pr-agent-docs.codium.ai/tools/review/#general-configurations) by configuring the tool.\\n\\n\"\n                  \"The tool can be triggered [automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) every time a new PR is opened, or can be invoked manually by commenting on any PR.\\n\")\n        output +=\"\"\"\\\n- When commenting, to edit [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml#L23) related to the review tool (`pr_reviewer` section), use the following template:\n```\n/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n```\n- With a [configuration file](https://pr-agent-docs.codium.ai/usage-guide/configuration_options/), use the following template:\n```\n[pr_reviewer]\nsome_config1=...\nsome_config2=...\n```\n    \"\"\"\n\n        output += f\"\\n\\nSee the review [usage page](https://pr-agent-docs.codium.ai/tools/review/) for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n\n\n    @staticmethod\n    def get_describe_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"The `describe` tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels. \"\n        output += \"The tool can be triggered [automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) every time a new PR is opened, or can be invoked manually by commenting on a PR.\\n\"\n        output += \"\"\"\\\n\nWhen commenting, to edit [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml#L46) related to the describe tool (`pr_description` section), use the following template:\n```\n/describe --pr_description.some_config1=... --pr_description.some_config2=...\n```\nWith a [configuration file](https://pr-agent-docs.codium.ai/usage-guide/configuration_options/), use the following template:\n```\n[pr_description]\nsome_config1=...\nsome_config2=...\n```\n\"\"\"\n        output += \"\\n\\n<table>\"\n\n        # automation\n        output += \"<tr><td><details> <summary><strong> Enabling\\\\disabling automation </strong></summary><hr>\\n\\n\"\n        output += \"\"\"\\\n- When you first install the app, the [default mode](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) for the describe tool is:\n```\npr_commands = [\"/describe\", ...]\n```\nmeaning the `describe` tool will run automatically on every PR.\n\n- Markers are an alternative way to control the generated description, to give maximal control to the user. If you set:\n```\npr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n```\nthe tool will replace every marker of the form `pr_agent:marker_name` in the PR description with the relevant content, where `marker_name` is one of the following:\n  - `type`: the PR type.\n  - `summary`: the PR summary.\n  - `walkthrough`: the PR walkthrough.\n\nNote that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.\n\n\"\"\"\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n        # custom labels\n        output += \"<tr><td><details> <summary><strong> Custom labels </strong></summary><hr>\\n\\n\"\n        output += \"\"\"\\\nThe default labels of the `describe` tool are quite generic: [`Bug fix`, `Tests`, `Enhancement`, `Documentation`, `Other`].\n\nIf you specify [custom labels](https://pr-agent-docs.codium.ai/tools/describe/#handle-custom-labels-from-the-repos-labels-page) in the repo's labels page or via configuration file, you can get tailored labels for your use cases.\nExamples for custom labels:\n- `Main topic:performance` - pr_agent:The main topic of this PR is performance\n- `New endpoint` - pr_agent:A new endpoint was added in this PR\n- `SQL query` - pr_agent:A new SQL query was added in this PR\n- `Dockerfile changes` - pr_agent:The PR contains changes in the Dockerfile\n- ...\n\nThe list above is eclectic, and aims to give an idea of different possibilities. Define custom labels that are relevant for your repo and use cases.\nNote that Labels are not mutually exclusive, so you can add multiple label categories.\nMake sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it.\n\"\"\"\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n        # Inline File Walkthrough\n        output += \"<tr><td><details> <summary><strong> Inline File Walkthrough </strong></summary><hr>\\n\\n\"\n        output += \"\"\"\\\nFor enhanced user experience, the `describe` tool can add file summaries directly to the \"Files changed\" tab in the PR page.\nThis will enable you to quickly understand the changes in each file, while reviewing the code changes (diffs).\n\nTo enable inline file summary, set `pr_description.inline_file_summary` in the configuration file, possible values are:\n- `'table'`: File changes walkthrough table will be displayed on the top of the \"Files changed\" tab, in addition to the \"Conversation\" tab.\n- `true`: A collapsable file comment with changes title and a changes summary for each file in the PR.\n- `false` (default): File changes walkthrough will be added only to the \"Conversation\" tab.\n\"\"\"\n\n        # extra instructions\n        output += \"<tr><td><details> <summary><strong> Utilizing extra instructions</strong></summary><hr>\\n\\n\"\n        output += '''\\\nThe `describe` tool can be configured with extra instructions, to guide the model to a feedback tailored to the needs of your project.\n\nBe specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Notice that the general structure of the description is fixed, and cannot be changed. Extra instructions can change the content or style of each sub-section of the PR description.\n\nExamples for extra instructions:\n```\n[pr_description]\nextra_instructions=\"\"\"\\\n- The PR title should be in the format: '<PR type>: <title>'\n- The title should be short and concise (up to 10 words)\n- ...\n\"\"\"\n```\nUse triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.\n'''\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n\n        # general\n        output += \"\\n\\n<tr><td><details> <summary><strong> More PR-Agent commands</strong></summary><hr> \\n\\n\"\n        output += HelpMessage.get_general_bot_help_text()\n        output += \"\\n\\n</details></td></tr>\\n\\n\"\n\n        output += \"</table>\"\n\n        output += f\"\\n\\nSee the [describe usage](https://pr-agent-docs.codium.ai/tools/describe/) page for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n    @staticmethod\n    def get_ask_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"\"\"\\\nThe `ask` tool answers questions about the PR, based on the PR code changes.\nIt can be invoked manually by commenting on any PR:\n```\n/ask \"...\"\n```\n\nNote that the tool does not have \"memory\" of previous questions, and answers each question independently.\nYou can ask questions about the entire PR, about specific code lines, or about an image related to the PR code changes.\n        \"\"\"\n        # output += \"\\n\\n<table>\"\n        #\n        # # # general\n        # # output += \"\\n\\n<tr><td><details> <summary><strong> More PR-Agent commands</strong></summary><hr> \\n\\n\"\n        # # output += HelpMessage.get_general_bot_help_text()\n        # # output += \"\\n\\n</details></td></tr>\\n\\n\"\n        #\n        # output += \"</table>\"\n\n        output += f\"\\n\\nSee the [ask usage](https://pr-agent-docs.codium.ai/tools/ask/) page for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n\n    @staticmethod\n    def get_improve_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"The code suggestions tool, named `improve`, scans the PR code changes, and automatically generates code suggestions for improving the PR.\"\n        output += \"The tool can be triggered [automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) every time a new PR is opened, or can be invoked manually by commenting on a PR.\\n\"\n        output += \"\"\"\\\n- When commenting, to edit [configurations](https://github.com/Codium-ai/pr-agent/blob/main/pr_agent/settings/configuration.toml#L78) related to the improve tool (`pr_code_suggestions` section), use the following template:\n\n```\n/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n```\n\n- With a [configuration file](https://pr-agent-docs.codium.ai/usage-guide/configuration_options/), use the following template:\n\n```\n[pr_code_suggestions]\nsome_config1=...\nsome_config2=...\n```\n\n\"\"\"\n\n        output += f\"\\n\\nSee the improve [usage page](https://pr-agent-docs.codium.ai/tools/improve/) for a comprehensive guide on using this tool.\\n\\n\"\n\n        return output\n\n\n    @staticmethod\n    def get_help_docs_usage_guide():\n        output = \"**Overview:**\\n\"\n        output += \"\"\"\\\nThe help docs tool, named `help_docs`, answers a question based on a given relative path of documentation, either from the repository of this merge request or from a given one.\"\nIt can be invoked manually by commenting on any PR:\n```\n/help_docs \"...\"\n```\n\"\"\"\n        output += f\"\\n\\nSee the [help_docs usage](https://pr-agent-docs.codium.ai/tools/help_docs/) page for a comprehensive guide on using this tool.\\n\\n\"\n        return output",
    "start_line": 1,
    "end_line": 218,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class HelpMessage",
    "component_id": "pr_agent.servers.help.HelpMessage"
  },
  "pr_agent.servers.serverless.serverless": {
    "id": "pr_agent.servers.serverless.serverless",
    "name": "serverless",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/serverless.py",
    "relative_path": "pr_agent/servers/serverless.py",
    "depends_on": [],
    "source_code": "def serverless(event, context):\n    return handler(event, context)",
    "start_line": 15,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function serverless",
    "component_id": "pr_agent.servers.serverless.serverless"
  },
  "pr_agent.servers.utils.verify_signature": {
    "id": "pr_agent.servers.utils.verify_signature",
    "name": "verify_signature",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/utils.py",
    "relative_path": "pr_agent/servers/utils.py",
    "depends_on": [],
    "source_code": "def verify_signature(payload_body, secret_token, signature_header):\n    \"\"\"Verify that the payload was sent from GitHub by validating SHA256.\n\n    Raise and return 403 if not authorized.\n\n    Args:\n        payload_body: original request body to verify (request.body())\n        secret_token: GitHub app webhook token (WEBHOOK_SECRET)\n        signature_header: header received from GitHub (x-hub-signature-256)\n    \"\"\"\n    if not signature_header:\n        raise HTTPException(status_code=403, detail=\"x-hub-signature-256 header is missing!\")\n    hash_object = hmac.new(secret_token.encode('utf-8'), msg=payload_body, digestmod=hashlib.sha256)\n    expected_signature = \"sha256=\" + hash_object.hexdigest()\n    if not hmac.compare_digest(expected_signature, signature_header):\n        raise HTTPException(status_code=403, detail=\"Request signatures didn't match!\")",
    "start_line": 10,
    "end_line": 25,
    "has_docstring": true,
    "docstring": "Verify that the payload was sent from GitHub by validating SHA256.\n\nRaise and return 403 if not authorized.\n\nArgs:\n    payload_body: original request body to verify (request.body())\n    secret_token: GitHub app webhook token (WEBHOOK_SECRET)\n    signature_header: header received from GitHub (x-hub-signature-256)",
    "parameters": [
      "payload_body",
      "secret_token",
      "signature_header"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function verify_signature",
    "component_id": "pr_agent.servers.utils.verify_signature"
  },
  "pr_agent.servers.utils.RateLimitExceeded": {
    "id": "pr_agent.servers.utils.RateLimitExceeded",
    "name": "RateLimitExceeded",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/utils.py",
    "relative_path": "pr_agent/servers/utils.py",
    "depends_on": [],
    "source_code": "class RateLimitExceeded(Exception):\n    \"\"\"Raised when the git provider API rate limit has been exceeded.\"\"\"\n    pass",
    "start_line": 28,
    "end_line": 30,
    "has_docstring": true,
    "docstring": "Raised when the git provider API rate limit has been exceeded.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "Exception"
    ],
    "class_name": null,
    "display_name": "class RateLimitExceeded",
    "component_id": "pr_agent.servers.utils.RateLimitExceeded"
  },
  "pr_agent.servers.utils.DefaultDictWithTimeout": {
    "id": "pr_agent.servers.utils.DefaultDictWithTimeout",
    "name": "DefaultDictWithTimeout",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/servers/utils.py",
    "relative_path": "pr_agent/servers/utils.py",
    "depends_on": [],
    "source_code": "class DefaultDictWithTimeout(defaultdict):\n    \"\"\"A defaultdict with a time-to-live (TTL).\"\"\"\n\n    def __init__(\n        self,\n        default_factory: Callable[[], Any] = None,\n        ttl: int = None,\n        refresh_interval: int = 60,\n        update_key_time_on_get: bool = True,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Args:\n            default_factory: The default factory to use for keys that are not in the dictionary.\n            ttl: The time-to-live (TTL) in seconds.\n            refresh_interval: How often to refresh the dict and delete items older than the TTL.\n            update_key_time_on_get: Whether to update the access time of a key also on get (or only when set).\n        \"\"\"\n        super().__init__(default_factory, *args, **kwargs)\n        self.__key_times = dict()\n        self.__ttl = ttl\n        self.__refresh_interval = refresh_interval\n        self.__update_key_time_on_get = update_key_time_on_get\n        self.__last_refresh = self.__time() - self.__refresh_interval\n\n    @staticmethod\n    def __time():\n        return time.monotonic()\n\n    def __refresh(self):\n        if self.__ttl is None:\n            return\n        request_time = self.__time()\n        if request_time - self.__last_refresh > self.__refresh_interval:\n            return\n        to_delete = [key for key, key_time in self.__key_times.items() if request_time - key_time > self.__ttl]\n        for key in to_delete:\n            del self[key]\n        self.__last_refresh = request_time\n\n    def __getitem__(self, __key):\n        if self.__update_key_time_on_get:\n            self.__key_times[__key] = self.__time()\n        self.__refresh()\n        return super().__getitem__(__key)\n\n    def __setitem__(self, __key, __value):\n        self.__key_times[__key] = self.__time()\n        return super().__setitem__(__key, __value)\n\n    def __delitem__(self, __key):\n        del self.__key_times[__key]\n        return super().__delitem__(__key)",
    "start_line": 33,
    "end_line": 86,
    "has_docstring": true,
    "docstring": "A defaultdict with a time-to-live (TTL).",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "defaultdict"
    ],
    "class_name": null,
    "display_name": "class DefaultDictWithTimeout",
    "component_id": "pr_agent.servers.utils.DefaultDictWithTimeout"
  },
  "pr_agent.tools.pr_add_docs.PRAddDocs": {
    "id": "pr_agent.tools.pr_add_docs.PRAddDocs",
    "name": "PRAddDocs",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_add_docs.py",
    "relative_path": "pr_agent/tools/pr_add_docs.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.tools.pr_add_docs.get_docs_for_language",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.algo.utils.load_yaml",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider",
      "pr_agent.git_providers.git_provider.publish_code_suggestions"
    ],
    "source_code": "class PRAddDocs:\n    def __init__(self, pr_url: str, cli_mode=False, args: list = None,\n                 ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n\n        self.git_provider = get_git_provider()(pr_url)\n        self.main_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_language\n\n        self.patches_diff = None\n        self.prediction = None\n        self.cli_mode = cli_mode\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.git_provider.get_pr_description(),\n            \"language\": self.main_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"extra_instructions\": get_settings().pr_add_docs.extra_instructions,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n            'docs_for_language': get_docs_for_language(self.main_language,\n                                                       get_settings().pr_add_docs.docs_style),\n        }\n        self.token_handler = TokenHandler(self.git_provider.pr,\n                                          self.vars,\n                                          get_settings().pr_add_docs_prompt.system,\n                                          get_settings().pr_add_docs_prompt.user)\n\n    async def run(self):\n        try:\n            get_logger().info('Generating code Docs for PR...')\n            if get_settings().config.publish_output:\n                self.git_provider.publish_comment(\"Generating Documentation...\", is_temporary=True)\n\n            get_logger().info('Preparing PR documentation...')\n            await retry_with_fallback_models(self._prepare_prediction)\n            data = self._prepare_pr_code_docs()\n            if (not data) or (not 'Code Documentation' in data):\n                get_logger().info('No code documentation found for PR.')\n                return\n\n            if get_settings().config.publish_output:\n                get_logger().info('Pushing PR documentation...')\n                self.git_provider.remove_initial_comment()\n                get_logger().info('Pushing inline code documentation...')\n                self.push_inline_docs(data)\n        except Exception as e:\n            get_logger().error(f\"Failed to generate code documentation for PR, error: {e}\")\n\n    async def _prepare_prediction(self, model: str):\n        get_logger().info('Getting PR diff...')\n\n        self.patches_diff = get_pr_diff(self.git_provider,\n                                        self.token_handler,\n                                        model,\n                                        add_line_numbers_to_hunks=True,\n                                        disable_extra_lines=False)\n\n        get_logger().info('Getting AI prediction...')\n        self.prediction = await self._get_prediction(model)\n\n    async def _get_prediction(self, model: str):\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = self.patches_diff  # update diff\n        environment = Environment(undefined=StrictUndefined)\n        system_prompt = environment.from_string(get_settings().pr_add_docs_prompt.system).render(variables)\n        user_prompt = environment.from_string(get_settings().pr_add_docs_prompt.user).render(variables)\n        if get_settings().config.verbosity_level >= 2:\n            get_logger().info(f\"\\nSystem prompt:\\n{system_prompt}\")\n            get_logger().info(f\"\\nUser prompt:\\n{user_prompt}\")\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model, temperature=get_settings().config.temperature, system=system_prompt, user=user_prompt)\n\n        return response\n\n    def _prepare_pr_code_docs(self) -> Dict:\n        docs = self.prediction.strip()\n        data = load_yaml(docs)\n        if isinstance(data, list):\n            data = {'Code Documentation': data}\n        return data\n\n    def push_inline_docs(self, data):\n        docs = []\n\n        if not data['Code Documentation']:\n            return self.git_provider.publish_comment('No code documentation found to improve this PR.')\n\n        for d in data['Code Documentation']:\n            try:\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"add_docs: {d}\")\n                relevant_file = d['relevant file'].strip()\n                relevant_line = int(d['relevant line'])  # absolute position\n                documentation = d['documentation']\n                doc_placement = d['doc placement'].strip()\n                if documentation:\n                    new_code_snippet = self.dedent_code(relevant_file, relevant_line, documentation, doc_placement,\n                                                        add_original_line=True)\n\n                    body = f\"**Suggestion:** Proposed documentation\\n```suggestion\\n\" + new_code_snippet + \"\\n```\"\n                    docs.append({'body': body, 'relevant_file': relevant_file,\n                                             'relevant_lines_start': relevant_line,\n                                             'relevant_lines_end': relevant_line})\n            except Exception:\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"Could not parse code docs: {d}\")\n\n        is_successful = self.git_provider.publish_code_suggestions(docs)\n        if not is_successful:\n            get_logger().info(\"Failed to publish code docs, trying to publish each docs separately\")\n            for doc_suggestion in docs:\n                self.git_provider.publish_code_suggestions([doc_suggestion])\n\n    def dedent_code(self, relevant_file, relevant_lines_start, new_code_snippet, doc_placement='after',\n                    add_original_line=False):\n        try:  # dedent code snippet\n            self.diff_files = self.git_provider.diff_files if self.git_provider.diff_files \\\n                else self.git_provider.get_diff_files()\n            original_initial_line = None\n            for file in self.diff_files:\n                if file.filename.strip() == relevant_file:\n                    original_initial_line = file.head_file.splitlines()[relevant_lines_start - 1]\n                    break\n            if original_initial_line:\n                if doc_placement == 'after':\n                    line = file.head_file.splitlines()[relevant_lines_start]\n                else:\n                    line = original_initial_line\n                suggested_initial_line = new_code_snippet.splitlines()[0]\n                original_initial_spaces = len(line) - len(line.lstrip())\n                suggested_initial_spaces = len(suggested_initial_line) - len(suggested_initial_line.lstrip())\n                delta_spaces = original_initial_spaces - suggested_initial_spaces\n                if delta_spaces > 0:\n                    new_code_snippet = textwrap.indent(new_code_snippet, delta_spaces * \" \").rstrip('\\n')\n                if add_original_line:\n                    if doc_placement == 'after':\n                        new_code_snippet = original_initial_line + \"\\n\" + new_code_snippet\n                    else:\n                        new_code_snippet = new_code_snippet.rstrip() + \"\\n\" + original_initial_line\n        except Exception as e:\n            if get_settings().config.verbosity_level >= 2:\n                get_logger().info(f\"Could not dedent code snippet for file {relevant_file}, error: {e}\")\n\n        return new_code_snippet",
    "start_line": 19,
    "end_line": 166,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRAddDocs",
    "component_id": "pr_agent.tools.pr_add_docs.PRAddDocs"
  },
  "pr_agent.tools.pr_add_docs.get_docs_for_language": {
    "id": "pr_agent.tools.pr_add_docs.get_docs_for_language",
    "name": "get_docs_for_language",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_add_docs.py",
    "relative_path": "pr_agent/tools/pr_add_docs.py",
    "depends_on": [],
    "source_code": "def get_docs_for_language(language, style):\n    language = language.lower()\n    if language == 'java':\n        return \"Javadocs\"\n    elif language in ['python', 'lisp', 'clojure']:\n        return f\"Docstring ({style})\"\n    elif language in ['javascript', 'typescript']:\n        return \"JSdocs\"\n    elif language == 'c++':\n        return \"Doxygen\"\n    else:\n        return \"Docs\"",
    "start_line": 169,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "language",
      "style"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_docs_for_language",
    "component_id": "pr_agent.tools.pr_add_docs.get_docs_for_language"
  },
  "pr_agent.tools.pr_code_suggestions.PRCodeSuggestions": {
    "id": "pr_agent.tools.pr_code_suggestions.PRCodeSuggestions",
    "name": "PRCodeSuggestions",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_code_suggestions.py",
    "relative_path": "pr_agent/tools/pr_code_suggestions.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.git_providers.git_provider.get_comment_url",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.algo.pr_processing.get_pr_multi_diffs",
      "pr_agent.git_providers.git_provider.get_line_link",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.algo.git_patch_processing.decouple_and_convert_to_hunks_with_lines_numbers",
      "pr_agent.git_providers.git_provider.edit_comment",
      "pr_agent.git_providers.__init__.get_git_provider_with_context",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.pr_processing.add_ai_metadata_to_diff_files",
      "pr_agent.git_providers.git_provider.publish_code_suggestions",
      "pr_agent.servers.github_polling.now",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.tools.pr_description.insert_br_after_x_chars",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.tools.pr_description.replace_code_tags",
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_latest_commit_url",
      "pr_agent.algo.utils.show_relevant_configurations",
      "pr_agent.git_providers.git_provider.get_issue_comments",
      "pr_agent.algo.utils.load_yaml"
    ],
    "source_code": "class PRCodeSuggestions:\n    def __init__(self, pr_url: str, cli_mode=False, args: list = None,\n                 ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n\n        self.git_provider = get_git_provider_with_context(pr_url)\n        self.main_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n\n        # limit context specifically for the improve command, which has hard input to parse:\n        if get_settings().pr_code_suggestions.max_context_tokens:\n            MAX_CONTEXT_TOKENS_IMPROVE = get_settings().pr_code_suggestions.max_context_tokens\n            if get_settings().config.max_model_tokens > MAX_CONTEXT_TOKENS_IMPROVE:\n                get_logger().info(f\"Setting max_model_tokens to {MAX_CONTEXT_TOKENS_IMPROVE} for PR improve\")\n                get_settings().config.max_model_tokens_original = get_settings().config.max_model_tokens\n                get_settings().config.max_model_tokens = MAX_CONTEXT_TOKENS_IMPROVE\n\n        num_code_suggestions = int(get_settings().pr_code_suggestions.num_code_suggestions_per_chunk)\n\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_language\n        self.patches_diff = None\n        self.prediction = None\n        self.pr_url = pr_url\n        self.cli_mode = cli_mode\n        self.pr_description, self.pr_description_files = (\n            self.git_provider.get_pr_description(split_changes_walkthrough=True))\n        if (self.pr_description_files and get_settings().get(\"config.is_auto_command\", False) and\n                get_settings().get(\"config.enable_ai_metadata\", False)):\n            add_ai_metadata_to_diff_files(self.git_provider, self.pr_description_files)\n            get_logger().debug(f\"AI metadata added to the this command\")\n        else:\n            get_settings().set(\"config.enable_ai_metadata\", False)\n            get_logger().debug(f\"AI metadata is disabled for this command\")\n\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.pr_description,\n            \"language\": self.main_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"diff_no_line_numbers\": \"\",  # empty diff for initial calculation\n            \"num_code_suggestions\": num_code_suggestions,\n            \"extra_instructions\": get_settings().pr_code_suggestions.extra_instructions,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n            \"relevant_best_practices\": \"\",\n            \"is_ai_metadata\": get_settings().get(\"config.enable_ai_metadata\", False),\n            \"focus_only_on_problems\": get_settings().get(\"pr_code_suggestions.focus_only_on_problems\", False),\n            \"date\": datetime.now().strftime('%Y-%m-%d'),\n            'duplicate_prompt_examples': get_settings().config.get('duplicate_prompt_examples', False),\n        }\n\n        if get_settings().pr_code_suggestions.get(\"decouple_hunks\", True):\n            self.pr_code_suggestions_prompt_system = get_settings().pr_code_suggestions_prompt.system\n            self.pr_code_suggestions_prompt_user = get_settings().pr_code_suggestions_prompt.user\n        else:\n            self.pr_code_suggestions_prompt_system = get_settings().pr_code_suggestions_prompt_not_decoupled.system\n            self.pr_code_suggestions_prompt_user = get_settings().pr_code_suggestions_prompt_not_decoupled.user\n\n        self.token_handler = TokenHandler(self.git_provider.pr,\n                                          self.vars,\n                                          self.pr_code_suggestions_prompt_system,\n                                          self.pr_code_suggestions_prompt_user)\n\n        self.progress = f\"## Generating PR code suggestions\\n\\n\"\n        self.progress += f\"\"\"\\nWork in progress ...<br>\\n<img src=\"https://codium.ai/images/pr_agent/dual_ball_loading-crop.gif\" width=48>\"\"\"\n        self.progress_response = None\n\n    async def run(self):\n        try:\n            if not self.git_provider.get_files():\n                get_logger().info(f\"PR has no files: {self.pr_url}, skipping code suggestions\")\n                return None\n\n            get_logger().info('Generating code suggestions for PR...')\n            relevant_configs = {'pr_code_suggestions': dict(get_settings().pr_code_suggestions),\n                                'config': dict(get_settings().config)}\n            get_logger().debug(\"Relevant configs\", artifacts=relevant_configs)\n\n            # publish \"Preparing suggestions...\" comments\n            if (get_settings().config.publish_output and get_settings().config.publish_output_progress and\n                    not get_settings().config.get('is_auto_command', False)):\n                if self.git_provider.is_supported(\"gfm_markdown\"):\n                    self.progress_response = self.git_provider.publish_comment(self.progress)\n                else:\n                    self.git_provider.publish_comment(\"Preparing suggestions...\", is_temporary=True)\n\n            # # call the model to get the suggestions, and self-reflect on them\n            # if not self.is_extended:\n            #     data = await retry_with_fallback_models(self._prepare_prediction, model_type=ModelType.REGULAR)\n            # else:\n            data = await retry_with_fallback_models(self._prepare_prediction_extended, model_type=ModelType.REGULAR)\n            if not data:\n                data = {\"code_suggestions\": []}\n            self.data = data\n\n            # Handle the case where the PR has no suggestions\n            if (data is None or 'code_suggestions' not in data or not data['code_suggestions']):\n                await self.publish_no_suggestions()\n                return\n\n            # publish the suggestions\n            if get_settings().config.publish_output:\n                # If a temporary comment was published, remove it\n                self.git_provider.remove_initial_comment()\n\n                # Publish table summarized suggestions\n                if ((not get_settings().pr_code_suggestions.commitable_code_suggestions) and\n                        self.git_provider.is_supported(\"gfm_markdown\")):\n\n                    # generate summarized suggestions\n                    pr_body = self.generate_summarized_suggestions(data)\n                    get_logger().debug(f\"PR output\", artifact=pr_body)\n\n                    # require self-review\n                    if get_settings().pr_code_suggestions.demand_code_suggestions_self_review:\n                        pr_body = await self.add_self_review_text(pr_body)\n\n                    # add usage guide\n                    if (get_settings().pr_code_suggestions.enable_chat_text and get_settings().config.is_auto_command\n                            and isinstance(self.git_provider, GithubProvider)):\n                        pr_body += \"\\n\\n> Need additional feedback ? start a [PR chat](https://chromewebstore.google.com/detail/ephlnjeghhogofkifjloamocljapahnl) \\n\\n\"\n                    if get_settings().pr_code_suggestions.enable_help_text:\n                        pr_body += \"<hr>\\n\\n<details> <summary><strong> Tool usage guide:</strong></summary><hr> \\n\\n\"\n                        pr_body += HelpMessage.get_improve_usage_guide()\n                        pr_body += \"\\n</details>\\n\"\n\n                    # Output the relevant configurations if enabled\n                    if get_settings().get('config', {}).get('output_relevant_configurations', False):\n                        pr_body += show_relevant_configurations(relevant_section='pr_code_suggestions')\n\n                    # publish the PR comment\n                    if get_settings().pr_code_suggestions.persistent_comment: # true by default\n                        self.publish_persistent_comment_with_history(self.git_provider,\n                                                                     pr_body,\n                                                                     initial_header=\"## PR Code Suggestions \",\n                                                                     update_header=True,\n                                                                     name=\"suggestions\",\n                                                                     final_update_message=False,\n                                                                     max_previous_comments=get_settings().pr_code_suggestions.max_history_len,\n                                                                     progress_response=self.progress_response)\n                    else:\n                        if self.progress_response:\n                            self.git_provider.edit_comment(self.progress_response, body=pr_body)\n                        else:\n                            self.git_provider.publish_comment(pr_body)\n\n                    # dual publishing mode\n                    if int(get_settings().pr_code_suggestions.dual_publishing_score_threshold) > 0:\n                        await self.dual_publishing(data)\n                else:\n                    await self.push_inline_code_suggestions(data)\n                    if self.progress_response:\n                        self.git_provider.remove_comment(self.progress_response)\n            else:\n                get_logger().info('Code suggestions generated for PR, but not published since publish_output is False.')\n                pr_body = self.generate_summarized_suggestions(data)\n                get_settings().data = {\"artifact\": pr_body}\n                return\n        except Exception as e:\n            get_logger().error(f\"Failed to generate code suggestions for PR, error: {e}\",\n                               artifact={\"traceback\": traceback.format_exc()})\n            if get_settings().config.publish_output:\n                if self.progress_response:\n                    self.progress_response.delete()\n                else:\n                    try:\n                        self.git_provider.remove_initial_comment()\n                        self.git_provider.publish_comment(f\"Failed to generate code suggestions for PR\")\n                    except Exception as e:\n                        get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n\n    async def add_self_review_text(self, pr_body):\n        text = get_settings().pr_code_suggestions.code_suggestions_self_review_text\n        pr_body += f\"\\n\\n- [ ]  {text}\"\n        approve_pr_on_self_review = get_settings().pr_code_suggestions.approve_pr_on_self_review\n        fold_suggestions_on_self_review = get_settings().pr_code_suggestions.fold_suggestions_on_self_review\n        if approve_pr_on_self_review and not fold_suggestions_on_self_review:\n            pr_body += ' <!-- approve pr self-review -->'\n        elif fold_suggestions_on_self_review and not approve_pr_on_self_review:\n            pr_body += ' <!-- fold suggestions self-review -->'\n        else:\n            pr_body += ' <!-- approve and fold suggestions self-review -->'\n        return pr_body\n\n    async def publish_no_suggestions(self):\n        pr_body = \"## PR Code Suggestions \\n\\nNo code suggestions found for the PR.\"\n        if get_settings().config.publish_output and get_settings().config.publish_output_no_suggestions:\n            get_logger().warning('No code suggestions found for the PR.')\n            get_logger().debug(f\"PR output\", artifact=pr_body)\n            if self.progress_response:\n                self.git_provider.edit_comment(self.progress_response, body=pr_body)\n            else:\n                self.git_provider.publish_comment(pr_body)\n        else:\n            get_settings().data = {\"artifact\": \"\"}\n\n    async def dual_publishing(self, data):\n        data_above_threshold = {'code_suggestions': []}\n        try:\n            for suggestion in data['code_suggestions']:\n                if int(suggestion.get('score', 0)) >= int(\n                        get_settings().pr_code_suggestions.dual_publishing_score_threshold) \\\n                        and suggestion.get('improved_code'):\n                    data_above_threshold['code_suggestions'].append(suggestion)\n                    if not data_above_threshold['code_suggestions'][-1]['existing_code']:\n                        get_logger().info(f'Identical existing and improved code for dual publishing found')\n                        data_above_threshold['code_suggestions'][-1]['existing_code'] = suggestion[\n                            'improved_code']\n            if data_above_threshold['code_suggestions']:\n                get_logger().info(\n                    f\"Publishing {len(data_above_threshold['code_suggestions'])} suggestions in dual publishing mode\")\n                await self.push_inline_code_suggestions(data_above_threshold)\n        except Exception as e:\n            get_logger().error(f\"Failed to publish dual publishing suggestions, error: {e}\")\n\n    @staticmethod\n    def publish_persistent_comment_with_history(git_provider: GitProvider,\n                                                pr_comment: str,\n                                                initial_header: str,\n                                                update_header: bool = True,\n                                                name='review',\n                                                final_update_message=True,\n                                                max_previous_comments=4,\n                                                progress_response=None,\n                                                only_fold=False):\n\n        def _extract_link(comment_text: str):\n            r = re.compile(r\"<!--.*?-->\")\n            match = r.search(comment_text)\n\n            up_to_commit_txt = \"\"\n            if match:\n                up_to_commit_txt = f\" up to commit {match.group(0)[4:-3].strip()}\"\n            return up_to_commit_txt\n\n        if isinstance(git_provider, AzureDevopsProvider): # get_latest_commit_url is not supported yet\n            if progress_response:\n                git_provider.edit_comment(progress_response, pr_comment)\n                new_comment = progress_response\n            else:\n                new_comment = git_provider.publish_comment(pr_comment)\n            return new_comment\n\n        history_header = f\"#### Previous suggestions\\n\"\n        last_commit_num = git_provider.get_latest_commit_url().split('/')[-1][:7]\n        if only_fold: # A user clicked on the 'self-review' checkbox\n            text = get_settings().pr_code_suggestions.code_suggestions_self_review_text\n            latest_suggestion_header = f\"\\n\\n- [x]  {text}\"\n        else:\n            latest_suggestion_header = f\"Latest suggestions up to {last_commit_num}\"\n        latest_commit_html_comment = f\"<!-- {last_commit_num} -->\"\n        found_comment = None\n\n        if max_previous_comments > 0:\n            try:\n                prev_comments = list(git_provider.get_issue_comments())\n                for comment in prev_comments:\n                    if comment.body.startswith(initial_header):\n                        prev_suggestions = comment.body\n                        found_comment = comment\n                        comment_url = git_provider.get_comment_url(comment)\n\n                        if history_header.strip() not in comment.body:\n                            # no history section\n                            # extract everything between <table> and </table> in comment.body including <table> and </table>\n                            table_index = comment.body.find(\"<table>\")\n                            if table_index == -1:\n                                git_provider.edit_comment(comment, pr_comment)\n                                continue\n                            # find http link from comment.body[:table_index]\n                            up_to_commit_txt = _extract_link(comment.body[:table_index])\n                            prev_suggestion_table = comment.body[\n                                                    table_index:comment.body.rfind(\"</table>\") + len(\"</table>\")]\n\n                            tick = \" \" if \"\" in prev_suggestion_table else \"\"\n                            # surround with details tag\n                            prev_suggestion_table = f\"<details><summary>{tick}{name.capitalize()}{up_to_commit_txt}</summary>\\n<br>{prev_suggestion_table}\\n\\n</details>\"\n\n                            new_suggestion_table = pr_comment.replace(initial_header, \"\").strip()\n\n                            pr_comment_updated = f\"{initial_header}\\n{latest_commit_html_comment}\\n\\n\"\n                            pr_comment_updated += f\"{latest_suggestion_header}\\n{new_suggestion_table}\\n\\n___\\n\\n\"\n                            pr_comment_updated += f\"{history_header}{prev_suggestion_table}\\n\"\n                        else:\n                            # get the text of the previous suggestions until the latest commit\n                            sections = prev_suggestions.split(history_header.strip())\n                            latest_table = sections[0].strip()\n                            prev_suggestion_table = sections[1].replace(history_header, \"\").strip()\n\n                            # get text after the latest_suggestion_header in comment.body\n                            table_ind = latest_table.find(\"<table>\")\n                            up_to_commit_txt = _extract_link(latest_table[:table_ind])\n\n                            latest_table = latest_table[table_ind:latest_table.rfind(\"</table>\") + len(\"</table>\")]\n                            # enforce max_previous_comments\n                            count = prev_suggestions.count(f\"\\n<details><summary>{name.capitalize()}\")\n                            count += prev_suggestions.count(f\"\\n<details><summary> {name.capitalize()}\")\n                            if count >= max_previous_comments:\n                                # remove the oldest suggestion\n                                prev_suggestion_table = prev_suggestion_table[:prev_suggestion_table.rfind(\n                                    f\"<details><summary>{name.capitalize()} up to commit\")]\n\n                            tick = \" \" if \"\" in latest_table else \"\"\n                            # Add to the prev_suggestions section\n                            last_prev_table = f\"\\n<details><summary>{tick}{name.capitalize()}{up_to_commit_txt}</summary>\\n<br>{latest_table}\\n\\n</details>\"\n                            prev_suggestion_table = last_prev_table + \"\\n\" + prev_suggestion_table\n\n                            new_suggestion_table = pr_comment.replace(initial_header, \"\").strip()\n\n                            pr_comment_updated = f\"{initial_header}\\n\"\n                            pr_comment_updated += f\"{latest_commit_html_comment}\\n\\n\"\n                            pr_comment_updated += f\"{latest_suggestion_header}\\n\\n{new_suggestion_table}\\n\\n\"\n                            pr_comment_updated += \"___\\n\\n\"\n                            pr_comment_updated += f\"{history_header}\\n\"\n                            pr_comment_updated += f\"{prev_suggestion_table}\\n\"\n\n                        get_logger().info(f\"Persistent mode - updating comment {comment_url} to latest {name} message\")\n                        if progress_response:  # publish to 'progress_response' comment, because it refreshes immediately\n                            git_provider.edit_comment(progress_response, pr_comment_updated)\n                            git_provider.remove_comment(comment)\n                            comment = progress_response\n                        else:\n                            git_provider.edit_comment(comment, pr_comment_updated)\n                        return comment\n            except Exception as e:\n                get_logger().exception(f\"Failed to update persistent review, error: {e}\")\n                pass\n\n        # if we are here, we did not find a previous comment to update\n        body = pr_comment.replace(initial_header, \"\").strip()\n        pr_comment = f\"{initial_header}\\n\\n{latest_commit_html_comment}\\n\\n{body}\\n\\n\"\n        if progress_response:\n            git_provider.edit_comment(progress_response, pr_comment)\n            new_comment = progress_response\n        else:\n            new_comment = git_provider.publish_comment(pr_comment)\n        return new_comment\n\n\n    def extract_link(self, s):\n        r = re.compile(r\"<!--.*?-->\")\n        match = r.search(s)\n\n        up_to_commit_txt = \"\"\n        if match:\n            up_to_commit_txt = f\" up to commit {match.group(0)[4:-3].strip()}\"\n        return up_to_commit_txt\n\n    async def _prepare_prediction(self, model: str) -> dict:\n        self.patches_diff = get_pr_diff(self.git_provider,\n                                        self.token_handler,\n                                        model,\n                                        add_line_numbers_to_hunks=True,\n                                        disable_extra_lines=False)\n        self.patches_diff_list = [self.patches_diff]\n        self.patches_diff_no_line_number = self.remove_line_numbers([self.patches_diff])[0]\n\n        if self.patches_diff:\n            get_logger().debug(f\"PR diff\", artifact=self.patches_diff)\n            self.prediction = await self._get_prediction(model, self.patches_diff, self.patches_diff_no_line_number)\n        else:\n            get_logger().warning(f\"Empty PR diff\")\n            self.prediction = None\n\n        data = self.prediction\n        return data\n\n    async def _get_prediction(self, model: str, patches_diff: str, patches_diff_no_line_number: str) -> dict:\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = patches_diff  # update diff\n        variables[\"diff_no_line_numbers\"] = patches_diff_no_line_number  # update diff\n        environment = Environment(undefined=StrictUndefined)\n        system_prompt = environment.from_string(self.pr_code_suggestions_prompt_system).render(variables)\n        user_prompt = environment.from_string(get_settings().pr_code_suggestions_prompt.user).render(variables)\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model, temperature=get_settings().config.temperature, system=system_prompt, user=user_prompt)\n        if not get_settings().config.publish_output:\n            get_settings().system_prompt = system_prompt\n            get_settings().user_prompt = user_prompt\n\n        # load suggestions from the AI response\n        data = self._prepare_pr_code_suggestions(response)\n\n        # self-reflect on suggestions (mandatory, since line numbers are generated now here)\n        model_reflection = get_settings().config.model\n        response_reflect = await self.self_reflect_on_suggestions(data[\"code_suggestions\"],\n                                                                  patches_diff, model=model_reflection)\n        if response_reflect:\n            await self.analyze_self_reflection_response(data, response_reflect)\n        else:\n            # get_logger().error(f\"Could not self-reflect on suggestions. using default score 7\")\n            for i, suggestion in enumerate(data[\"code_suggestions\"]):\n                suggestion[\"score\"] = 7\n                suggestion[\"score_why\"] = \"\"\n\n        return data\n\n    async def analyze_self_reflection_response(self, data, response_reflect):\n        response_reflect_yaml = load_yaml(response_reflect)\n        code_suggestions_feedback = response_reflect_yaml.get(\"code_suggestions\", [])\n        if code_suggestions_feedback and len(code_suggestions_feedback) == len(data[\"code_suggestions\"]):\n            for i, suggestion in enumerate(data[\"code_suggestions\"]):\n                try:\n                    suggestion[\"score\"] = code_suggestions_feedback[i][\"suggestion_score\"]\n                    suggestion[\"score_why\"] = code_suggestions_feedback[i][\"why\"]\n\n                    if 'relevant_lines_start' not in suggestion:\n                        relevant_lines_start = code_suggestions_feedback[i].get('relevant_lines_start', -1)\n                        relevant_lines_end = code_suggestions_feedback[i].get('relevant_lines_end', -1)\n                        suggestion['relevant_lines_start'] = relevant_lines_start\n                        suggestion['relevant_lines_end'] = relevant_lines_end\n                        if relevant_lines_start < 0 or relevant_lines_end < 0:\n                            suggestion[\"score\"] = 0\n\n                    try:\n                        if get_settings().config.publish_output:\n                            if not suggestion[\"score\"]:\n                                score = -1\n                            else:\n                                score = int(suggestion[\"score\"])\n                            label = suggestion[\"label\"].lower().strip()\n                            label = label.replace('<br>', ' ')\n                            suggestion_statistics_dict = {'score': score,\n                                                          'label': label}\n                            get_logger().info(f\"PR-Agent suggestions statistics\",\n                                              statistics=suggestion_statistics_dict, analytics=True)\n                    except Exception as e:\n                        get_logger().error(f\"Failed to log suggestion statistics, error: {e}\")\n                        pass\n\n                except Exception as e:  #\n                    get_logger().error(f\"Error processing suggestion score {i}\",\n                                       artifact={\"suggestion\": suggestion,\n                                                 \"code_suggestions_feedback\": code_suggestions_feedback[i]})\n                    suggestion[\"score\"] = 7\n                    suggestion[\"score_why\"] = \"\"\n\n                suggestion = self.validate_one_liner_suggestion_not_repeating_code(suggestion)\n\n                # if the before and after code is the same, clear one of them\n                try:\n                    if suggestion['existing_code'] == suggestion['improved_code']:\n                        get_logger().debug(\n                            f\"edited improved suggestion {i + 1}, because equal to existing code: {suggestion['existing_code']}\")\n                        if get_settings().pr_code_suggestions.commitable_code_suggestions:\n                            suggestion['improved_code'] = \"\"  # we need 'existing_code' to locate the code in the PR\n                        else:\n                            suggestion['existing_code'] = \"\"\n                except Exception as e:\n                    get_logger().error(f\"Error processing suggestion {i + 1}, error: {e}\")\n\n    @staticmethod\n    def _truncate_if_needed(suggestion):\n        max_code_suggestion_length = get_settings().get(\"PR_CODE_SUGGESTIONS.MAX_CODE_SUGGESTION_LENGTH\", 0)\n        suggestion_truncation_message = get_settings().get(\"PR_CODE_SUGGESTIONS.SUGGESTION_TRUNCATION_MESSAGE\", \"\")\n        if max_code_suggestion_length > 0:\n            if len(suggestion['improved_code']) > max_code_suggestion_length:\n                get_logger().info(f\"Truncated suggestion from {len(suggestion['improved_code'])} \"\n                                  f\"characters to {max_code_suggestion_length} characters\")\n                suggestion['improved_code'] = suggestion['improved_code'][:max_code_suggestion_length]\n                suggestion['improved_code'] += f\"\\n{suggestion_truncation_message}\"\n        return suggestion\n\n    def _prepare_pr_code_suggestions(self, predictions: str) -> Dict:\n        data = load_yaml(predictions.strip(),\n                         keys_fix_yaml=[\"relevant_file\", \"suggestion_content\", \"existing_code\", \"improved_code\"],\n                         first_key=\"code_suggestions\", last_key=\"label\")\n        if isinstance(data, list):\n            data = {'code_suggestions': data}\n\n        # remove or edit invalid suggestions\n        suggestion_list = []\n        one_sentence_summary_list = []\n        for i, suggestion in enumerate(data['code_suggestions']):\n            try:\n                needed_keys = ['one_sentence_summary', 'label', 'relevant_file']\n                is_valid_keys = True\n                for key in needed_keys:\n                    if key not in suggestion:\n                        is_valid_keys = False\n                        get_logger().debug(\n                            f\"Skipping suggestion {i + 1}, because it does not contain '{key}':\\n'{suggestion}\")\n                        break\n                if not is_valid_keys:\n                    continue\n\n                if get_settings().get(\"pr_code_suggestions.focus_only_on_problems\", False):\n                    CRITICAL_LABEL = 'critical'\n                    if CRITICAL_LABEL in suggestion['label'].lower(): # we want the published labels to be less declarative\n                        suggestion['label'] = 'possible issue'\n\n                if suggestion['one_sentence_summary'] in one_sentence_summary_list:\n                    get_logger().debug(f\"Skipping suggestion {i + 1}, because it is a duplicate: {suggestion}\")\n                    continue\n\n                if 'const' in suggestion['suggestion_content'] and 'instead' in suggestion[\n                    'suggestion_content'] and 'let' in suggestion['suggestion_content']:\n                    get_logger().debug(\n                        f\"Skipping suggestion {i + 1}, because it uses 'const instead let': {suggestion}\")\n                    continue\n\n                if ('existing_code' in suggestion) and ('improved_code' in suggestion):\n                    suggestion = self._truncate_if_needed(suggestion)\n                    one_sentence_summary_list.append(suggestion['one_sentence_summary'])\n                    suggestion_list.append(suggestion)\n                else:\n                    get_logger().info(\n                        f\"Skipping suggestion {i + 1}, because it does not contain 'existing_code' or 'improved_code': {suggestion}\")\n            except Exception as e:\n                get_logger().error(f\"Error processing suggestion {i + 1}: {suggestion}, error: {e}\")\n        data['code_suggestions'] = suggestion_list\n\n        return data\n\n    async def push_inline_code_suggestions(self, data):\n        code_suggestions = []\n\n        if not data['code_suggestions']:\n            get_logger().info('No suggestions found to improve this PR.')\n            if self.progress_response:\n                return self.git_provider.edit_comment(self.progress_response,\n                                                      body='No suggestions found to improve this PR.')\n            else:\n                return self.git_provider.publish_comment('No suggestions found to improve this PR.')\n\n        for d in data['code_suggestions']:\n            try:\n                if get_settings().config.verbosity_level >= 2:\n                    get_logger().info(f\"suggestion: {d}\")\n                relevant_file = d['relevant_file'].strip()\n                relevant_lines_start = int(d['relevant_lines_start'])  # absolute position\n                relevant_lines_end = int(d['relevant_lines_end'])\n                content = d['suggestion_content'].rstrip()\n                new_code_snippet = d['improved_code'].rstrip()\n                label = d['label'].strip()\n\n                if new_code_snippet:\n                    new_code_snippet = self.dedent_code(relevant_file, relevant_lines_start, new_code_snippet)\n\n                if d.get('score'):\n                    body = f\"**Suggestion:** {content} [{label}, importance: {d.get('score')}]\\n```suggestion\\n\" + new_code_snippet + \"\\n```\"\n                else:\n                    body = f\"**Suggestion:** {content} [{label}]\\n```suggestion\\n\" + new_code_snippet + \"\\n```\"\n                code_suggestions.append({'body': body, 'relevant_file': relevant_file,\n                                         'relevant_lines_start': relevant_lines_start,\n                                         'relevant_lines_end': relevant_lines_end,\n                                         'original_suggestion': d})\n            except Exception:\n                get_logger().info(f\"Could not parse suggestion: {d}\")\n\n        is_successful = self.git_provider.publish_code_suggestions(code_suggestions)\n        if not is_successful:\n            get_logger().info(\"Failed to publish code suggestions, trying to publish each suggestion separately\")\n            for code_suggestion in code_suggestions:\n                self.git_provider.publish_code_suggestions([code_suggestion])\n\n    def dedent_code(self, relevant_file, relevant_lines_start, new_code_snippet):\n        try:  # dedent code snippet\n            self.diff_files = self.git_provider.diff_files if self.git_provider.diff_files \\\n                else self.git_provider.get_diff_files()\n            original_initial_line = None\n            for file in self.diff_files:\n                if file.filename.strip() == relevant_file:\n                    if file.head_file:\n                        file_lines = file.head_file.splitlines()\n                        if relevant_lines_start > len(file_lines):\n                            get_logger().warning(\n                                \"Could not dedent code snippet, because relevant_lines_start is out of range\",\n                                artifact={'filename': file.filename,\n                                          'file_content': file.head_file,\n                                          'relevant_lines_start': relevant_lines_start,\n                                          'new_code_snippet': new_code_snippet})\n                            return new_code_snippet\n                        else:\n                            original_initial_line = file_lines[relevant_lines_start - 1]\n                    else:\n                        get_logger().warning(\"Could not dedent code snippet, because head_file is missing\",\n                                             artifact={'filename': file.filename,\n                                                       'relevant_lines_start': relevant_lines_start,\n                                                       'new_code_snippet': new_code_snippet})\n                        return new_code_snippet\n                    break\n            if original_initial_line:\n                suggested_initial_line = new_code_snippet.splitlines()[0]\n                original_initial_spaces = len(original_initial_line) - len(original_initial_line.lstrip())\n                suggested_initial_spaces = len(suggested_initial_line) - len(suggested_initial_line.lstrip())\n                delta_spaces = original_initial_spaces - suggested_initial_spaces\n                if delta_spaces > 0:\n                    new_code_snippet = textwrap.indent(new_code_snippet, delta_spaces * \" \").rstrip('\\n')\n        except Exception as e:\n            get_logger().error(f\"Error when dedenting code snippet for file {relevant_file}, error: {e}\")\n\n        return new_code_snippet\n\n    def validate_one_liner_suggestion_not_repeating_code(self, suggestion):\n        try:\n            existing_code = suggestion.get('existing_code', '').strip()\n            if '...' in existing_code:\n                return suggestion\n            new_code = suggestion.get('improved_code', '').strip()\n\n            relevant_file = suggestion.get('relevant_file', '').strip()\n            diff_files = self.git_provider.get_diff_files()\n            for file in diff_files:\n                if file.filename.strip() == relevant_file:\n                    # protections\n                    if not file.head_file:\n                        get_logger().info(f\"head_file is empty\")\n                        return suggestion\n                    head_file = file.head_file\n                    base_file = file.base_file\n                    if existing_code in base_file and existing_code not in head_file and new_code in head_file:\n                        suggestion[\"score\"] = 0\n                        get_logger().warning(\n                            f\"existing_code is in the base file but not in the head file, setting score to 0\",\n                            artifact={\"suggestion\": suggestion})\n        except Exception as e:\n            get_logger().exception(f\"Error validating one-liner suggestion\", artifact={\"error\": e})\n\n        return suggestion\n\n    def remove_line_numbers(self, patches_diff_list: List[str]) -> List[str]:\n        # create a copy of the patches_diff_list, without line numbers for '__new hunk__' sections\n        try:\n            self.patches_diff_list_no_line_numbers = []\n            for patches_diff in self.patches_diff_list:\n                patches_diff_lines = patches_diff.splitlines()\n                for i, line in enumerate(patches_diff_lines):\n                    if line.strip():\n                        if line.isnumeric():\n                            patches_diff_lines[i] = ''\n                        elif line[0].isdigit():\n                            # find the first letter in the line that starts with a valid letter\n                            for j, char in enumerate(line):\n                                if not char.isdigit():\n                                    patches_diff_lines[i] = line[j + 1:]\n                                    break\n                self.patches_diff_list_no_line_numbers.append('\\n'.join(patches_diff_lines))\n            return self.patches_diff_list_no_line_numbers\n        except Exception as e:\n            get_logger().error(f\"Error removing line numbers from patches_diff_list, error: {e}\")\n            return patches_diff_list\n\n    async def _prepare_prediction_extended(self, model: str) -> dict:\n        # get PR diff\n        if get_settings().pr_code_suggestions.decouple_hunks:\n            self.patches_diff_list = get_pr_multi_diffs(self.git_provider,\n                                                        self.token_handler,\n                                                        model,\n                                                        max_calls=get_settings().pr_code_suggestions.max_number_of_calls,\n                                                        add_line_numbers=True)  # decouple hunk with line numbers\n            self.patches_diff_list_no_line_numbers = self.remove_line_numbers(self.patches_diff_list)  # decouple hunk\n\n        else:\n            # non-decoupled hunks\n            self.patches_diff_list_no_line_numbers = get_pr_multi_diffs(self.git_provider,\n                                                                        self.token_handler,\n                                                                        model,\n                                                                        max_calls=get_settings().pr_code_suggestions.max_number_of_calls,\n                                                                        add_line_numbers=False)\n            self.patches_diff_list = await self.convert_to_decoupled_with_line_numbers(\n                self.patches_diff_list_no_line_numbers, model)\n            if not self.patches_diff_list:\n                # fallback to decoupled hunks\n                self.patches_diff_list = get_pr_multi_diffs(self.git_provider,\n                                                            self.token_handler,\n                                                            model,\n                                                            max_calls=get_settings().pr_code_suggestions.max_number_of_calls,\n                                                            add_line_numbers=True)  # decouple hunk with line numbers\n\n        if self.patches_diff_list:\n            get_logger().info(f\"Number of PR chunk calls: {len(self.patches_diff_list)}\")\n            get_logger().debug(f\"PR diff:\", artifact=self.patches_diff_list)\n\n            # parallelize calls to AI:\n            if get_settings().pr_code_suggestions.parallel_calls:\n                prediction_list = await asyncio.gather(\n                    *[self._get_prediction(model, patches_diff, patches_diff_no_line_numbers) for\n                      patches_diff, patches_diff_no_line_numbers in\n                      zip(self.patches_diff_list, self.patches_diff_list_no_line_numbers)])\n                self.prediction_list = prediction_list\n            else:\n                prediction_list = []\n                for patches_diff, patches_diff_no_line_numbers in zip(self.patches_diff_list, self.patches_diff_list_no_line_numbers):\n                    prediction = await self._get_prediction(model, patches_diff, patches_diff_no_line_numbers)\n                    prediction_list.append(prediction)\n\n            data = {\"code_suggestions\": []}\n            for j, predictions in enumerate(prediction_list):  # each call adds an element to the list\n                if \"code_suggestions\" in predictions:\n                    score_threshold = max(1, int(get_settings().pr_code_suggestions.suggestions_score_threshold))\n                    for i, prediction in enumerate(predictions[\"code_suggestions\"]):\n                        try:\n                            score = int(prediction.get(\"score\", 1))\n                            if score >= score_threshold:\n                                data[\"code_suggestions\"].append(prediction)\n                            else:\n                                get_logger().info(\n                                    f\"Removing suggestions {i} from call {j}, because score is {score}, and score_threshold is {score_threshold}\",\n                                    artifact=prediction)\n                        except Exception as e:\n                            get_logger().error(f\"Error getting PR diff for suggestion {i} in call {j}, error: {e}\",\n                                               artifact={\"prediction\": prediction})\n            self.data = data\n        else:\n            get_logger().warning(f\"Empty PR diff list\")\n            self.data = data = None\n        return data\n\n    async def convert_to_decoupled_with_line_numbers(self, patches_diff_list_no_line_numbers, model) -> List[str]:\n        with get_logger().contextualize(sub_feature='convert_to_decoupled_with_line_numbers'):\n            try:\n                patches_diff_list = []\n                for patch_prompt in patches_diff_list_no_line_numbers:\n                    file_prefix = \"## File: \"\n                    patches = patch_prompt.strip().split(f\"\\n{file_prefix}\")\n                    patches_new = copy.deepcopy(patches)\n                    for i in range(len(patches_new)):\n                        if i == 0:\n                            prefix = patches_new[i].split(\"\\n@@\")[0].strip()\n                        else:\n                            prefix = file_prefix + patches_new[i].split(\"\\n@@\")[0][1:]\n                            prefix = prefix.strip()\n                        patches_new[i] = prefix + '\\n\\n' + decouple_and_convert_to_hunks_with_lines_numbers(patches_new[i],\n                                                                                                          file=None).strip()\n                        patches_new[i] = patches_new[i].strip()\n                    patch_final = \"\\n\\n\\n\".join(patches_new)\n                    if model in MAX_TOKENS:\n                        max_tokens_full = MAX_TOKENS[\n                            model]  # note - here we take the actual max tokens, without any reductions. we do aim to get the full documentation website in the prompt\n                    else:\n                        max_tokens_full = get_max_tokens(model)\n                    delta_output = 2000\n                    token_count = self.token_handler.count_tokens(patch_final)\n                    if token_count > max_tokens_full - delta_output:\n                        get_logger().warning(\n                            f\"Token count {token_count} exceeds the limit {max_tokens_full - delta_output}. clipping the tokens\")\n                        patch_final = clip_tokens(patch_final, max_tokens_full - delta_output)\n                    patches_diff_list.append(patch_final)\n                return patches_diff_list\n            except Exception as e:\n                get_logger().exception(f\"Error converting to decoupled with line numbers\",\n                                       artifact={'patches_diff_list_no_line_numbers': patches_diff_list_no_line_numbers})\n                return []\n\n    def generate_summarized_suggestions(self, data: Dict) -> str:\n        try:\n            pr_body = \"## PR Code Suggestions \\n\\n\"\n\n            if len(data.get('code_suggestions', [])) == 0:\n                pr_body += \"No suggestions found to improve this PR.\"\n                return pr_body\n\n            if get_settings().pr_code_suggestions.enable_intro_text and get_settings().config.is_auto_command:\n                pr_body += \"Explore these optional code suggestions:\\n\\n\"\n\n            language_extension_map_org = get_settings().language_extension_map_org\n            extension_to_language = {}\n            for language, extensions in language_extension_map_org.items():\n                for ext in extensions:\n                    extension_to_language[ext] = language\n\n            pr_body += \"<table>\"\n            header = f\"Suggestion\"\n            delta = 66\n            header += \"&nbsp; \" * delta\n            pr_body += f\"\"\"<thead><tr><td><strong>Category</strong></td><td align=left><strong>{header}</strong></td><td align=center><strong>Impact</strong></td></tr>\"\"\"\n            pr_body += \"\"\"<tbody>\"\"\"\n            suggestions_labels = dict()\n            # add all suggestions related to each label\n            for suggestion in data['code_suggestions']:\n                label = suggestion['label'].strip().strip(\"'\").strip('\"')\n                if label not in suggestions_labels:\n                    suggestions_labels[label] = []\n                suggestions_labels[label].append(suggestion)\n\n            # sort suggestions_labels by the suggestion with the highest score\n            suggestions_labels = dict(\n                sorted(suggestions_labels.items(), key=lambda x: max([s['score'] for s in x[1]]), reverse=True))\n            # sort the suggestions inside each label group by score\n            for label, suggestions in suggestions_labels.items():\n                suggestions_labels[label] = sorted(suggestions, key=lambda x: x['score'], reverse=True)\n\n            counter_suggestions = 0\n            for label, suggestions in suggestions_labels.items():\n                num_suggestions = len(suggestions)\n                pr_body += f\"\"\"<tr><td rowspan={num_suggestions}>{label.capitalize()}</td>\\n\"\"\"\n                for i, suggestion in enumerate(suggestions):\n\n                    relevant_file = suggestion['relevant_file'].strip()\n                    relevant_lines_start = int(suggestion['relevant_lines_start'])\n                    relevant_lines_end = int(suggestion['relevant_lines_end'])\n                    range_str = \"\"\n                    if relevant_lines_start == relevant_lines_end:\n                        range_str = f\"[{relevant_lines_start}]\"\n                    else:\n                        range_str = f\"[{relevant_lines_start}-{relevant_lines_end}]\"\n\n                    try:\n                        code_snippet_link = self.git_provider.get_line_link(relevant_file, relevant_lines_start,\n                                                                            relevant_lines_end)\n                    except:\n                        code_snippet_link = \"\"\n                    # add html table for each suggestion\n\n                    suggestion_content = suggestion['suggestion_content'].rstrip()\n                    CHAR_LIMIT_PER_LINE = 84\n                    suggestion_content = insert_br_after_x_chars(suggestion_content, CHAR_LIMIT_PER_LINE)\n                    # pr_body += f\"<tr><td><details><summary>{suggestion_content}</summary>\"\n                    existing_code = suggestion['existing_code'].rstrip() + \"\\n\"\n                    improved_code = suggestion['improved_code'].rstrip() + \"\\n\"\n\n                    diff = difflib.unified_diff(existing_code.split('\\n'),\n                                                improved_code.split('\\n'), n=999)\n                    patch_orig = \"\\n\".join(diff)\n                    patch = \"\\n\".join(patch_orig.splitlines()[5:]).strip('\\n')\n\n                    example_code = \"\"\n                    example_code += f\"```diff\\n{patch.rstrip()}\\n```\\n\"\n                    if i == 0:\n                        pr_body += f\"\"\"<td>\\n\\n\"\"\"\n                    else:\n                        pr_body += f\"\"\"<tr><td>\\n\\n\"\"\"\n                    suggestion_summary = suggestion['one_sentence_summary'].strip().rstrip('.')\n                    if \"'<\" in suggestion_summary and \">'\" in suggestion_summary:\n                        # escape the '<' and '>' characters, otherwise they are interpreted as html tags\n                        get_logger().info(f\"Escaped suggestion summary: {suggestion_summary}\")\n                        suggestion_summary = suggestion_summary.replace(\"'<\", \"`<\")\n                        suggestion_summary = suggestion_summary.replace(\">'\", \">`\")\n                    if '`' in suggestion_summary:\n                        suggestion_summary = replace_code_tags(suggestion_summary)\n\n                    pr_body += f\"\"\"\\n\\n<details><summary>{suggestion_summary}</summary>\\n\\n___\\n\\n\"\"\"\n                    pr_body += f\"\"\"\n**{suggestion_content}**\n\n[{relevant_file} {range_str}]({code_snippet_link})\n\n{example_code.rstrip()}\n\"\"\"\n                    if suggestion.get('score_why'):\n                        pr_body += f\"<details><summary>Suggestion importance[1-10]: {suggestion['score']}</summary>\\n\\n\"\n                        pr_body += f\"__\\n\\nWhy: {suggestion['score_why']}\\n\\n\"\n                        pr_body += f\"</details>\"\n\n                    pr_body += f\"</details>\"\n\n                    # # add another column for 'score'\n                    score_int = int(suggestion.get('score', 0))\n                    score_str = f\"{score_int}\"\n                    if get_settings().pr_code_suggestions.new_score_mechanism:\n                        score_str = self.get_score_str(score_int)\n                    pr_body += f\"</td><td align=center>{score_str}\\n\\n\"\n\n                    pr_body += f\"</td></tr>\"\n                    counter_suggestions += 1\n\n                # pr_body += \"</details>\"\n                # pr_body += \"\"\"</td></tr>\"\"\"\n            pr_body += \"\"\"</tr></tbody></table>\"\"\"\n            return pr_body\n        except Exception as e:\n            get_logger().info(f\"Failed to publish summarized code suggestions, error: {e}\")\n            return \"\"\n\n    def get_score_str(self, score: int) -> str:\n        th_high = get_settings().pr_code_suggestions.get('new_score_mechanism_th_high', 9)\n        th_medium = get_settings().pr_code_suggestions.get('new_score_mechanism_th_medium', 7)\n        if score >= th_high:\n            return \"High\"\n        elif score >= th_medium:\n            return \"Medium\"\n        else:  # score < 7\n            return \"Low\"\n\n    async def self_reflect_on_suggestions(self,\n                                          suggestion_list: List,\n                                          patches_diff: str,\n                                          model: str,\n                                          prev_suggestions_str: str = \"\",\n                                          dedicated_prompt: str = \"\") -> str:\n        if not suggestion_list:\n            return \"\"\n\n        try:\n            suggestion_str = \"\"\n            for i, suggestion in enumerate(suggestion_list):\n                suggestion_str += f\"suggestion {i + 1}: \" + str(suggestion) + '\\n\\n'\n\n            variables = {'suggestion_list': suggestion_list,\n                         'suggestion_str': suggestion_str,\n                         \"diff\": patches_diff,\n                         'num_code_suggestions': len(suggestion_list),\n                         'prev_suggestions_str': prev_suggestions_str,\n                         \"is_ai_metadata\": get_settings().get(\"config.enable_ai_metadata\", False),\n                         'duplicate_prompt_examples': get_settings().config.get('duplicate_prompt_examples', False)}\n            environment = Environment(undefined=StrictUndefined)\n\n            if dedicated_prompt:\n                system_prompt_reflect = environment.from_string(\n                    get_settings().get(dedicated_prompt).system).render(variables)\n                user_prompt_reflect = environment.from_string(\n                    get_settings().get(dedicated_prompt).user).render(variables)\n            else:\n                system_prompt_reflect = environment.from_string(\n                    get_settings().pr_code_suggestions_reflect_prompt.system).render(variables)\n                user_prompt_reflect = environment.from_string(\n                    get_settings().pr_code_suggestions_reflect_prompt.user).render(variables)\n\n            with get_logger().contextualize(command=\"self_reflect_on_suggestions\"):\n                response_reflect, finish_reason_reflect = await self.ai_handler.chat_completion(model=model,\n                                                                                                system=system_prompt_reflect,\n                                                                                                user=user_prompt_reflect)\n        except Exception as e:\n            get_logger().info(f\"Could not reflect on suggestions, error: {e}\")\n            return \"\"\n        return response_reflect",
    "start_line": 33,
    "end_line": 950,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRCodeSuggestions",
    "component_id": "pr_agent.tools.pr_code_suggestions.PRCodeSuggestions"
  },
  "pr_agent.tools.pr_config.PRConfig": {
    "id": "pr_agent.tools.pr_config.PRConfig",
    "name": "PRConfig",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_config.py",
    "relative_path": "pr_agent/tools/pr_config.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.config_loader.get_settings",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "class PRConfig:\n    \"\"\"\n    The PRConfig class is responsible for listing all configuration options available for the user.\n    \"\"\"\n    def __init__(self, pr_url: str, args=None, ai_handler=None):\n        \"\"\"\n        Initialize the PRConfig object with the necessary attributes and objects to comment on a pull request.\n\n        Args:\n            pr_url (str): The URL of the pull request to be reviewed.\n            args (list, optional): List of arguments passed to the PRReviewer class. Defaults to None.\n        \"\"\"\n        self.git_provider = get_git_provider()(pr_url)\n\n    async def run(self):\n        get_logger().info('Getting configuration settings...')\n        get_logger().info('Preparing configs...')\n        pr_comment = self._prepare_pr_configs()\n        if get_settings().config.publish_output:\n            get_logger().info('Pushing configs...')\n            self.git_provider.publish_comment(pr_comment)\n            self.git_provider.remove_initial_comment()\n        return \"\"\n\n    def _prepare_pr_configs(self) -> str:\n        conf_file = get_settings().find_file(\"configuration.toml\")\n        conf_settings = Dynaconf(settings_files=[conf_file])\n        configuration_headers = [header.lower() for header in conf_settings.keys()]\n        relevant_configs = {\n            header: configs for header, configs in get_settings().to_dict().items()\n            if (header.lower().startswith(\"pr_\") or header.lower().startswith(\"config\")) and header.lower() in configuration_headers\n        }\n\n        skip_keys = ['ai_disclaimer', 'ai_disclaimer_title', 'ANALYTICS_FOLDER', 'secret_provider', \"skip_keys\", \"app_id\", \"redirect\",\n                     'trial_prefix_message', 'no_eligible_message', 'identity_provider', 'ALLOWED_REPOS',\n                     'APP_NAME', 'PERSONAL_ACCESS_TOKEN', 'shared_secret', 'key', 'AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'user_token',\n                     'private_key', 'private_key_id', 'client_id', 'client_secret', 'token', 'bearer_token', 'jira_api_token','webhook_secret']\n        partial_skip_keys = ['key', 'secret', 'token', 'private']\n        extra_skip_keys = get_settings().config.get('config.skip_keys', [])\n        if extra_skip_keys:\n            skip_keys.extend(extra_skip_keys)\n        skip_keys_lower = [key.lower() for key in skip_keys]\n\n\n        markdown_text = \"<details> <summary><strong> PR-Agent Configurations:</strong></summary> \\n\\n\"\n        markdown_text += f\"\\n\\n```yaml\\n\\n\"\n        for header, configs in relevant_configs.items():\n            if configs:\n                markdown_text += \"\\n\\n\"\n                markdown_text += f\"==================== {header} ====================\"\n            for key, value in configs.items():\n                if key.lower() in skip_keys_lower:\n                    continue\n                if any(skip_key in key.lower() for skip_key in partial_skip_keys):\n                    continue\n                markdown_text += f\"\\n{header.lower()}.{key.lower()} = {repr(value) if isinstance(value, str) else value}\"\n                markdown_text += \"  \"\n        markdown_text += \"\\n```\"\n        markdown_text += \"\\n</details>\\n\"\n        get_logger().info(f\"Possible Configurations outputted to PR comment\", artifact=markdown_text)\n        return markdown_text",
    "start_line": 8,
    "end_line": 68,
    "has_docstring": true,
    "docstring": "The PRConfig class is responsible for listing all configuration options available for the user.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRConfig",
    "component_id": "pr_agent.tools.pr_config.PRConfig"
  },
  "pr_agent.tools.pr_description.PRDescription": {
    "id": "pr_agent.tools.pr_description.PRDescription",
    "name": "PRDescription",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_description.py",
    "relative_path": "pr_agent/tools/pr_description.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.publish_persistent_comment",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.git_providers.git_provider.get_pr_id",
      "pr_agent.git_providers.git_provider.get_line_link",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.git_providers.__init__.get_git_provider_with_context",
      "pr_agent.git_providers.git_provider.get_pr_labels",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.tools.pr_description.insert_br_after_x_chars",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.get_user_description",
      "pr_agent.algo.utils.get_user_labels",
      "pr_agent.algo.utils.set_custom_labels",
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_latest_commit_url",
      "pr_agent.tools.ticket_pr_compliance_check.extract_and_cache_pr_tickets",
      "pr_agent.git_providers.git_provider.publish_description",
      "pr_agent.algo.utils.show_relevant_configurations",
      "pr_agent.git_providers.git_provider.publish_labels",
      "pr_agent.git_providers.git_provider.get_pr_url",
      "pr_agent.algo.utils.load_yaml",
      "pr_agent.algo.pr_processing.get_pr_diff_multiple_patchs"
    ],
    "source_code": "class PRDescription:\n    def __init__(self, pr_url: str, args: list = None,\n                 ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n        \"\"\"\n        Initialize the PRDescription object with the necessary attributes and objects for generating a PR description\n        using an AI model.\n        Args:\n            pr_url (str): The URL of the pull request.\n            args (list, optional): List of arguments passed to the PRDescription class. Defaults to None.\n        \"\"\"\n        # Initialize the git provider and main PR language\n        self.git_provider = get_git_provider_with_context(pr_url)\n        self.main_pr_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n        self.pr_id = self.git_provider.get_pr_id()\n        self.keys_fix = [\"filename:\", \"language:\", \"changes_summary:\", \"changes_title:\", \"description:\", \"title:\"]\n\n        if get_settings().pr_description.enable_semantic_files_types and not self.git_provider.is_supported(\n                \"gfm_markdown\"):\n            get_logger().debug(f\"Disabling semantic files types for {self.pr_id}, gfm_markdown not supported.\")\n            get_settings().pr_description.enable_semantic_files_types = False\n\n        # Initialize the AI handler\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_pr_language\n\n        # Initialize the variables dictionary\n        self.COLLAPSIBLE_FILE_LIST_THRESHOLD = get_settings().pr_description.get(\"collapsible_file_list_threshold\", 8)\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.git_provider.get_pr_description(full=False),\n            \"language\": self.main_pr_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"extra_instructions\": get_settings().pr_description.extra_instructions,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n            \"enable_custom_labels\": get_settings().config.enable_custom_labels,\n            \"custom_labels_class\": \"\",  # will be filled if necessary in 'set_custom_labels' function\n            \"enable_semantic_files_types\": get_settings().pr_description.enable_semantic_files_types,\n            \"related_tickets\": \"\",\n            \"include_file_summary_changes\": len(self.git_provider.get_diff_files()) <= self.COLLAPSIBLE_FILE_LIST_THRESHOLD,\n            'duplicate_prompt_examples': get_settings().config.get('duplicate_prompt_examples', False),\n        }\n\n        self.user_description = self.git_provider.get_user_description()\n\n        # Initialize the token handler\n        self.token_handler = TokenHandler(\n            self.git_provider.pr,\n            self.vars,\n            get_settings().pr_description_prompt.system,\n            get_settings().pr_description_prompt.user,\n        )\n\n        # Initialize patches_diff and prediction attributes\n        self.patches_diff = None\n        self.prediction = None\n        self.file_label_dict = None\n\n    async def run(self):\n        try:\n            get_logger().info(f\"Generating a PR description for pr_id: {self.pr_id}\")\n            relevant_configs = {'pr_description': dict(get_settings().pr_description),\n                                'config': dict(get_settings().config)}\n            get_logger().debug(\"Relevant configs\", artifacts=relevant_configs)\n            if get_settings().config.publish_output and not get_settings().config.get('is_auto_command', False):\n                self.git_provider.publish_comment(\"Preparing PR description...\", is_temporary=True)\n\n            # ticket extraction if exists\n            await extract_and_cache_pr_tickets(self.git_provider, self.vars)\n\n            await retry_with_fallback_models(self._prepare_prediction, ModelType.WEAK)\n\n            if self.prediction:\n                self._prepare_data()\n            else:\n                get_logger().warning(f\"Empty prediction, PR: {self.pr_id}\")\n                self.git_provider.remove_initial_comment()\n                return None\n\n            if get_settings().pr_description.enable_semantic_files_types:\n                self.file_label_dict = self._prepare_file_labels()\n\n            pr_labels, pr_file_changes = [], []\n            if get_settings().pr_description.publish_labels:\n                pr_labels = self._prepare_labels()\n            else:\n                get_logger().debug(f\"Publishing labels disabled\")\n\n            if get_settings().pr_description.use_description_markers:\n                pr_title, pr_body, changes_walkthrough, pr_file_changes = self._prepare_pr_answer_with_markers()\n            else:\n                pr_title, pr_body, changes_walkthrough, pr_file_changes = self._prepare_pr_answer()\n                if not self.git_provider.is_supported(\n                        \"publish_file_comments\") or not get_settings().pr_description.inline_file_summary:\n                    pr_body += \"\\n\\n\" + changes_walkthrough\n            get_logger().debug(\"PR output\", artifact={\"title\": pr_title, \"body\": pr_body})\n\n            # Add help text if gfm_markdown is supported\n            if self.git_provider.is_supported(\"gfm_markdown\") and get_settings().pr_description.enable_help_text:\n                pr_body += \"<hr>\\n\\n<details> <summary><strong> Describe tool usage guide:</strong></summary><hr> \\n\\n\"\n                pr_body += HelpMessage.get_describe_usage_guide()\n                pr_body += \"\\n</details>\\n\"\n            elif get_settings().pr_description.enable_help_comment and self.git_provider.is_supported(\"gfm_markdown\"):\n                if isinstance(self.git_provider, GithubProvider):\n                    pr_body += ('\\n\\n___\\n\\n> <details> <summary>  Need help?</summary><li>Type <code>/help how to ...</code> '\n                                'in the comments thread for any questions about PR-Agent usage.</li><li>Check out the '\n                                '<a href=\"https://qodo-merge-docs.qodo.ai/usage-guide/\">documentation</a> '\n                                'for more information.</li></details>')\n                else: # gitlab\n                    pr_body += (\"\\n\\n___\\n\\n<details><summary>Need help?</summary>- Type <code>/help how to ...</code> in the comments \"\n                                \"thread for any questions about PR-Agent usage.<br>- Check out the \"\n                                \"<a href='https://qodo-merge-docs.qodo.ai/usage-guide/'>documentation</a> for more information.</details>\")\n            # elif get_settings().pr_description.enable_help_comment:\n            #     pr_body += '\\n\\n___\\n\\n>  **PR-Agent usage**: Comment `/help \"your question\"` on any pull request to receive relevant information'\n\n            # Output the relevant configurations if enabled\n            if get_settings().get('config', {}).get('output_relevant_configurations', False):\n                pr_body += show_relevant_configurations(relevant_section='pr_description')\n\n            if get_settings().config.publish_output:\n\n                # publish labels\n                if get_settings().pr_description.publish_labels and pr_labels and self.git_provider.is_supported(\"get_labels\"):\n                    original_labels = self.git_provider.get_pr_labels(update=True)\n                    get_logger().debug(f\"original labels\", artifact=original_labels)\n                    user_labels = get_user_labels(original_labels)\n                    new_labels = pr_labels + user_labels\n                    get_logger().debug(f\"published labels\", artifact=new_labels)\n                    if sorted(new_labels) != sorted(original_labels):\n                        self.git_provider.publish_labels(new_labels)\n                    else:\n                        get_logger().debug(f\"Labels are the same, not updating\")\n\n                # publish description\n                if get_settings().pr_description.publish_description_as_comment:\n                    full_markdown_description = f\"## Title\\n\\n{pr_title}\\n\\n___\\n{pr_body}\"\n                    if get_settings().pr_description.publish_description_as_comment_persistent:\n                        self.git_provider.publish_persistent_comment(full_markdown_description,\n                                                                     initial_header=\"## Title\",\n                                                                     update_header=True,\n                                                                     name=\"describe\",\n                                                                     final_update_message=False, )\n                    else:\n                        self.git_provider.publish_comment(full_markdown_description)\n                else:\n                    self.git_provider.publish_description(pr_title, pr_body)\n\n                    # publish final update message\n                    if (get_settings().pr_description.final_update_message and not get_settings().config.get('is_auto_command', False)):\n                        latest_commit_url = self.git_provider.get_latest_commit_url()\n                        if latest_commit_url:\n                            pr_url = self.git_provider.get_pr_url()\n                            update_comment = f\"**[PR Description]({pr_url})** updated to latest commit ({latest_commit_url})\"\n                            self.git_provider.publish_comment(update_comment)\n                self.git_provider.remove_initial_comment()\n            else:\n                get_logger().info('PR description, but not published since publish_output is False.')\n                get_settings().data = {\"artifact\": pr_body}\n                return\n        except Exception as e:\n            get_logger().error(f\"Error generating PR description {self.pr_id}: {e}\",\n                               artifact={\"traceback\": traceback.format_exc()})\n\n        return \"\"\n\n    async def _prepare_prediction(self, model: str) -> None:\n        if get_settings().pr_description.use_description_markers and 'pr_agent:' not in self.user_description:\n            get_logger().info(\"Markers were enabled, but user description does not contain markers. skipping AI prediction\")\n            return None\n\n        large_pr_handling = get_settings().pr_description.enable_large_pr_handling and \"pr_description_only_files_prompts\" in get_settings()\n        output = get_pr_diff(self.git_provider, self.token_handler, model, large_pr_handling=large_pr_handling, return_remaining_files=True)\n        if isinstance(output, tuple):\n            patches_diff, remaining_files_list = output\n        else:\n            patches_diff = output\n            remaining_files_list = []\n\n        if not large_pr_handling or patches_diff:\n            self.patches_diff = patches_diff\n            if patches_diff:\n                # generate the prediction\n                get_logger().debug(f\"PR diff\", artifact=self.patches_diff)\n                self.prediction = await self._get_prediction(model, patches_diff, prompt=\"pr_description_prompt\")\n\n                # extend the prediction with additional files not shown\n                if get_settings().pr_description.enable_semantic_files_types:\n                    self.prediction = await self.extend_uncovered_files(self.prediction)\n            else:\n                get_logger().error(f\"Error getting PR diff {self.pr_id}\",\n                                   artifact={\"traceback\": traceback.format_exc()})\n                self.prediction = None\n        else:\n            # get the diff in multiple patches, with the token handler only for the files prompt\n            get_logger().debug('large_pr_handling for describe')\n            token_handler_only_files_prompt = TokenHandler(\n                self.git_provider.pr,\n                self.vars,\n                get_settings().pr_description_only_files_prompts.system,\n                get_settings().pr_description_only_files_prompts.user,\n            )\n            (patches_compressed_list, total_tokens_list, deleted_files_list, remaining_files_list, file_dict,\n             files_in_patches_list) = get_pr_diff_multiple_patchs(\n                self.git_provider, token_handler_only_files_prompt, model)\n\n            # get the files prediction for each patch\n            if not get_settings().pr_description.async_ai_calls:\n                results = []\n                for i, patches in enumerate(patches_compressed_list):  # sync calls\n                    patches_diff = \"\\n\".join(patches)\n                    get_logger().debug(f\"PR diff number {i + 1} for describe files\")\n                    prediction_files = await self._get_prediction(model, patches_diff,\n                                                                  prompt=\"pr_description_only_files_prompts\")\n                    results.append(prediction_files)\n            else:  # async calls\n                tasks = []\n                for i, patches in enumerate(patches_compressed_list):\n                    if patches:\n                        patches_diff = \"\\n\".join(patches)\n                        get_logger().debug(f\"PR diff number {i + 1} for describe files\")\n                        task = asyncio.create_task(\n                            self._get_prediction(model, patches_diff, prompt=\"pr_description_only_files_prompts\"))\n                        tasks.append(task)\n                # Wait for all tasks to complete\n                results = await asyncio.gather(*tasks)\n            file_description_str_list = []\n            for i, result in enumerate(results):\n                prediction_files = result.strip().removeprefix('```yaml').strip('`').strip()\n                if load_yaml(prediction_files, keys_fix_yaml=self.keys_fix) and prediction_files.startswith('pr_files'):\n                    prediction_files = prediction_files.removeprefix('pr_files:').strip()\n                    file_description_str_list.append(prediction_files)\n                else:\n                    get_logger().debug(f\"failed to generate predictions in iteration {i + 1} for describe files\")\n\n            # generate files_walkthrough string, with proper token handling\n            token_handler_only_description_prompt = TokenHandler(\n                self.git_provider.pr,\n                self.vars,\n                get_settings().pr_description_only_description_prompts.system,\n                get_settings().pr_description_only_description_prompts.user)\n            files_walkthrough = \"\\n\".join(file_description_str_list)\n            files_walkthrough_prompt = copy.deepcopy(files_walkthrough)\n            MAX_EXTRA_FILES_TO_PROMPT = 50\n            if remaining_files_list:\n                files_walkthrough_prompt += \"\\n\\nNo more token budget. Additional unprocessed files:\"\n                for i, file in enumerate(remaining_files_list):\n                    files_walkthrough_prompt += f\"\\n- {file}\"\n                    if i >= MAX_EXTRA_FILES_TO_PROMPT:\n                        get_logger().debug(f\"Too many remaining files, clipping to {MAX_EXTRA_FILES_TO_PROMPT}\")\n                        files_walkthrough_prompt += f\"\\n... and {len(remaining_files_list) - MAX_EXTRA_FILES_TO_PROMPT} more\"\n                        break\n            if deleted_files_list:\n                files_walkthrough_prompt += \"\\n\\nAdditional deleted files:\"\n                for i, file in enumerate(deleted_files_list):\n                    files_walkthrough_prompt += f\"\\n- {file}\"\n                    if i >= MAX_EXTRA_FILES_TO_PROMPT:\n                        get_logger().debug(f\"Too many deleted files, clipping to {MAX_EXTRA_FILES_TO_PROMPT}\")\n                        files_walkthrough_prompt += f\"\\n... and {len(deleted_files_list) - MAX_EXTRA_FILES_TO_PROMPT} more\"\n                        break\n            tokens_files_walkthrough = len(\n                token_handler_only_description_prompt.encoder.encode(files_walkthrough_prompt))\n            total_tokens = token_handler_only_description_prompt.prompt_tokens + tokens_files_walkthrough\n            max_tokens_model = get_max_tokens(model)\n            if total_tokens > max_tokens_model - OUTPUT_BUFFER_TOKENS_HARD_THRESHOLD:\n                # clip files_walkthrough to git the tokens within the limit\n                files_walkthrough_prompt = clip_tokens(files_walkthrough_prompt,\n                                                       max_tokens_model - OUTPUT_BUFFER_TOKENS_HARD_THRESHOLD - token_handler_only_description_prompt.prompt_tokens,\n                                                       num_input_tokens=tokens_files_walkthrough)\n\n            # PR header inference\n            get_logger().debug(f\"PR diff only description\", artifact=files_walkthrough_prompt)\n            prediction_headers = await self._get_prediction(model, patches_diff=files_walkthrough_prompt,\n                                                            prompt=\"pr_description_only_description_prompts\")\n            prediction_headers = prediction_headers.strip().removeprefix('```yaml').strip('`').strip()\n\n            # extend the tables with the files not shown\n            files_walkthrough_extended = await self.extend_uncovered_files(files_walkthrough)\n\n            # final processing\n            self.prediction = prediction_headers + \"\\n\" + \"pr_files:\\n\" + files_walkthrough_extended\n            if not load_yaml(self.prediction, keys_fix_yaml=self.keys_fix):\n                get_logger().error(f\"Error getting valid YAML in large PR handling for describe {self.pr_id}\")\n                if load_yaml(prediction_headers, keys_fix_yaml=self.keys_fix):\n                    get_logger().debug(f\"Using only headers for describe {self.pr_id}\")\n                    self.prediction = prediction_headers\n\n    async def extend_uncovered_files(self, original_prediction: str) -> str:\n        try:\n            prediction = original_prediction\n\n            # get the original prediction filenames\n            original_prediction_loaded = load_yaml(original_prediction, keys_fix_yaml=self.keys_fix)\n            if isinstance(original_prediction_loaded, list):\n                original_prediction_dict = {\"pr_files\": original_prediction_loaded}\n            else:\n                original_prediction_dict = original_prediction_loaded\n            if original_prediction_dict:\n                filenames_predicted = [file.get('filename', '').strip() for file in original_prediction_dict.get('pr_files', [])]\n            else:\n                filenames_predicted = []\n\n            # extend the prediction with additional files not included in the original prediction\n            pr_files = self.git_provider.get_diff_files()\n            prediction_extra = \"pr_files:\"\n            MAX_EXTRA_FILES_TO_OUTPUT = 100\n            counter_extra_files = 0\n            for file in pr_files:\n                if file.filename in filenames_predicted:\n                    continue\n\n                # add up to MAX_EXTRA_FILES_TO_OUTPUT files\n                counter_extra_files += 1\n                if counter_extra_files > MAX_EXTRA_FILES_TO_OUTPUT:\n                    extra_file_yaml = f\"\"\"\\\n- filename: |\n    Additional files not shown\n  changes_title: |\n    ...\n  label: |\n    additional files\n\"\"\"\n                    prediction_extra = prediction_extra + \"\\n\" + extra_file_yaml.strip()\n                    get_logger().debug(f\"Too many remaining files, clipping to {MAX_EXTRA_FILES_TO_OUTPUT}\")\n                    break\n\n                extra_file_yaml = f\"\"\"\\\n- filename: |\n    {file.filename}\n  changes_title: |\n    ...\n  label: |\n    additional files\n\"\"\"\n                prediction_extra = prediction_extra + \"\\n\" + extra_file_yaml.strip()\n\n            # merge the two dictionaries\n            if counter_extra_files > 0:\n                get_logger().info(f\"Adding {counter_extra_files} unprocessed extra files to table prediction\")\n                prediction_extra_dict = load_yaml(prediction_extra, keys_fix_yaml=self.keys_fix)\n                if original_prediction_dict and isinstance(original_prediction_dict, dict) and \\\n                        isinstance(prediction_extra_dict, dict) and \"pr_files\" in prediction_extra_dict:\n                    if \"pr_files\" in original_prediction_dict:\n                        original_prediction_dict[\"pr_files\"].extend(prediction_extra_dict[\"pr_files\"])\n                    else:\n                        original_prediction_dict[\"pr_files\"] = prediction_extra_dict[\"pr_files\"]\n                    new_yaml = yaml.dump(original_prediction_dict)\n                    if load_yaml(new_yaml, keys_fix_yaml=self.keys_fix):\n                        prediction = new_yaml\n                if isinstance(original_prediction, list):\n                    prediction = yaml.dump(original_prediction_dict[\"pr_files\"])\n\n            return prediction\n        except Exception as e:\n            get_logger().exception(f\"Error extending uncovered files {self.pr_id}\", artifact={\"error\": e})\n            return original_prediction\n\n\n    async def extend_additional_files(self, remaining_files_list) -> str:\n        prediction = self.prediction\n        try:\n            original_prediction_dict = load_yaml(self.prediction, keys_fix_yaml=self.keys_fix)\n            prediction_extra = \"pr_files:\"\n            for file in remaining_files_list:\n                extra_file_yaml = f\"\"\"\\\n- filename: |\n    {file}\n  changes_summary: |\n    ...\n  changes_title: |\n    ...\n  label: |\n    additional files (token-limit)\n\"\"\"\n                prediction_extra = prediction_extra + \"\\n\" + extra_file_yaml.strip()\n            prediction_extra_dict = load_yaml(prediction_extra, keys_fix_yaml=self.keys_fix)\n            # merge the two dictionaries\n            if isinstance(original_prediction_dict, dict) and isinstance(prediction_extra_dict, dict):\n                original_prediction_dict[\"pr_files\"].extend(prediction_extra_dict[\"pr_files\"])\n                new_yaml = yaml.dump(original_prediction_dict)\n                if load_yaml(new_yaml, keys_fix_yaml=self.keys_fix):\n                    prediction = new_yaml\n            return prediction\n        except Exception as e:\n            get_logger().error(f\"Error extending additional files {self.pr_id}: {e}\")\n            return self.prediction\n\n    async def _get_prediction(self, model: str, patches_diff: str, prompt=\"pr_description_prompt\") -> str:\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = patches_diff  # update diff\n\n        environment = Environment(undefined=StrictUndefined)\n        set_custom_labels(variables, self.git_provider)\n        self.variables = variables\n\n        system_prompt = environment.from_string(get_settings().get(prompt, {}).get(\"system\", \"\")).render(self.variables)\n        user_prompt = environment.from_string(get_settings().get(prompt, {}).get(\"user\", \"\")).render(self.variables)\n\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model,\n            temperature=get_settings().config.temperature,\n            system=system_prompt,\n            user=user_prompt\n        )\n\n        return response\n\n    def _prepare_data(self):\n        # Load the AI prediction data into a dictionary\n        self.data = load_yaml(self.prediction.strip(), keys_fix_yaml=self.keys_fix)\n\n        if get_settings().pr_description.add_original_user_description and self.user_description:\n            self.data[\"User Description\"] = self.user_description\n\n        # re-order keys\n        if 'User Description' in self.data:\n            self.data['User Description'] = self.data.pop('User Description')\n        if 'title' in self.data:\n            self.data['title'] = self.data.pop('title')\n        if 'type' in self.data:\n            self.data['type'] = self.data.pop('type')\n        if 'labels' in self.data:\n            self.data['labels'] = self.data.pop('labels')\n        if 'description' in self.data:\n            self.data['description'] = self.data.pop('description')\n        if 'pr_files' in self.data:\n            self.data['pr_files'] = self.data.pop('pr_files')\n\n    def _prepare_labels(self) -> List[str]:\n        pr_labels = []\n\n        # If the 'PR Type' key is present in the dictionary, split its value by comma and assign it to 'pr_types'\n        if 'labels' in self.data and self.data['labels']:\n            if type(self.data['labels']) == list:\n                pr_labels = self.data['labels']\n            elif type(self.data['labels']) == str:\n                pr_labels = self.data['labels'].split(',')\n        elif 'type' in self.data and self.data['type'] and get_settings().pr_description.publish_labels:\n            if type(self.data['type']) == list:\n                pr_labels = self.data['type']\n            elif type(self.data['type']) == str:\n                pr_labels = self.data['type'].split(',')\n        pr_labels = [label.strip() for label in pr_labels]\n\n        # convert lowercase labels to original case\n        try:\n            if \"labels_minimal_to_labels_dict\" in self.variables:\n                d: dict = self.variables[\"labels_minimal_to_labels_dict\"]\n                for i, label_i in enumerate(pr_labels):\n                    if label_i in d:\n                        pr_labels[i] = d[label_i]\n        except Exception as e:\n            get_logger().error(f\"Error converting labels to original case {self.pr_id}: {e}\")\n        return pr_labels\n\n    def _prepare_pr_answer_with_markers(self) -> Tuple[str, str, str, List[dict]]:\n        get_logger().info(f\"Using description marker replacements {self.pr_id}\")\n\n        # Remove the 'PR Title' key from the dictionary\n        ai_title = self.data.pop('title', self.vars[\"title\"])\n        if (not get_settings().pr_description.generate_ai_title):\n            # Assign the original PR title to the 'title' variable\n            title = self.vars[\"title\"]\n        else:\n            # Assign the value of the 'PR Title' key to 'title' variable\n            title = ai_title\n      \n        body = self.user_description\n        if get_settings().pr_description.include_generated_by_header:\n            ai_header = f\"###  Generated by PR Agent at {self.git_provider.last_commit_id.sha}\\n\\n\"\n        else:\n            ai_header = \"\"\n\n        ai_type = self.data.get('type')\n        if ai_type and not re.search(r'<!--\\s*pr_agent:type\\s*-->', body):\n            if isinstance(ai_type, list):\n                pr_types = [f\"{ai_header}{t}\" for t in ai_type]\n                pr_type = ','.join(pr_types)\n            else:\n                pr_type = f\"{ai_header}{ai_type}\"\n            body = body.replace('pr_agent:type', pr_type)\n\n        ai_summary = self.data.get('description')\n        if ai_summary and not re.search(r'<!--\\s*pr_agent:summary\\s*-->', body):\n            summary = f\"{ai_header}{ai_summary}\"\n            body = body.replace('pr_agent:summary', summary)\n\n        ai_walkthrough = self.data.get('pr_files')\n        walkthrough_gfm = \"\"\n        pr_file_changes = []\n        if ai_walkthrough and not re.search(r'<!--\\s*pr_agent:walkthrough\\s*-->', body):\n            try:\n                walkthrough_gfm, pr_file_changes = self.process_pr_files_prediction(walkthrough_gfm,\n                                                                                    self.file_label_dict)\n                body = body.replace('pr_agent:walkthrough', walkthrough_gfm)\n            except Exception as e:\n                get_logger().error(f\"Failing to process walkthrough {self.pr_id}: {e}\")\n                body = body.replace('pr_agent:walkthrough', \"\")\n\n        return title, body, walkthrough_gfm, pr_file_changes\n\n    def _prepare_pr_answer(self) -> Tuple[str, str, str, List[dict]]:\n        \"\"\"\n        Prepare the PR description based on the AI prediction data.\n\n        Returns:\n        - title: a string containing the PR title.\n        - pr_body: a string containing the PR description body in a markdown format.\n        \"\"\"\n\n        # Iterate over the dictionary items and append the key and value to 'markdown_text' in a markdown format\n        markdown_text = \"\"\n        # Don't display 'PR Labels'\n        if 'labels' in self.data and self.git_provider.is_supported(\"get_labels\"):\n            self.data.pop('labels')\n        if not get_settings().pr_description.enable_pr_type:\n            self.data.pop('type')\n        for key, value in self.data.items():\n            markdown_text += f\"## **{key}**\\n\\n\"\n            markdown_text += f\"{value}\\n\\n\"\n\n        # Remove the 'PR Title' key from the dictionary\n        ai_title = self.data.pop('title', self.vars[\"title\"])\n        if (not get_settings().pr_description.generate_ai_title):\n            # Assign the original PR title to the 'title' variable\n            title = self.vars[\"title\"]\n        else:\n            # Assign the value of the 'PR Title' key to 'title' variable\n            title = ai_title\n\n        # Iterate over the remaining dictionary items and append the key and value to 'pr_body' in a markdown format,\n        # except for the items containing the word 'walkthrough'\n        pr_body, changes_walkthrough = \"\", \"\"\n        pr_file_changes = []\n        for idx, (key, value) in enumerate(self.data.items()):\n            if key == 'pr_files':\n                value = self.file_label_dict\n            else:\n                key_publish = key.rstrip(':').replace(\"_\", \" \").capitalize()\n                if key_publish == \"Type\":\n                    key_publish = \"PR Type\"\n                # elif key_publish == \"Description\":\n                #     key_publish = \"PR Description\"\n                pr_body += f\"### **{key_publish}**\\n\"\n            if 'walkthrough' in key.lower():\n                if self.git_provider.is_supported(\"gfm_markdown\"):\n                    pr_body += \"<details> <summary>files:</summary>\\n\\n\"\n                for file in value:\n                    filename = file['filename'].replace(\"'\", \"`\")\n                    description = file['changes_in_file']\n                    pr_body += f'- `{filename}`: {description}\\n'\n                if self.git_provider.is_supported(\"gfm_markdown\"):\n                    pr_body += \"</details>\\n\"\n            elif 'pr_files' in key.lower() and get_settings().pr_description.enable_semantic_files_types:\n                changes_walkthrough, pr_file_changes = self.process_pr_files_prediction(changes_walkthrough, value)\n                changes_walkthrough = f\"{PRDescriptionHeader.CHANGES_WALKTHROUGH.value}\\n{changes_walkthrough}\"\n            elif key.lower().strip() == 'description':\n                if isinstance(value, list):\n                    value = ', '.join(v.rstrip() for v in value)\n                value = value.replace('\\n-', '\\n\\n-').strip() # makes the bullet points more readable by adding double space\n                pr_body += f\"{value}\\n\"\n            else:\n                # if the value is a list, join its items by comma\n                if isinstance(value, list):\n                    value = ', '.join(v.rstrip() for v in value)\n                pr_body += f\"{value}\\n\"\n            if idx < len(self.data) - 1:\n                pr_body += \"\\n\\n___\\n\\n\"\n\n        return title, pr_body, changes_walkthrough, pr_file_changes,\n\n    def _prepare_file_labels(self):\n        file_label_dict = {}\n        if (not self.data or not isinstance(self.data, dict) or\n                'pr_files' not in self.data or not self.data['pr_files']):\n            return file_label_dict\n        for file in self.data['pr_files']:\n            try:\n                required_fields = ['changes_title', 'filename', 'label']\n                if not all(field in file for field in required_fields):\n                    # can happen for example if a YAML generation was interrupted in the middle (no more tokens)\n                    get_logger().warning(f\"Missing required fields in file label dict {self.pr_id}, skipping file\",\n                                         artifact={\"file\": file})\n                    continue\n                if not file.get('changes_title'):\n                    get_logger().warning(f\"Empty changes title or summary in file label dict {self.pr_id}, skipping file\",\n                                         artifact={\"file\": file})\n                    continue\n                filename = file['filename'].replace(\"'\", \"`\").replace('\"', '`')\n                changes_summary = file.get('changes_summary', \"\").strip()\n                changes_title = file['changes_title'].strip()\n                label = file.get('label').strip().lower()\n                if label not in file_label_dict:\n                    file_label_dict[label] = []\n                file_label_dict[label].append((filename, changes_title, changes_summary))\n            except Exception as e:\n                get_logger().error(f\"Error preparing file label dict {self.pr_id}: {e}\")\n                pass\n        return file_label_dict\n\n    def process_pr_files_prediction(self, pr_body, value):\n        pr_comments = []\n        # logic for using collapsible file list\n        use_collapsible_file_list = get_settings().pr_description.collapsible_file_list\n        num_files = 0\n        if value:\n            for semantic_label in value.keys():\n                num_files += len(value[semantic_label])\n        if use_collapsible_file_list == \"adaptive\":\n            use_collapsible_file_list = num_files > self.COLLAPSIBLE_FILE_LIST_THRESHOLD\n\n        if not self.git_provider.is_supported(\"gfm_markdown\"):\n            return pr_body, pr_comments\n        try:\n            pr_body += \"<table>\"\n            header = f\"Relevant files\"\n            delta = 75\n            # header += \"&nbsp; \" * delta\n            pr_body += f\"\"\"<thead><tr><th></th><th align=\"left\">{header}</th></tr></thead>\"\"\"\n            pr_body += \"\"\"<tbody>\"\"\"\n            for semantic_label in value.keys():\n                s_label = semantic_label.strip(\"'\").strip('\"')\n                pr_body += f\"\"\"<tr><td><strong>{s_label.capitalize()}</strong></td>\"\"\"\n                list_tuples = value[semantic_label]\n\n                if use_collapsible_file_list:\n                    pr_body += f\"\"\"<td><details><summary>{len(list_tuples)} files</summary><table>\"\"\"\n                else:\n                    pr_body += f\"\"\"<td><table>\"\"\"\n                for filename, file_changes_title, file_change_description in list_tuples:\n                    filename = filename.replace(\"'\", \"`\").rstrip()\n                    filename_publish = filename.split(\"/\")[-1]\n                    if file_changes_title and file_changes_title.strip() != \"...\":\n                        file_changes_title_code = f\"<code>{file_changes_title}</code>\"\n                        file_changes_title_code_br = insert_br_after_x_chars(file_changes_title_code, x=(delta - 5)).strip()\n                        if len(file_changes_title_code_br) < (delta - 5):\n                            file_changes_title_code_br += \"&nbsp; \" * ((delta - 5) - len(file_changes_title_code_br))\n                        filename_publish = f\"<strong>{filename_publish}</strong><dd>{file_changes_title_code_br}</dd>\"\n                    else:\n                        filename_publish = f\"<strong>{filename_publish}</strong>\"\n                    diff_plus_minus = \"\"\n                    delta_nbsp = \"\"\n                    diff_files = self.git_provider.get_diff_files()\n                    for f in diff_files:\n                        if f.filename.lower().strip('/') == filename.lower().strip('/'):\n                            num_plus_lines = f.num_plus_lines\n                            num_minus_lines = f.num_minus_lines\n                            diff_plus_minus += f\"+{num_plus_lines}/-{num_minus_lines}\"\n                            if len(diff_plus_minus) > 12 or diff_plus_minus == \"+0/-0\":\n                                diff_plus_minus = \"[link]\"\n                            delta_nbsp = \"&nbsp; \" * max(0, (8 - len(diff_plus_minus)))\n                            break\n\n                    # try to add line numbers link to code suggestions\n                    link = \"\"\n                    if hasattr(self.git_provider, 'get_line_link'):\n                        filename = filename.strip()\n                        link = self.git_provider.get_line_link(filename, relevant_line_start=-1)\n                    if (not link or not diff_plus_minus) and ('additional files' not in filename.lower()):\n                        # get_logger().warning(f\"Error getting line link for '{filename}'\")\n                        link = \"\"\n                        # continue\n\n                    # Add file data to the PR body\n                    file_change_description_br = insert_br_after_x_chars(file_change_description, x=(delta - 5))\n                    pr_body = self.add_file_data(delta_nbsp, diff_plus_minus, file_change_description_br, filename,\n                                                 filename_publish, link, pr_body)\n\n                # Close the collapsible file list\n                if use_collapsible_file_list:\n                    pr_body += \"\"\"</table></details></td></tr>\"\"\"\n                else:\n                    pr_body += \"\"\"</table></td></tr>\"\"\"\n            pr_body += \"\"\"</tr></tbody></table>\"\"\"\n\n        except Exception as e:\n            get_logger().error(f\"Error processing pr files to markdown {self.pr_id}: {str(e)}\")\n            pass\n        return pr_body, pr_comments\n\n    def add_file_data(self, delta_nbsp, diff_plus_minus, file_change_description_br, filename, filename_publish, link,\n                      pr_body) -> str:\n\n        if not file_change_description_br:\n            pr_body += f\"\"\"\n<tr>\n  <td>{filename_publish}</td>\n  <td><a href=\"{link}\">{diff_plus_minus}</a>{delta_nbsp}</td>\n\n</tr>\n\"\"\"\n        else:\n            pr_body += f\"\"\"\n<tr>\n  <td>\n    <details>\n      <summary>{filename_publish}</summary>\n<hr>\n\n{filename}\n\n{file_change_description_br}\n\n\n</details>\n\n\n  </td>\n  <td><a href=\"{link}\">{diff_plus_minus}</a>{delta_nbsp}</td>\n\n</tr>\n\"\"\"\n        return pr_body",
    "start_line": 33,
    "end_line": 746,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRDescription",
    "component_id": "pr_agent.tools.pr_description.PRDescription"
  },
  "pr_agent.tools.pr_description.count_chars_without_html": {
    "id": "pr_agent.tools.pr_description.count_chars_without_html",
    "name": "count_chars_without_html",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_description.py",
    "relative_path": "pr_agent/tools/pr_description.py",
    "depends_on": [],
    "source_code": "def count_chars_without_html(string):\n    if '<' not in string:\n        return len(string)\n    no_html_string = re.sub('<[^>]+>', '', string)\n    return len(no_html_string)",
    "start_line": 748,
    "end_line": 752,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "string"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function count_chars_without_html",
    "component_id": "pr_agent.tools.pr_description.count_chars_without_html"
  },
  "pr_agent.tools.pr_description.insert_br_after_x_chars": {
    "id": "pr_agent.tools.pr_description.insert_br_after_x_chars",
    "name": "insert_br_after_x_chars",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_description.py",
    "relative_path": "pr_agent/tools/pr_description.py",
    "depends_on": [
      "pr_agent.tools.pr_description.count_chars_without_html",
      "pr_agent.tools.pr_description.replace_code_tags"
    ],
    "source_code": "def insert_br_after_x_chars(text: str, x=70):\n    \"\"\"\n    Insert <br> into a string after a word that increases its length above x characters.\n    Use proper HTML tags for code and new lines.\n    \"\"\"\n\n    if not text:\n        return \"\"\n    if count_chars_without_html(text) < x:\n        return text\n\n    # replace odd instances of ` with <code> and even instances of ` with </code>\n    text = replace_code_tags(text)\n\n    # convert list items to <li>\n    if text.startswith(\"- \") or text.startswith(\"* \"):\n        text = \"<li>\" + text[2:]\n    text = text.replace(\"\\n- \", '<br><li> ').replace(\"\\n - \", '<br><li> ')\n    text = text.replace(\"\\n* \", '<br><li> ').replace(\"\\n * \", '<br><li> ')\n\n    # convert new lines to <br>\n    text = text.replace(\"\\n\", '<br>')\n\n    # split text into lines\n    lines = text.split('<br>')\n    words = []\n    for i, line in enumerate(lines):\n        words += line.split(' ')\n        if i < len(lines) - 1:\n            words[-1] += \"<br>\"\n\n    new_text = []\n    is_inside_code = False\n    current_length = 0\n    for word in words:\n        is_saved_word = False\n        if word == \"<code>\" or word == \"</code>\" or word == \"<li>\" or word == \"<br>\":\n            is_saved_word = True\n\n        len_word = count_chars_without_html(word)\n        if not is_saved_word and (current_length + len_word > x):\n            if is_inside_code:\n                new_text.append(\"</code><br><code>\")\n            else:\n                new_text.append(\"<br>\")\n            current_length = 0  # Reset counter\n        new_text.append(word + \" \")\n\n        if not is_saved_word:\n            current_length += len_word + 1  # Add 1 for the space\n\n        if word == \"<li>\" or word == \"<br>\":\n            current_length = 0\n\n        if \"<code>\" in word:\n            is_inside_code = True\n        if \"</code>\" in word:\n            is_inside_code = False\n    return ''.join(new_text).strip()",
    "start_line": 755,
    "end_line": 813,
    "has_docstring": true,
    "docstring": "Insert <br> into a string after a word that increases its length above x characters.\nUse proper HTML tags for code and new lines.",
    "parameters": [
      "text",
      "x"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function insert_br_after_x_chars",
    "component_id": "pr_agent.tools.pr_description.insert_br_after_x_chars"
  },
  "pr_agent.tools.pr_description.replace_code_tags": {
    "id": "pr_agent.tools.pr_description.replace_code_tags",
    "name": "replace_code_tags",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_description.py",
    "relative_path": "pr_agent/tools/pr_description.py",
    "depends_on": [],
    "source_code": "def replace_code_tags(text):\n    \"\"\"\n    Replace odd instances of ` with <code> and even instances of ` with </code>\n    \"\"\"\n    parts = text.split('`')\n    for i in range(1, len(parts), 2):\n        parts[i] = '<code>' + parts[i] + '</code>'\n    return ''.join(parts)",
    "start_line": 816,
    "end_line": 823,
    "has_docstring": true,
    "docstring": "Replace odd instances of ` with <code> and even instances of ` with </code>",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function replace_code_tags",
    "component_id": "pr_agent.tools.pr_description.replace_code_tags"
  },
  "pr_agent.tools.pr_generate_labels.PRGenerateLabels": {
    "id": "pr_agent.tools.pr_generate_labels.PRGenerateLabels",
    "name": "PRGenerateLabels",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_generate_labels.py",
    "relative_path": "pr_agent/tools/pr_generate_labels.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.git_providers.git_provider.get_pr_id",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.git_provider.get_pr_labels",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.get_user_labels",
      "pr_agent.algo.utils.set_custom_labels",
      "pr_agent.git_providers.__init__.get_git_provider",
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.publish_labels",
      "pr_agent.algo.utils.load_yaml"
    ],
    "source_code": "class PRGenerateLabels:\n    def __init__(self, pr_url: str, args: list = None,\n                 ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n        \"\"\"\n        Initialize the PRGenerateLabels object with the necessary attributes and objects for generating labels\n        corresponding to the PR using an AI model.\n        Args:\n            pr_url (str): The URL of the pull request.\n            args (list, optional): List of arguments passed to the PRGenerateLabels class. Defaults to None.\n        \"\"\"\n        # Initialize the git provider and main PR language\n        self.git_provider = get_git_provider()(pr_url)\n        self.main_pr_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n        self.pr_id = self.git_provider.get_pr_id()\n\n        # Initialize the AI handler\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_pr_language\n\n        # Initialize the variables dictionary\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.git_provider.get_pr_description(full=False),\n            \"language\": self.main_pr_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"extra_instructions\": get_settings().pr_description.extra_instructions,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n            \"enable_custom_labels\": get_settings().config.enable_custom_labels,\n            \"custom_labels_class\": \"\",  # will be filled if necessary in 'set_custom_labels' function\n        }\n\n        # Initialize the token handler\n        self.token_handler = TokenHandler(\n            self.git_provider.pr,\n            self.vars,\n            get_settings().pr_custom_labels_prompt.system,\n            get_settings().pr_custom_labels_prompt.user,\n        )\n\n        # Initialize patches_diff and prediction attributes\n        self.patches_diff = None\n        self.prediction = None\n\n    async def run(self):\n        \"\"\"\n        Generates a PR labels using an AI model and publishes it to the PR.\n        \"\"\"\n\n        try:\n            get_logger().info(f\"Generating a PR labels {self.pr_id}\")\n            if get_settings().config.publish_output:\n                self.git_provider.publish_comment(\"Preparing PR labels...\", is_temporary=True)\n\n            await retry_with_fallback_models(self._prepare_prediction)\n\n            get_logger().info(f\"Preparing answer {self.pr_id}\")\n            if self.prediction:\n                self._prepare_data()\n            else:\n                return None\n\n            pr_labels = self._prepare_labels()\n\n            if get_settings().config.publish_output:\n                get_logger().info(f\"Pushing labels {self.pr_id}\")\n\n                current_labels = self.git_provider.get_pr_labels()\n                user_labels = get_user_labels(current_labels)\n                pr_labels = pr_labels + user_labels\n\n                if self.git_provider.is_supported(\"get_labels\"):\n                    self.git_provider.publish_labels(pr_labels)\n                elif pr_labels:\n                    value = ', '.join(v for v in pr_labels)\n                    pr_labels_text = f\"## PR Labels:\\n{value}\\n\"\n                    self.git_provider.publish_comment(pr_labels_text, is_temporary=False)\n                self.git_provider.remove_initial_comment()\n        except Exception as e:\n            get_logger().error(f\"Error generating PR labels {self.pr_id}: {e}\")\n\n        return \"\"\n\n    async def _prepare_prediction(self, model: str) -> None:\n        \"\"\"\n        Prepare the AI prediction for the PR labels based on the provided model.\n\n        Args:\n            model (str): The name of the model to be used for generating the prediction.\n\n        Returns:\n            None\n\n        Raises:\n            Any exceptions raised by the 'get_pr_diff' and '_get_prediction' functions.\n\n        \"\"\"\n\n        get_logger().info(f\"Getting PR diff {self.pr_id}\")\n        self.patches_diff = get_pr_diff(self.git_provider, self.token_handler, model)\n        get_logger().info(f\"Getting AI prediction {self.pr_id}\")\n        self.prediction = await self._get_prediction(model)\n\n    async def _get_prediction(self, model: str) -> str:\n        \"\"\"\n        Generate an AI prediction for the PR labels based on the provided model.\n\n        Args:\n            model (str): The name of the model to be used for generating the prediction.\n\n        Returns:\n            str: The generated AI prediction.\n        \"\"\"\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = self.patches_diff  # update diff\n\n        environment = Environment(undefined=StrictUndefined)\n        set_custom_labels(variables, self.git_provider)\n        self.variables = variables\n\n        system_prompt = environment.from_string(get_settings().pr_custom_labels_prompt.system).render(self.variables)\n        user_prompt = environment.from_string(get_settings().pr_custom_labels_prompt.user).render(self.variables)\n\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model,\n            temperature=get_settings().config.temperature,\n            system=system_prompt,\n            user=user_prompt\n        )\n\n        return response\n\n    def _prepare_data(self):\n        # Load the AI prediction data into a dictionary\n        self.data = load_yaml(self.prediction.strip())\n\n\n\n    def _prepare_labels(self) -> List[str]:\n        pr_types = []\n\n        # If the 'labels' key is present in the dictionary, split its value by comma and assign it to 'pr_types'\n        if 'labels' in self.data:\n            if type(self.data['labels']) == list:\n                pr_types = self.data['labels']\n            elif type(self.data['labels']) == str:\n                pr_types = self.data['labels'].split(',')\n        pr_types = [label.strip() for label in pr_types]\n\n        # convert lowercase labels to original case\n        try:\n            if \"labels_minimal_to_labels_dict\" in self.variables:\n                d: dict = self.variables[\"labels_minimal_to_labels_dict\"]\n                for i, label_i in enumerate(pr_types):\n                    if label_i in d:\n                        pr_types[i] = d[label_i]\n        except Exception as e:\n            get_logger().error(f\"Error converting labels to original case {self.pr_id}: {e}\")\n\n        return pr_types",
    "start_line": 19,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRGenerateLabels",
    "component_id": "pr_agent.tools.pr_generate_labels.PRGenerateLabels"
  },
  "pr_agent.tools.pr_help_docs.modify_answer_section": {
    "id": "pr_agent.tools.pr_help_docs.modify_answer_section",
    "name": "modify_answer_section",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.tools.pr_help_docs.extract_model_answer_and_relevant_sources"
    ],
    "source_code": "def modify_answer_section(ai_response: str) -> str | None:\n    # Gets the model's answer and relevant sources section, repacing the heading of the answer section with:\n    # :bulb: Auto-generated documentation-based answer:\n    \"\"\"\n    For example: The following input:\n\n    ### Question: \\nThe following general issue was asked by a user: Title: How does one request to re-review a PR? More Info: I cannot seem to find to do this.\n    ### Answer:\\nAccording to the documentation, one needs to invoke the command: /review\n    #### Relevant Sources...\n\n    Should become:\n\n    ### :bulb: Auto-generated documentation-based answer:\\n\n    According to the documentation, one needs to invoke the command: /review\n    #### Relevant Sources...\n    \"\"\"\n    model_answer_and_relevant_sections_in_response \\\n        = extract_model_answer_and_relevant_sources(ai_response)\n    if model_answer_and_relevant_sections_in_response is not None:\n        cleaned_question_with_answer = \"### :bulb: Auto-generated documentation-based answer:\\n\"\n        cleaned_question_with_answer += model_answer_and_relevant_sections_in_response\n        return cleaned_question_with_answer\n    get_logger().warning(f\"Either no answer section found, or that section is malformed: {ai_response}\")\n    return None",
    "start_line": 23,
    "end_line": 46,
    "has_docstring": true,
    "docstring": "    For example: The following input:\n\n    ### Question: \nThe following general issue was asked by a user: Title: How does one request to re-review a PR? More Info: I cannot seem to find to do this.\n    ### Answer:\nAccording to the documentation, one needs to invoke the command: /review\n    #### Relevant Sources...\n\n    Should become:\n\n    ### :bulb: Auto-generated documentation-based answer:\n\n    According to the documentation, one needs to invoke the command: /review\n    #### Relevant Sources...\n    ",
    "parameters": [
      "ai_response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function modify_answer_section",
    "component_id": "pr_agent.tools.pr_help_docs.modify_answer_section"
  },
  "pr_agent.tools.pr_help_docs.extract_model_answer_and_relevant_sources": {
    "id": "pr_agent.tools.pr_help_docs.extract_model_answer_and_relevant_sources",
    "name": "extract_model_answer_and_relevant_sources",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def extract_model_answer_and_relevant_sources(ai_response: str) -> str | None:\n    # It is assumed that the input contains several sections with leading \"### \",\n    # where the answer is the last one of them having the format: \"### Answer:\\n\"), since the model returns the answer\n    # AFTER the user question. By splitting using the string: \"### Answer:\\n\" and grabbing the last part,\n    # the model answer is guaranteed to be in that last part, provided it is followed by a \"#### Relevant Sources:\\n\\n\".\n    # (for more details, see here: https://github.com/Codium-ai/pr-agent-pro/blob/main/pr_agent/tools/pr_help_message.py#L173)\n    \"\"\"\n    For example:\n    ### Question: \\nHow does one request to re-review a PR?\\n\\n\n    ### Answer:\\nAccording to the documentation, one needs to invoke the command: /review\\n\\n\n    #### Relevant Sources:\\n\\n...\n\n    The answer part is: \"According to the documentation, one needs to invoke the command: /review\\n\\n\"\n    followed by \"Relevant Sources:\\n\\n\".\n    \"\"\"\n    if \"### Answer:\\n\" in ai_response:\n        model_answer_and_relevant_sources_sections_in_response = ai_response.split(\"### Answer:\\n\")[-1]\n        # Split such part by \"Relevant Sources\" section to contain only the model answer:\n        if \"#### Relevant Sources:\\n\\n\" in model_answer_and_relevant_sources_sections_in_response:\n            model_answer_section_in_response \\\n                = model_answer_and_relevant_sources_sections_in_response.split(\"#### Relevant Sources:\\n\\n\")[0]\n            get_logger().info(f\"Found model answer: {model_answer_section_in_response}\")\n            return model_answer_and_relevant_sources_sections_in_response \\\n                if len(model_answer_section_in_response) > 0 else None\n    get_logger().warning(f\"Either no answer section found, or that section is malformed: {ai_response}\")\n    return None",
    "start_line": 48,
    "end_line": 73,
    "has_docstring": true,
    "docstring": "    For example:\n    ### Question: \nHow does one request to re-review a PR?\n\n\n    ### Answer:\nAccording to the documentation, one needs to invoke the command: /review\n\n\n    #### Relevant Sources:\n\n...\n\n    The answer part is: \"According to the documentation, one needs to invoke the command: /review\n\n\"\n    followed by \"Relevant Sources:\n\n\".\n    ",
    "parameters": [
      "ai_response"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_model_answer_and_relevant_sources",
    "component_id": "pr_agent.tools.pr_help_docs.extract_model_answer_and_relevant_sources"
  },
  "pr_agent.tools.pr_help_docs.get_maximal_text_input_length_for_token_count_estimation": {
    "id": "pr_agent.tools.pr_help_docs.get_maximal_text_input_length_for_token_count_estimation",
    "name": "get_maximal_text_input_length_for_token_count_estimation",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "def get_maximal_text_input_length_for_token_count_estimation():\n    model = get_settings().config.model\n    if 'claude-3-7-sonnet' in model.lower():\n        return 900000 #Claude API for token estimation allows maximal text input of 900K chars\n    return math.inf #Otherwise, no known limitation on input text just for token estimation",
    "start_line": 75,
    "end_line": 79,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_maximal_text_input_length_for_token_count_estimation",
    "component_id": "pr_agent.tools.pr_help_docs.get_maximal_text_input_length_for_token_count_estimation"
  },
  "pr_agent.tools.pr_help_docs.aggregate_documentation_files_for_prompt_contents": {
    "id": "pr_agent.tools.pr_help_docs.aggregate_documentation_files_for_prompt_contents",
    "name": "aggregate_documentation_files_for_prompt_contents",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def aggregate_documentation_files_for_prompt_contents(base_path: str, doc_files: List[str]) -> Optional[str]:\n    docs_prompt = \"\"\n    for file in doc_files:\n        try:\n            with open(file, 'r', encoding='utf-8') as f:\n                content = f.read()\n                # Skip files with no text content\n                if not re.search(r'[a-zA-Z]', content):\n                    continue\n                file_path = str(file).replace(str(base_path), '')\n                docs_prompt += f\"\\n==file name==\\n\\n{file_path}\\n\\n==file content==\\n\\n{content.strip()}\\n=========\\n\\n\"\n        except Exception as e:\n            get_logger().warning(f\"Error while reading the file {file}: {e}\")\n            continue\n    if not docs_prompt:\n        get_logger().error(\"Couldn't find any usable documentation files. Returning None.\")\n        return None\n    return docs_prompt",
    "start_line": 83,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "base_path",
      "doc_files"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function aggregate_documentation_files_for_prompt_contents",
    "component_id": "pr_agent.tools.pr_help_docs.aggregate_documentation_files_for_prompt_contents"
  },
  "pr_agent.tools.pr_help_docs.format_markdown_q_and_a_response": {
    "id": "pr_agent.tools.pr_help_docs.format_markdown_q_and_a_response",
    "name": "format_markdown_q_and_a_response",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.tools.pr_help_docs.format_markdown_header"
    ],
    "source_code": "def format_markdown_q_and_a_response(question_str: str, response_str: str, relevant_sections: List[Dict[str, str]],\n                                     supported_suffixes: List[str], base_url_prefix: str, base_url_suffix: str=\"\") -> str:\n    base_url_prefix = base_url_prefix.strip('/') #Sanitize base_url_prefix\n    answer_str = \"\"\n    answer_str += f\"### Question: \\n{question_str}\\n\\n\"\n    answer_str += f\"### Answer:\\n{response_str.strip()}\\n\\n\"\n    answer_str += f\"#### Relevant Sources:\\n\\n\"\n    for section in relevant_sections:\n        file = section.get('file_name').strip()\n        ext = [suffix for suffix in supported_suffixes if file.endswith(suffix)]\n        if not ext:\n            get_logger().warning(f\"Unsupported file extension: {file}\")\n            continue\n        if str(section['relevant_section_header_string']).strip():\n            markdown_header = format_markdown_header(section['relevant_section_header_string'])\n            if base_url_prefix:\n                answer_str += f\"> - {base_url_prefix}/{file}{base_url_suffix}#{markdown_header}\\n\"\n        else:\n            answer_str += f\"> - {base_url_prefix}/{file}{base_url_suffix}\\n\"\n    return answer_str",
    "start_line": 102,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "question_str",
      "response_str",
      "relevant_sections",
      "supported_suffixes",
      "base_url_prefix",
      "base_url_suffix"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_markdown_q_and_a_response",
    "component_id": "pr_agent.tools.pr_help_docs.format_markdown_q_and_a_response"
  },
  "pr_agent.tools.pr_help_docs.format_markdown_header": {
    "id": "pr_agent.tools.pr_help_docs.format_markdown_header",
    "name": "format_markdown_header",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def format_markdown_header(header: str) -> str:\n    try:\n        # First, strip common characters from both ends\n        cleaned = header.strip('# \\n')\n\n        # Define all characters to be removed/replaced in a single pass\n        replacements = {\n            \"'\": '',\n            \"`\": '',\n            '(': '',\n            ')': '',\n            ',': '',\n            '.': '',\n            '?': '',\n            '!': '',\n            ' ': '-'\n        }\n\n        # Compile regex pattern for characters to remove\n        pattern = re.compile('|'.join(map(re.escape, replacements.keys())))\n\n        # Perform replacements in a single pass and convert to lowercase\n        return pattern.sub(lambda m: replacements[m.group()], cleaned).lower()\n    except Exception:\n        get_logger().exception(f\"Error while formatting markdown header\", artifacts={'header': header})\n        return \"\"",
    "start_line": 123,
    "end_line": 148,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "header"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_markdown_header",
    "component_id": "pr_agent.tools.pr_help_docs.format_markdown_header"
  },
  "pr_agent.tools.pr_help_docs.clean_markdown_content": {
    "id": "pr_agent.tools.pr_help_docs.clean_markdown_content",
    "name": "clean_markdown_content",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [],
    "source_code": "def clean_markdown_content(content: str) -> str:\n    \"\"\"\n    Remove hidden comments and unnecessary elements from markdown content to reduce size.\n\n    Args:\n        content: The original markdown content\n\n    Returns:\n        Cleaned markdown content\n    \"\"\"\n    # Remove HTML comments\n    content = re.sub(r'<!--.*?-->', '', content, flags=re.DOTALL)\n\n    # Remove frontmatter (YAML between --- or +++ delimiters)\n    content = re.sub(r'^---\\s*\\n.*?\\n---\\s*\\n', '', content, flags=re.DOTALL)\n    content = re.sub(r'^\\+\\+\\+\\s*\\n.*?\\n\\+\\+\\+\\s*\\n', '', content, flags=re.DOTALL)\n\n    # Remove excessive blank lines (more than 2 consecutive)\n    content = re.sub(r'\\n{3,}', '\\n\\n', content)\n\n    # Remove HTML tags that are often used for styling only\n    content = re.sub(r'<div.*?>|</div>|<span.*?>|</span>', '', content, flags=re.DOTALL)\n\n    # Remove image alt text which can be verbose\n    content = re.sub(r'!\\[(.*?)\\]', '![]', content)\n\n    # Remove images completely\n    content = re.sub(r'!\\[.*?\\]\\(.*?\\)', '', content)\n\n    # Remove simple HTML tags but preserve content between them\n    content = re.sub(r'<(?!table|tr|td|th|thead|tbody)([a-zA-Z][a-zA-Z0-9]*)[^>]*>(.*?)</\\1>',\n                     r'\\2', content, flags=re.DOTALL)\n    return content.strip()",
    "start_line": 150,
    "end_line": 182,
    "has_docstring": true,
    "docstring": "Remove hidden comments and unnecessary elements from markdown content to reduce size.\n\nArgs:\n    content: The original markdown content\n\nReturns:\n    Cleaned markdown content",
    "parameters": [
      "content"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clean_markdown_content",
    "component_id": "pr_agent.tools.pr_help_docs.clean_markdown_content"
  },
  "pr_agent.tools.pr_help_docs.PredictionPreparator": {
    "id": "pr_agent.tools.pr_help_docs.PredictionPreparator",
    "name": "PredictionPreparator",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "class PredictionPreparator:\n    def __init__(self, ai_handler, vars, system_prompt, user_prompt):\n        self.ai_handler = ai_handler\n        variables = copy.deepcopy(vars)\n        environment = Environment(undefined=StrictUndefined)\n        self.system_prompt = environment.from_string(system_prompt).render(variables)\n        self.user_prompt = environment.from_string(user_prompt).render(variables)\n\n    async def __call__(self, model: str) -> str:\n        try:\n            response, finish_reason = await self.ai_handler.chat_completion(\n                model=model, temperature=get_settings().config.temperature, system=self.system_prompt, user=self.user_prompt)\n            return response\n        except Exception as e:\n            get_logger().error(f\"Error while preparing prediction: {e}\")\n            return \"\"",
    "start_line": 184,
    "end_line": 199,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PredictionPreparator",
    "component_id": "pr_agent.tools.pr_help_docs.PredictionPreparator"
  },
  "pr_agent.tools.pr_help_docs.PRHelpDocs": {
    "id": "pr_agent.tools.pr_help_docs.PRHelpDocs",
    "name": "PRHelpDocs",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_docs.py",
    "relative_path": "pr_agent/tools/pr_help_docs.py",
    "depends_on": [
      "pr_agent.tools.pr_help_docs.aggregate_documentation_files_for_prompt_contents",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.tools.pr_help_docs.PredictionPreparator",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.git_providers.git_provider.clone",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.tools.pr_help_docs.get_maximal_text_input_length_for_token_count_estimation",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.utils.load_yaml",
      "pr_agent.tools.pr_help_docs.modify_answer_section",
      "pr_agent.tools.pr_help_docs.format_markdown_q_and_a_response",
      "pr_agent.tools.pr_help_docs.clean_markdown_content",
      "pr_agent.git_providers.__init__.get_git_provider_with_context"
    ],
    "source_code": "class PRHelpDocs(object):\n    def __init__(self, ctx_url, ai_handler:partial[BaseAiHandler,] = OpenAIHandler, args: Tuple[str]=None, return_as_string: bool=False):\n        self.ctx_url = ctx_url\n        self.question = args[0] if args else None\n        self.return_as_string = return_as_string\n        self.repo_url_given_explicitly = True\n        self.repo_url = get_settings().get('PR_HELP_DOCS.REPO_URL', '')\n        self.repo_desired_branch = get_settings().get('PR_HELP_DOCS.REPO_DEFAULT_BRANCH', 'main') #Ignored if self.repo_url is empty\n        self.include_root_readme_file = not(get_settings()['PR_HELP_DOCS.EXCLUDE_ROOT_README'])\n        self.supported_doc_exts = get_settings()['PR_HELP_DOCS.SUPPORTED_DOC_EXTS']\n        self.docs_path = get_settings()['PR_HELP_DOCS.DOCS_PATH']\n\n        retrieved_settings = [self.include_root_readme_file, self.supported_doc_exts, self.docs_path]\n        if any([setting is None for setting in retrieved_settings]):\n            raise Exception(f\"One of the settings is invalid: {retrieved_settings}\")\n\n        self.git_provider = get_git_provider_with_context(ctx_url)\n        if not self.git_provider:\n            raise Exception(f\"No git provider found at {ctx_url}\")\n        if not self.repo_url:\n            self.repo_url_given_explicitly = False\n            get_logger().debug(f\"No explicit repo url provided, deducing it from type: {self.git_provider.__class__.__name__} \"\n                              f\"context url: {self.ctx_url}\")\n            self.repo_url = self.git_provider.get_git_repo_url(self.ctx_url)\n            if not self.repo_url:\n                raise Exception(f\"Unable to deduce repo url from type: {self.git_provider.__class__.__name__} url: {self.ctx_url}\")\n            get_logger().debug(f\"deduced repo url: {self.repo_url}\")\n            self.repo_desired_branch = None #Inferred from the repo provider.\n\n        self.ai_handler = ai_handler()\n        self.vars = {\n            \"docs_url\": self.repo_url,\n            \"question\": self.question,\n            \"snippets\": \"\",\n        }\n        self.token_handler = TokenHandler(None,\n                                              self.vars,\n                                              get_settings().pr_help_docs_prompts.system,\n                                              get_settings().pr_help_docs_prompts.user)\n\n    async def run(self):\n        if not self.question:\n            get_logger().warning('No question provided. Will do nothing.')\n            return None\n\n        try:\n            # Clone the repository and gather relevant documentation files.\n            docs_prompt = None\n            with TemporaryDirectory() as tmp_dir:\n                get_logger().debug(f\"About to clone repository: {self.repo_url} to temporary directory: {tmp_dir}...\")\n                returned_cloned_repo_root = self.git_provider.clone(self.repo_url, tmp_dir, remove_dest_folder=False)\n                if not returned_cloned_repo_root:\n                    raise Exception(f\"Failed to clone {self.repo_url} to {tmp_dir}\")\n\n                get_logger().debug(f\"About to gather relevant documentation files...\")\n                doc_files = []\n                if self.include_root_readme_file:\n                    for root, _, files in os.walk(returned_cloned_repo_root.path):\n                        # Only look at files in the root directory, not subdirectories\n                        if root == returned_cloned_repo_root.path:\n                            for file in files:\n                                if file.lower().startswith(\"readme.\"):\n                                    doc_files.append(os.path.join(root, file))\n                abs_docs_path = os.path.join(returned_cloned_repo_root.path, self.docs_path)\n                if os.path.exists(abs_docs_path):\n                    doc_files.extend(self._find_all_document_files_matching_exts(abs_docs_path,\n                                                                                 ignore_readme=(self.docs_path=='.')))\n                    if not doc_files:\n                        get_logger().warning(f\"No documentation files found matching file extensions: \"\n                                             f\"{self.supported_doc_exts} under repo: {self.repo_url} path: {self.docs_path}\")\n                        return None\n\n                get_logger().info(f'Answering a question inside context {self.ctx_url} for repo: {self.repo_url}'\n                                  f' using the following documentation files: ', artifacts={'doc_files': doc_files})\n\n                docs_prompt = aggregate_documentation_files_for_prompt_contents(returned_cloned_repo_root.path, doc_files)\n            if not docs_prompt:\n                get_logger().warning(f\"Error reading one of the documentation files. Returning with no result...\")\n                return None\n            docs_prompt_to_send_to_model = docs_prompt\n\n            # Estimate how many tokens will be needed. Trim in case of exceeding limit.\n            # Firstly, check if text needs to be trimmed, as some models fail to return the estimated token count if the input text is too long.\n            max_allowed_txt_input = get_maximal_text_input_length_for_token_count_estimation()\n            if len(docs_prompt_to_send_to_model) >= max_allowed_txt_input:\n                get_logger().warning(f\"Text length: {len(docs_prompt_to_send_to_model)} exceeds the current returned limit of {max_allowed_txt_input} just for token count estimation. Trimming the text...\")\n                docs_prompt_to_send_to_model = docs_prompt_to_send_to_model[:max_allowed_txt_input]\n            # Then, count the tokens in the prompt. If the count exceeds the limit, trim the text.\n            token_count = self.token_handler.count_tokens(docs_prompt_to_send_to_model, force_accurate=True)\n            get_logger().debug(f\"Estimated token count of documentation to send to model: {token_count}\")\n            model = get_settings().config.model\n            if model in MAX_TOKENS:\n                max_tokens_full = MAX_TOKENS[model] # note - here we take the actual max tokens, without any reductions. we do aim to get the full documentation website in the prompt\n            else:\n                max_tokens_full = get_max_tokens(model)\n            delta_output = 5000 #Elbow room to reduce chance of exceeding token limit or model paying less attention to prompt guidelines.\n            if token_count > max_tokens_full - delta_output:\n                docs_prompt_to_send_to_model = clean_markdown_content(docs_prompt_to_send_to_model) #Reduce unnecessary text/images/etc.\n                get_logger().info(f\"Token count {token_count} exceeds the limit {max_tokens_full - delta_output}. Attempting to clip text to fit within the limit...\")\n                docs_prompt_to_send_to_model = clip_tokens(docs_prompt_to_send_to_model, max_tokens_full - delta_output,\n                                                           num_input_tokens=token_count)\n            self.vars['snippets'] = docs_prompt_to_send_to_model.strip()\n\n            # Run the AI model and extract sections from its response\n            response = await retry_with_fallback_models(PredictionPreparator(self.ai_handler, self.vars,\n                                                                             get_settings().pr_help_docs_prompts.system,\n                                                                             get_settings().pr_help_docs_prompts.user),\n                                                        model_type=ModelType.REGULAR)\n            response_yaml = load_yaml(response)\n            if not response_yaml:\n                get_logger().exception(\"Failed to parse the AI response.\", artifacts={'response': response})\n                raise Exception(f\"Failed to parse the AI response.\")\n            response_str = response_yaml.get('response')\n            relevant_sections = response_yaml.get('relevant_sections')\n            if not response_str or not relevant_sections:\n                get_logger().exception(\"Failed to extract response/relevant sections.\",\n                                       artifacts={'response_str': response_str, 'relevant_sections': relevant_sections})\n                raise Exception(f\"Failed to extract response/relevant sections.\")\n\n            # Format the response as markdown\n            canonical_url_prefix, canonical_url_suffix = self.git_provider.get_canonical_url_parts(repo_git_url=self.repo_url if self.repo_url_given_explicitly else None,\n                                                                                                   desired_branch=self.repo_desired_branch)\n            answer_str = format_markdown_q_and_a_response(self.question, response_str, relevant_sections, self.supported_doc_exts, canonical_url_prefix, canonical_url_suffix)\n            if answer_str:\n                #Remove the question phrase and replace with light bulb and a heading mentioning this is an automated answer:\n                answer_str = modify_answer_section(answer_str)\n            # For PR help docs, we return the answer string instead of publishing it\n            if answer_str and self.return_as_string:\n                if int(response_yaml.get('question_is_relevant', '1')) == 0:\n                    get_logger().warning(f\"Chat help docs answer would be ignored due to an invalid question.\",\n                                         artifacts={'answer_str': answer_str})\n                    return \"\"\n                get_logger().info(f\"Chat help docs answer\", artifacts={'answer_str': answer_str})\n                return answer_str\n\n            # Publish the answer\n            if not answer_str or int(response_yaml.get('question_is_relevant', '1')) == 0:\n                get_logger().info(f\"No answer found\")\n                return \"\"\n\n            if self.git_provider.is_supported(\"gfm_markdown\") and get_settings().pr_help_docs.enable_help_text:\n                answer_str += \"<hr>\\n\\n<details> <summary><strong> Tool usage guide:</strong></summary><hr> \\n\\n\"\n                answer_str += HelpMessage.get_help_docs_usage_guide()\n                answer_str += \"\\n</details>\\n\"\n\n            if get_settings().config.publish_output:\n                self.git_provider.publish_comment(answer_str)\n            else:\n                get_logger().info(\"Answer:\", artifacts={'answer_str': answer_str})\n\n        except:\n            get_logger().exception('failed to provide answer to given user question as a result of a thrown exception (see above)')\n\n\n    def _find_all_document_files_matching_exts(self, abs_docs_path: str, ignore_readme=False) -> List[str]:\n        matching_files = []\n\n        # Ensure extensions don't have leading dots and are lowercase\n        dotless_extensions = [ext.lower().lstrip('.') for ext in self.supported_doc_exts]\n\n        # Walk through directory and subdirectories\n        for root, _, files in os.walk(abs_docs_path):\n            for file in files:\n                if ignore_readme and root == abs_docs_path and file.lower() in [f\"readme.{ext}\" for ext in dotless_extensions]:\n                    continue\n                # Check if file has one of the specified extensions\n                if any(file.lower().endswith(f'.{ext}') for ext in dotless_extensions):\n                    matching_files.append(os.path.join(root, file))\n        return matching_files",
    "start_line": 202,
    "end_line": 370,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "object"
    ],
    "class_name": null,
    "display_name": "class PRHelpDocs",
    "component_id": "pr_agent.tools.pr_help_docs.PRHelpDocs"
  },
  "pr_agent.tools.pr_help_message.extract_header": {
    "id": "pr_agent.tools.pr_help_message.extract_header",
    "name": "extract_header",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_message.py",
    "relative_path": "pr_agent/tools/pr_help_message.py",
    "depends_on": [],
    "source_code": "def extract_header(snippet):\n    res = ''\n    lines = snippet.split('===Snippet content===')[0].split('\\n')\n    highest_header = ''\n    highest_level = float('inf')\n    for line in lines[::-1]:\n        line = line.strip()\n        if line.startswith('Header '):\n            highest_header = line.split(': ')[1]\n    if highest_header:\n        res = f\"#{highest_header.lower().replace(' ', '-')}\"\n    return res",
    "start_line": 19,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "snippet"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_header",
    "component_id": "pr_agent.tools.pr_help_message.extract_header"
  },
  "pr_agent.tools.pr_help_message.PRHelpMessage": {
    "id": "pr_agent.tools.pr_help_message.PRHelpMessage",
    "name": "PRHelpMessage",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_message.py",
    "relative_path": "pr_agent/tools/pr_help_message.py",
    "depends_on": [
      "pr_agent.tools.pr_help_message.extract_header",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.algo.utils.clip_tokens",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.algo.utils.load_yaml",
      "pr_agent.tools.pr_help_docs.format_markdown_header",
      "pr_agent.tools.pr_help_message.generate_bbdc_table",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.git_providers.__init__.get_git_provider_with_context",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "class PRHelpMessage:\n    def __init__(self, pr_url: str, args=None, ai_handler: partial[BaseAiHandler,] = OpenAIHandler, return_as_string=False):\n        self.git_provider = get_git_provider_with_context(pr_url)\n        self.ai_handler = ai_handler()\n        self.question_str = self.parse_args(args)\n        self.return_as_string = return_as_string\n        if self.question_str:\n            self.vars = {\n                \"question\": self.question_str,\n                \"snippets\": \"\",\n            }\n            self.token_handler = TokenHandler(None,\n                                              self.vars,\n                                              get_settings().pr_help_prompts.system,\n                                              get_settings().pr_help_prompts.user)\n\n    async def _prepare_prediction(self, model: str):\n        try:\n            variables = copy.deepcopy(self.vars)\n            environment = Environment(undefined=StrictUndefined)\n            system_prompt = environment.from_string(get_settings().pr_help_prompts.system).render(variables)\n            user_prompt = environment.from_string(get_settings().pr_help_prompts.user).render(variables)\n            response, finish_reason = await self.ai_handler.chat_completion(\n                model=model, temperature=get_settings().config.temperature, system=system_prompt, user=user_prompt)\n            return response\n        except Exception as e:\n            get_logger().error(f\"Error while preparing prediction: {e}\")\n            return \"\"\n\n    def parse_args(self, args):\n        if args and len(args) > 0:\n            question_str = \" \".join(args)\n        else:\n            question_str = \"\"\n        return question_str\n\n    def format_markdown_header(self, header: str) -> str:\n        try:\n            # First, strip common characters from both ends\n            cleaned = header.strip('# \\n')\n\n            # Define all characters to be removed/replaced in a single pass\n            replacements = {\n                \"'\": '',\n                \"`\": '',\n                '(': '',\n                ')': '',\n                ',': '',\n                '.': '',\n                '?': '',\n                '!': '',\n                ' ': '-'\n            }\n\n            # Compile regex pattern for characters to remove\n            pattern = re.compile('|'.join(map(re.escape, replacements.keys())))\n\n            # Perform replacements in a single pass and convert to lowercase\n            return pattern.sub(lambda m: replacements[m.group()], cleaned).lower()\n        except Exception:\n            get_logger().exception(f\"Error while formatting markdown header\", artifacts={'header': header})\n            return \"\"\n\n\n    async def run(self):\n        try:\n            if self.question_str:\n                get_logger().info(f'Answering a PR question about the PR {self.git_provider.pr_url} ')\n\n                if not get_settings().get('openai.key'):\n                    if get_settings().config.publish_output:\n                        self.git_provider.publish_comment(\n                            \"The `Help` tool chat feature requires an OpenAI API key for calculating embeddings\")\n                    else:\n                        get_logger().error(\"The `Help` tool chat feature requires an OpenAI API key for calculating embeddings\")\n                    return\n\n                # current path\n                docs_path= Path(__file__).parent.parent.parent / 'docs' / 'docs'\n                # get all the 'md' files inside docs_path and its subdirectories\n                md_files = list(docs_path.glob('**/*.md'))\n                folders_to_exclude = ['/finetuning_benchmark/']\n                files_to_exclude = {'EXAMPLE_BEST_PRACTICE.md', 'compression_strategy.md', '/docs/overview/index.md'}\n                md_files = [file for file in md_files if not any(folder in str(file) for folder in folders_to_exclude) and not any(file.name == file_to_exclude for file_to_exclude in files_to_exclude)]\n\n                # sort the 'md_files' so that 'priority_files' will be at the top\n                priority_files_strings = ['/docs/index.md', '/usage-guide', 'tools/describe.md', 'tools/review.md',\n                                          'tools/improve.md', '/faq']\n                md_files_priority = [file for file in md_files if\n                                     any(priority_string in str(file) for priority_string in priority_files_strings)]\n                md_files_not_priority = [file for file in md_files if file not in md_files_priority]\n                md_files = md_files_priority + md_files_not_priority\n\n                docs_prompt = \"\"\n                for file in md_files:\n                    try:\n                        with open(file, 'r') as f:\n                            file_path = str(file).replace(str(docs_path), '')\n                            docs_prompt += f\"\\n==file name==\\n\\n{file_path}\\n\\n==file content==\\n\\n{f.read().strip()}\\n=========\\n\\n\"\n                    except Exception as e:\n                        get_logger().error(f\"Error while reading the file {file}: {e}\")\n                token_count = self.token_handler.count_tokens(docs_prompt)\n                get_logger().debug(f\"Token count of full documentation website: {token_count}\")\n\n                model = get_settings().config.model\n                if model in MAX_TOKENS:\n                    max_tokens_full = MAX_TOKENS[model] # note - here we take the actual max tokens, without any reductions. we do aim to get the full documentation website in the prompt\n                else:\n                    max_tokens_full = get_max_tokens(model)\n                delta_output = 2000\n                if token_count > max_tokens_full - delta_output:\n                    get_logger().info(f\"Token count {token_count} exceeds the limit {max_tokens_full - delta_output}. Skipping the PR Help message.\")\n                    docs_prompt = clip_tokens(docs_prompt, max_tokens_full - delta_output)\n                self.vars['snippets'] = docs_prompt.strip()\n\n                # run the AI model\n                response = await retry_with_fallback_models(self._prepare_prediction, model_type=ModelType.REGULAR)\n                response_yaml = load_yaml(response)\n                if isinstance(response_yaml, str):\n                    get_logger().warning(f\"failing to parse response: {response_yaml}, publishing the response as is\")\n                    if get_settings().config.publish_output:\n                        answer_str = f\"### Question: \\n{self.question_str}\\n\\n\"\n                        answer_str += f\"### Answer:\\n\\n\"\n                        answer_str += response_yaml\n                        self.git_provider.publish_comment(answer_str)\n                    return \"\"\n                response_str = response_yaml.get('response')\n                relevant_sections = response_yaml.get('relevant_sections')\n\n                if not relevant_sections:\n                    get_logger().info(f\"Could not find relevant answer for the question: {self.question_str}\")\n                    if get_settings().config.publish_output:\n                        answer_str = f\"### Question: \\n{self.question_str}\\n\\n\"\n                        answer_str += f\"### Answer:\\n\\n\"\n                        answer_str += f\"Could not find relevant information to answer the question. Please provide more details and try again.\"\n                        self.git_provider.publish_comment(answer_str)\n                    return \"\"\n\n                # prepare the answer\n                answer_str = \"\"\n                if response_str:\n                    answer_str += f\"### Question: \\n{self.question_str}\\n\\n\"\n                    answer_str += f\"### Answer:\\n{response_str.strip()}\\n\\n\"\n                    answer_str += f\"#### Relevant Sources:\\n\\n\"\n                    base_path = \"https://qodo-merge-docs.qodo.ai/\"\n                    for section in relevant_sections:\n                        file = section.get('file_name').strip().removesuffix('.md')\n                        if str(section['relevant_section_header_string']).strip():\n                            markdown_header = self.format_markdown_header(section['relevant_section_header_string'])\n                            answer_str += f\"> - {base_path}{file}#{markdown_header}\\n\"\n                        else:\n                            answer_str += f\"> - {base_path}{file}\\n\"\n\n\n                # publish the answer\n                if get_settings().config.publish_output:\n                    self.git_provider.publish_comment(answer_str)\n                else:\n                    get_logger().info(f\"Answer:\\n{answer_str}\")\n            else:\n                if not isinstance(self.git_provider, BitbucketServerProvider) and not self.git_provider.is_supported(\"gfm_markdown\"):\n                    self.git_provider.publish_comment(\n                        \"The `Help` tool requires gfm markdown, which is not supported by your code platform.\")\n                    return\n\n                get_logger().info('Getting PR Help Message...')\n                relevant_configs = {'pr_help': dict(get_settings().pr_help),\n                                    'config': dict(get_settings().config)}\n                get_logger().debug(\"Relevant configs\", artifacts=relevant_configs)\n                pr_comment = \"## PR Agent Walkthrough \\n\\n\"\n                pr_comment += \"Welcome to the PR Agent, an AI-powered tool for automated pull request analysis, feedback, suggestions and more.\"\"\"\n                pr_comment += \"\\n\\nHere is a list of tools you can use to interact with the PR Agent:\\n\"\n                base_path = \"https://pr-agent-docs.codium.ai/tools\"\n\n                tool_names = []\n                tool_names.append(f\"[DESCRIBE]({base_path}/describe/)\")\n                tool_names.append(f\"[REVIEW]({base_path}/review/)\")\n                tool_names.append(f\"[IMPROVE]({base_path}/improve/)\")\n                tool_names.append(f\"[UPDATE CHANGELOG]({base_path}/update_changelog/)\")\n                tool_names.append(f\"[HELP DOCS]({base_path}/help_docs/)\")\n                tool_names.append(f\"[ADD DOCS]({base_path}/documentation/) \")\n                tool_names.append(f\"[TEST]({base_path}/test/) \")\n                tool_names.append(f\"[IMPROVE COMPONENT]({base_path}/improve_component/) \")\n                tool_names.append(f\"[ANALYZE]({base_path}/analyze/) \")\n                tool_names.append(f\"[ASK]({base_path}/ask/)\")\n                tool_names.append(f\"[GENERATE CUSTOM LABELS]({base_path}/custom_labels/) \")\n                tool_names.append(f\"[CI FEEDBACK]({base_path}/ci_feedback/) \")\n                tool_names.append(f\"[CUSTOM PROMPT]({base_path}/custom_prompt/) \")\n                tool_names.append(f\"[IMPLEMENT]({base_path}/implement/) \")\n\n                descriptions = []\n                descriptions.append(\"Generates PR description - title, type, summary, code walkthrough and labels\")\n                descriptions.append(\"Adjustable feedback about the PR, possible issues, security concerns, review effort and more\")\n                descriptions.append(\"Code suggestions for improving the PR\")\n                descriptions.append(\"Automatically updates the changelog\")\n                descriptions.append(\"Answers a question regarding this repository, or a given one, based on given documentation path\")\n                descriptions.append(\"Generates documentation to methods/functions/classes that changed in the PR\")\n                descriptions.append(\"Generates unit tests for a specific component, based on the PR code change\")\n                descriptions.append(\"Code suggestions for a specific component that changed in the PR\")\n                descriptions.append(\"Identifies code components that changed in the PR, and enables to interactively generate tests, docs, and code suggestions for each component\")\n                descriptions.append(\"Answering free-text questions about the PR\")\n                descriptions.append(\"Automatically retrieves and presents similar issues\")\n                descriptions.append(\"Generates custom labels for the PR, based on specific guidelines defined by the user\")\n                descriptions.append(\"Generates feedback and analysis for a failed CI job\")\n                descriptions.append(\"Generates custom suggestions for improving the PR code, derived only from a specific guidelines prompt defined by the user\")\n                descriptions.append(\"Generates implementation code from review suggestions\")\n\n                commands  =[]\n                commands.append(\"`/describe`\")\n                commands.append(\"`/review`\")\n                commands.append(\"`/improve`\")\n                commands.append(\"`/update_changelog`\")\n                commands.append(\"`/help_docs`\")\n                commands.append(\"`/add_docs`\")\n                commands.append(\"`/test`\")\n                commands.append(\"`/improve_component`\")\n                commands.append(\"`/analyze`\")\n                commands.append(\"`/ask`\")\n                commands.append(\"`/generate_labels`\")\n                commands.append(\"`/checks`\")\n                commands.append(\"`/custom_prompt`\")\n                commands.append(\"`/implement`\")\n\n                checkbox_list = []\n                checkbox_list.append(\" - [ ] Run <!-- /describe -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /review -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /improve -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /update_changelog -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /help_docs -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /add_docs -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /test -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /improve_component -->\")\n                checkbox_list.append(\" - [ ] Run <!-- /analyze -->\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n                checkbox_list.append(\"[*]\")\n\n                if isinstance(self.git_provider, GithubProvider) and not get_settings().config.get('disable_checkboxes', False):\n                    pr_comment += f\"<table><tr align='left'><th align='left'>Tool</th><th align='left'>Description</th><th align='left'>Trigger Interactively :gem:</th></tr>\"\n                    for i in range(len(tool_names)):\n                        pr_comment += f\"\\n<tr><td align='left'>\\n\\n<strong>{tool_names[i]}</strong></td>\\n<td>{descriptions[i]}</td>\\n<td>\\n\\n{checkbox_list[i]}\\n</td></tr>\"\n                    pr_comment += \"</table>\\n\\n\"\n                    pr_comment += f\"\"\"\\n\\n(1) Note that each tool can be [triggered automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened) when a new PR is opened, or called manually by [commenting on a PR](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#online-usage).\"\"\"\n                    pr_comment += f\"\"\"\\n\\n(2) Tools marked with [*] require additional parameters to be passed. For example, to invoke the `/ask` tool, you need to comment on a PR: `/ask \"<question content>\"`. See the relevant documentation for each tool for more details.\"\"\"\n                elif isinstance(self.git_provider, BitbucketServerProvider):\n                    # only support basic commands in BBDC\n                    pr_comment = generate_bbdc_table(tool_names[:4], descriptions[:4])\n                else:\n                    pr_comment += f\"<table><tr align='left'><th align='left'>Tool</th><th align='left'>Command</th><th align='left'>Description</th></tr>\"\n                    for i in range(len(tool_names)):\n                        pr_comment += f\"\\n<tr><td align='left'>\\n\\n<strong>{tool_names[i]}</strong></td><td>{commands[i]}</td><td>{descriptions[i]}</td></tr>\"\n                    pr_comment += \"</table>\\n\\n\"\n                    pr_comment += f\"\"\"\\n\\nNote that each tool can be [invoked automatically](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/) when a new PR is opened, or called manually by [commenting on a PR](https://pr-agent-docs.codium.ai/usage-guide/automations_and_usage/#online-usage).\"\"\"\n\n                if get_settings().config.publish_output:\n                    self.git_provider.publish_comment(pr_comment)\n        except Exception as e:\n            get_logger().exception(f\"Error while running PRHelpMessage: {e}\")\n        return \"\"\n\n    async def prepare_relevant_snippets(self, sim_results):\n        # Get relevant snippets\n        relevant_snippets_full = []\n        relevant_pages_full = []\n        relevant_snippets_full_header = []\n        th = 0.75\n        for s in sim_results:\n            page = s[0].metadata['source']\n            content = s[0].page_content\n            score = s[1]\n            relevant_snippets_full.append(content)\n            relevant_snippets_full_header.append(extract_header(content))\n            relevant_pages_full.append(page)\n        # build the snippets string\n        relevant_snippets_str = \"\"\n        for i, s in enumerate(relevant_snippets_full):\n            relevant_snippets_str += f\"Snippet {i+1}:\\n\\n{s}\\n\\n\"\n            relevant_snippets_str += \"-------------------\\n\\n\"\n        return relevant_pages_full, relevant_snippets_full_header, relevant_snippets_str",
    "start_line": 32,
    "end_line": 316,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRHelpMessage",
    "component_id": "pr_agent.tools.pr_help_message.PRHelpMessage"
  },
  "pr_agent.tools.pr_help_message.generate_bbdc_table": {
    "id": "pr_agent.tools.pr_help_message.generate_bbdc_table",
    "name": "generate_bbdc_table",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_help_message.py",
    "relative_path": "pr_agent/tools/pr_help_message.py",
    "depends_on": [],
    "source_code": "def generate_bbdc_table(column_arr_1, column_arr_2):\n    # Generating header row\n    header_row = \"| Tool  | Description | \\n\"\n\n    # Generating separator row\n    separator_row = \"|--|--|\\n\"\n\n    # Generating data rows\n    data_rows = \"\"\n    max_len = max(len(column_arr_1), len(column_arr_2))\n    for i in range(max_len):\n        col1 = column_arr_1[i] if i < len(column_arr_1) else \"\"\n        col2 = column_arr_2[i] if i < len(column_arr_2) else \"\"\n        data_rows += f\"| {col1} | {col2} |\\n\"\n\n    # Combine all parts to form the complete table\n    markdown_table = header_row + separator_row + data_rows\n    return markdown_table",
    "start_line": 319,
    "end_line": 336,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "column_arr_1",
      "column_arr_2"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_bbdc_table",
    "component_id": "pr_agent.tools.pr_help_message.generate_bbdc_table"
  },
  "pr_agent.tools.pr_line_questions.PR_LineQuestions": {
    "id": "pr_agent.tools.pr_line_questions.PR_LineQuestions",
    "name": "PR_LineQuestions",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_line_questions.py",
    "relative_path": "pr_agent/tools/pr_line_questions.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.reply_to_comment_from_comment_id",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.algo.git_patch_processing.extract_hunk_lines_from_patch",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "class PR_LineQuestions:\n    def __init__(self, pr_url: str, args=None, ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n        self.question_str = self.parse_args(args)\n        self.git_provider = get_git_provider()(pr_url)\n        self.main_pr_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_pr_language\n\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"question\": self.question_str,\n            \"full_hunk\": \"\",\n            \"selected_lines\": \"\",\n        }\n        self.token_handler = TokenHandler(self.git_provider.pr,\n                                          self.vars,\n                                          get_settings().pr_line_questions_prompt.system,\n                                          get_settings().pr_line_questions_prompt.user)\n        self.patches_diff = None\n        self.prediction = None\n\n    def parse_args(self, args):\n        if args and len(args) > 0:\n            question_str = \" \".join(args)\n        else:\n            question_str = \"\"\n        return question_str\n\n\n    async def run(self):\n        get_logger().info('Answering a PR lines question...')\n        # if get_settings().config.publish_output:\n        #     self.git_provider.publish_comment(\"Preparing answer...\", is_temporary=True)\n\n        self.patch_with_lines = \"\"\n        ask_diff = get_settings().get('ask_diff_hunk', \"\")\n        line_start = get_settings().get('line_start', '')\n        line_end = get_settings().get('line_end', '')\n        side = get_settings().get('side', 'RIGHT')\n        file_name = get_settings().get('file_name', '')\n        comment_id = get_settings().get('comment_id', '')\n        if ask_diff:\n            self.patch_with_lines, self.selected_lines = extract_hunk_lines_from_patch(ask_diff,\n                                                                                       file_name,\n                                                                                       line_start=line_start,\n                                                                                       line_end=line_end,\n                                                                                       side=side\n                                                                                       )\n        else:\n            diff_files = self.git_provider.get_diff_files()\n            for file in diff_files:\n                if file.filename == file_name:\n                    self.patch_with_lines, self.selected_lines = extract_hunk_lines_from_patch(file.patch, file.filename,\n                                                                                               line_start=line_start,\n                                                                                               line_end=line_end,\n                                                                                               side=side)\n        if self.patch_with_lines:\n            model_answer = await retry_with_fallback_models(self._get_prediction, model_type=ModelType.WEAK)\n            # sanitize the answer so that no line will start with \"/\"\n            model_answer_sanitized = model_answer.strip().replace(\"\\n/\", \"\\n /\")\n            if model_answer_sanitized.startswith(\"/\"):\n                model_answer_sanitized = \" \" + model_answer_sanitized\n\n            get_logger().info('Preparing answer...')\n            if comment_id:\n                self.git_provider.reply_to_comment_from_comment_id(comment_id, model_answer_sanitized)\n            else:\n                self.git_provider.publish_comment(model_answer_sanitized)\n\n        return \"\"\n\n    async def _get_prediction(self, model: str):\n        variables = copy.deepcopy(self.vars)\n        variables[\"full_hunk\"] = self.patch_with_lines  # update diff\n        variables[\"selected_lines\"] = self.selected_lines\n        environment = Environment(undefined=StrictUndefined)\n        system_prompt = environment.from_string(get_settings().pr_line_questions_prompt.system).render(variables)\n        user_prompt = environment.from_string(get_settings().pr_line_questions_prompt.user).render(variables)\n        if get_settings().config.verbosity_level >= 2:\n            # get_logger().info(f\"\\nSystem prompt:\\n{system_prompt}\")\n            # get_logger().info(f\"\\nUser prompt:\\n{user_prompt}\")\n            print(f\"\\nSystem prompt:\\n{system_prompt}\")\n            print(f\"\\nUser prompt:\\n{user_prompt}\")\n\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model, temperature=get_settings().config.temperature, system=system_prompt, user=user_prompt)\n        return response",
    "start_line": 21,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PR_LineQuestions",
    "component_id": "pr_agent.tools.pr_line_questions.PR_LineQuestions"
  },
  "pr_agent.tools.pr_questions.PRQuestions": {
    "id": "pr_agent.tools.pr_questions.PRQuestions",
    "name": "PRQuestions",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_questions.py",
    "relative_path": "pr_agent/tools/pr_questions.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.config_loader.get_settings",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "class PRQuestions:\n    def __init__(self, pr_url: str, args=None, ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n        question_str = self.parse_args(args)\n        self.pr_url = pr_url\n        self.git_provider = get_git_provider()(pr_url)\n        self.main_pr_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_pr_language\n\n        self.question_str = question_str\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.git_provider.get_pr_description(),\n            \"language\": self.main_pr_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"questions\": self.question_str,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n        }\n        self.token_handler = TokenHandler(self.git_provider.pr,\n                                          self.vars,\n                                          get_settings().pr_questions_prompt.system,\n                                          get_settings().pr_questions_prompt.user)\n        self.patches_diff = None\n        self.prediction = None\n\n    def parse_args(self, args):\n        if args and len(args) > 0:\n            question_str = \" \".join(args)\n        else:\n            question_str = \"\"\n        return question_str\n\n    async def run(self):\n        get_logger().info(f'Answering a PR question about the PR {self.pr_url} ')\n        relevant_configs = {'pr_questions': dict(get_settings().pr_questions),\n                            'config': dict(get_settings().config)}\n        get_logger().debug(\"Relevant configs\", artifacts=relevant_configs)\n        if get_settings().config.publish_output:\n            self.git_provider.publish_comment(\"Preparing answer...\", is_temporary=True)\n\n        # identify image\n        img_path = self.identify_image_in_comment()\n        if img_path:\n            get_logger().debug(f\"Image path identified\", artifact=img_path)\n\n        await retry_with_fallback_models(self._prepare_prediction, model_type=ModelType.WEAK)\n\n        pr_comment = self._prepare_pr_answer()\n        get_logger().debug(f\"PR output\", artifact=pr_comment)\n\n        if self.git_provider.is_supported(\"gfm_markdown\") and get_settings().pr_questions.enable_help_text:\n            pr_comment += \"<hr>\\n\\n<details> <summary><strong> Tool usage guide:</strong></summary><hr> \\n\\n\"\n            pr_comment += HelpMessage.get_ask_usage_guide()\n            pr_comment += \"\\n</details>\\n\"\n\n        if get_settings().config.publish_output:\n            self.git_provider.publish_comment(pr_comment)\n            self.git_provider.remove_initial_comment()\n        return \"\"\n\n    def identify_image_in_comment(self):\n        img_path = ''\n        if '![image]' in self.question_str:\n            # assuming structure:\n            # /ask question ...  > ![image](img_path)\n            img_path = self.question_str.split('![image]')[1].strip().strip('()')\n            self.vars['img_path'] = img_path\n        elif 'https://' in self.question_str and ('.png' in self.question_str or 'jpg' in self.question_str): # direct image link\n            # include https:// in the image path\n            img_path = 'https://' + self.question_str.split('https://')[1]\n            self.vars['img_path'] = img_path\n        return img_path\n\n    async def _prepare_prediction(self, model: str):\n        self.patches_diff = get_pr_diff(self.git_provider, self.token_handler, model)\n        if self.patches_diff:\n            get_logger().debug(f\"PR diff\", artifact=self.patches_diff)\n            self.prediction = await self._get_prediction(model)\n        else:\n            get_logger().error(f\"Error getting PR diff\")\n            self.prediction = \"\"\n\n    async def _get_prediction(self, model: str):\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = self.patches_diff  # update diff\n        environment = Environment(undefined=StrictUndefined)\n        system_prompt = environment.from_string(get_settings().pr_questions_prompt.system).render(variables)\n        user_prompt = environment.from_string(get_settings().pr_questions_prompt.user).render(variables)\n        if 'img_path' in variables:\n            img_path = self.vars['img_path']\n            response, finish_reason = await (self.ai_handler.chat_completion\n                                             (model=model, temperature=get_settings().config.temperature,\n                                              system=system_prompt, user=user_prompt, img_path=img_path))\n        else:\n            response, finish_reason = await self.ai_handler.chat_completion(\n                model=model, temperature=get_settings().config.temperature, system=system_prompt, user=user_prompt)\n        return response\n\n    def _prepare_pr_answer(self) -> str:\n        model_answer = self.prediction.strip()\n        # sanitize the answer so that no line will start with \"/\"\n        model_answer_sanitized = model_answer.replace(\"\\n/\", \"\\n /\")\n        if model_answer_sanitized.startswith(\"/\"):\n            model_answer_sanitized = \" \" + model_answer_sanitized\n        if model_answer_sanitized != model_answer:\n            get_logger().debug(f\"Sanitized model answer\",\n                               artifact={\"model_answer\": model_answer, \"sanitized_answer\": model_answer_sanitized})\n\n\n        answer_str = f\"### **Ask**\\n{self.question_str}\\n\\n\"\n        answer_str += f\"### **Answer:**\\n{model_answer_sanitized}\\n\\n\"\n        return answer_str",
    "start_line": 18,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRQuestions",
    "component_id": "pr_agent.tools.pr_questions.PRQuestions"
  },
  "pr_agent.tools.pr_reviewer.PRReviewer": {
    "id": "pr_agent.tools.pr_reviewer.PRReviewer",
    "name": "PRReviewer",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_reviewer.py",
    "relative_path": "pr_agent/tools/pr_reviewer.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.publish_persistent_comment",
      "pr_agent.git_providers.git_provider.get_diff_files",
      "pr_agent.git_providers.git_provider.auto_approve",
      "pr_agent.git_providers.git_provider.IncrementalPR",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.git_providers.git_provider.remove_comment",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.git_providers.git_provider.get_incremental_commits",
      "pr_agent.algo.utils.convert_to_markdown_v2",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.git_providers.git_provider.get_pr_labels",
      "pr_agent.git_providers.__init__.get_git_provider_with_context",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.algo.pr_processing.add_ai_metadata_to_diff_files",
      "pr_agent.servers.github_polling.now",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.get_num_of_files",
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.tools.ticket_pr_compliance_check.extract_and_cache_pr_tickets",
      "pr_agent.algo.utils.show_relevant_configurations",
      "pr_agent.git_providers.git_provider.get_issue_comments",
      "pr_agent.git_providers.git_provider.publish_labels",
      "pr_agent.git_providers.git_provider.get_pr_url",
      "pr_agent.algo.utils.load_yaml",
      "pr_agent.algo.utils.github_action_output"
    ],
    "source_code": "class PRReviewer:\n    \"\"\"\n    The PRReviewer class is responsible for reviewing a pull request and generating feedback using an AI model.\n    \"\"\"\n\n    def __init__(self, pr_url: str, is_answer: bool = False, is_auto: bool = False, args: list = None,\n                 ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n        \"\"\"\n        Initialize the PRReviewer object with the necessary attributes and objects to review a pull request.\n\n        Args:\n            pr_url (str): The URL of the pull request to be reviewed.\n            is_answer (bool, optional): Indicates whether the review is being done in answer mode. Defaults to False.\n            is_auto (bool, optional): Indicates whether the review is being done in automatic mode. Defaults to False.\n            ai_handler (BaseAiHandler): The AI handler to be used for the review. Defaults to None.\n            args (list, optional): List of arguments passed to the PRReviewer class. Defaults to None.\n        \"\"\"\n        self.git_provider = get_git_provider_with_context(pr_url)\n        self.args = args\n        self.incremental = self.parse_incremental(args)  # -i command\n        if self.incremental and self.incremental.is_incremental:\n            self.git_provider.get_incremental_commits(self.incremental)\n\n        self.main_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n        self.pr_url = pr_url\n        self.is_answer = is_answer\n        self.is_auto = is_auto\n\n        if self.is_answer and not self.git_provider.is_supported(\"get_issue_comments\"):\n            raise Exception(f\"Answer mode is not supported for {get_settings().config.git_provider} for now\")\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_language\n        self.patches_diff = None\n        self.prediction = None\n        answer_str, question_str = self._get_user_answers()\n        self.pr_description, self.pr_description_files = (\n            self.git_provider.get_pr_description(split_changes_walkthrough=True))\n        if (self.pr_description_files and get_settings().get(\"config.is_auto_command\", False) and\n                get_settings().get(\"config.enable_ai_metadata\", False)):\n            add_ai_metadata_to_diff_files(self.git_provider, self.pr_description_files)\n            get_logger().debug(f\"AI metadata added to the this command\")\n        else:\n            get_settings().set(\"config.enable_ai_metadata\", False)\n            get_logger().debug(f\"AI metadata is disabled for this command\")\n\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.pr_description,\n            \"language\": self.main_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"num_pr_files\": self.git_provider.get_num_of_files(),\n            \"require_score\": get_settings().pr_reviewer.require_score_review,\n            \"require_tests\": get_settings().pr_reviewer.require_tests_review,\n            \"require_estimate_effort_to_review\": get_settings().pr_reviewer.require_estimate_effort_to_review,\n            'require_can_be_split_review': get_settings().pr_reviewer.require_can_be_split_review,\n            'require_security_review': get_settings().pr_reviewer.require_security_review,\n            'question_str': question_str,\n            'answer_str': answer_str,\n            \"extra_instructions\": get_settings().pr_reviewer.extra_instructions,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n            \"custom_labels\": \"\",\n            \"enable_custom_labels\": get_settings().config.enable_custom_labels,\n            \"is_ai_metadata\":  get_settings().get(\"config.enable_ai_metadata\", False),\n            \"related_tickets\": get_settings().get('related_tickets', []),\n            'duplicate_prompt_examples': get_settings().config.get('duplicate_prompt_examples', False),\n            \"date\": datetime.datetime.now().strftime('%Y-%m-%d'),\n        }\n\n        self.token_handler = TokenHandler(\n            self.git_provider.pr,\n            self.vars,\n            get_settings().pr_review_prompt.system,\n            get_settings().pr_review_prompt.user\n        )\n\n    def parse_incremental(self, args: List[str]):\n        is_incremental = False\n        if args and len(args) >= 1:\n            arg = args[0]\n            if arg == \"-i\":\n                is_incremental = True\n        incremental = IncrementalPR(is_incremental)\n        return incremental\n\n    async def run(self) -> None:\n        try:\n            if not self.git_provider.get_files():\n                get_logger().info(f\"PR has no files: {self.pr_url}, skipping review\")\n                return None\n\n            if self.incremental.is_incremental and not self._can_run_incremental_review():\n                return None\n\n            # if isinstance(self.args, list) and self.args and self.args[0] == 'auto_approve':\n            #     get_logger().info(f'Auto approve flow PR: {self.pr_url} ...')\n            #     self.auto_approve_logic()\n            #     return None\n\n            get_logger().info(f'Reviewing PR: {self.pr_url} ...')\n            relevant_configs = {'pr_reviewer': dict(get_settings().pr_reviewer),\n                                'config': dict(get_settings().config)}\n            get_logger().debug(\"Relevant configs\", artifacts=relevant_configs)\n\n            # ticket extraction if exists\n            await extract_and_cache_pr_tickets(self.git_provider, self.vars)\n\n            if self.incremental.is_incremental and hasattr(self.git_provider, \"unreviewed_files_set\") and not self.git_provider.unreviewed_files_set:\n                get_logger().info(f\"Incremental review is enabled for {self.pr_url} but there are no new files\")\n                previous_review_url = \"\"\n                if hasattr(self.git_provider, \"previous_review\"):\n                    previous_review_url = self.git_provider.previous_review.html_url\n                if get_settings().config.publish_output:\n                    self.git_provider.publish_comment(f\"Incremental Review Skipped\\n\"\n                                    f\"No files were changed since the [previous PR Review]({previous_review_url})\")\n                return None\n            \n            if get_settings().config.publish_output and not get_settings().config.get('is_auto_command', False):\n                self.git_provider.publish_comment(\"Preparing review...\", is_temporary=True)\n\n            await retry_with_fallback_models(self._prepare_prediction, model_type=ModelType.REGULAR)\n            if not self.prediction:\n                self.git_provider.remove_initial_comment()\n                return None\n\n            pr_review = self._prepare_pr_review()\n            get_logger().debug(f\"PR output\", artifact=pr_review)\n\n            if get_settings().config.publish_output:\n                # publish the review\n                if get_settings().pr_reviewer.persistent_comment and not self.incremental.is_incremental:\n                    final_update_message = get_settings().pr_reviewer.final_update_message\n                    self.git_provider.publish_persistent_comment(pr_review,\n                                                                 initial_header=f\"{PRReviewHeader.REGULAR.value} \",\n                                                                 update_header=True,\n                                                                 final_update_message=final_update_message, )\n                else:\n                    self.git_provider.publish_comment(pr_review)\n\n                self.git_provider.remove_initial_comment()\n            else:\n                get_logger().info(\"Review output is not published\")\n                get_settings().data = {\"artifact\": pr_review}\n                return\n        except Exception as e:\n            get_logger().error(f\"Failed to review PR: {e}\")\n\n    async def _prepare_prediction(self, model: str) -> None:\n        self.patches_diff = get_pr_diff(self.git_provider,\n                                        self.token_handler,\n                                        model,\n                                        add_line_numbers_to_hunks=True,\n                                        disable_extra_lines=False,)\n\n        if self.patches_diff:\n            get_logger().debug(f\"PR diff\", diff=self.patches_diff)\n            self.prediction = await self._get_prediction(model)\n        else:\n            get_logger().warning(f\"Empty diff for PR: {self.pr_url}\")\n            self.prediction = None\n\n    async def _get_prediction(self, model: str) -> str:\n        \"\"\"\n        Generate an AI prediction for the pull request review.\n\n        Args:\n            model: A string representing the AI model to be used for the prediction.\n\n        Returns:\n            A string representing the AI prediction for the pull request review.\n        \"\"\"\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = self.patches_diff  # update diff\n\n        environment = Environment(undefined=StrictUndefined)\n        system_prompt = environment.from_string(get_settings().pr_review_prompt.system).render(variables)\n        user_prompt = environment.from_string(get_settings().pr_review_prompt.user).render(variables)\n\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model,\n            temperature=get_settings().config.temperature,\n            system=system_prompt,\n            user=user_prompt,\n            \n        )\n\n        return response\n\n    def _prepare_pr_review(self) -> str:\n        \"\"\"\n        Prepare the PR review by processing the AI prediction and generating a markdown-formatted text that summarizes\n        the feedback.\n        \"\"\"\n        first_key = 'review'\n        last_key = 'security_concerns'\n        data = load_yaml(self.prediction.strip(),\n                         keys_fix_yaml=[\"ticket_compliance_check\", \"estimated_effort_to_review_[1-5]:\", \"security_concerns:\", \"key_issues_to_review:\",\n                                        \"relevant_file:\", \"relevant_line:\", \"suggestion:\"],\n                         first_key=first_key, last_key=last_key)\n        github_action_output(data, 'review')\n\n        # move data['review'] 'key_issues_to_review' key to the end of the dictionary\n        if 'key_issues_to_review' in data['review']:\n            key_issues_to_review = data['review'].pop('key_issues_to_review')\n            data['review']['key_issues_to_review'] = key_issues_to_review\n\n        incremental_review_markdown_text = None\n        # Add incremental review section\n        if self.incremental.is_incremental:\n            last_commit_url = f\"{self.git_provider.get_pr_url()}/commits/\" \\\n                              f\"{self.git_provider.incremental.first_new_commit_sha}\"\n            incremental_review_markdown_text = f\"Starting from commit {last_commit_url}\"\n\n        markdown_text = convert_to_markdown_v2(data, self.git_provider.is_supported(\"gfm_markdown\"),\n                                            incremental_review_markdown_text,\n                                               git_provider=self.git_provider,\n                                               files=self.git_provider.get_diff_files())\n\n        # Add help text if gfm_markdown is supported\n        if self.git_provider.is_supported(\"gfm_markdown\") and get_settings().pr_reviewer.enable_help_text:\n            markdown_text += \"<hr>\\n\\n<details> <summary><strong> Tool usage guide:</strong></summary><hr> \\n\\n\"\n            markdown_text += HelpMessage.get_review_usage_guide()\n            markdown_text += \"\\n</details>\\n\"\n\n        # Output the relevant configurations if enabled\n        if get_settings().get('config', {}).get('output_relevant_configurations', False):\n            markdown_text += show_relevant_configurations(relevant_section='pr_reviewer')\n\n        # Add custom labels from the review prediction (effort, security)\n        self.set_review_labels(data)\n\n        if markdown_text == None or len(markdown_text) == 0:\n            markdown_text = \"\"\n\n        return markdown_text\n\n    def _get_user_answers(self) -> Tuple[str, str]:\n        \"\"\"\n        Retrieves the question and answer strings from the discussion messages related to a pull request.\n\n        Returns:\n            A tuple containing the question and answer strings.\n        \"\"\"\n        question_str = \"\"\n        answer_str = \"\"\n\n        if self.is_answer:\n            discussion_messages = self.git_provider.get_issue_comments()\n\n            for message in discussion_messages.reversed:\n                if \"Questions to better understand the PR:\" in message.body:\n                    question_str = message.body\n                elif '/answer' in message.body:\n                    answer_str = message.body\n\n                if answer_str and question_str:\n                    break\n\n        return question_str, answer_str\n\n    def _get_previous_review_comment(self):\n        \"\"\"\n        Get the previous review comment if it exists.\n        \"\"\"\n        try:\n            if hasattr(self.git_provider, \"get_previous_review\"):\n                return self.git_provider.get_previous_review(\n                    full=not self.incremental.is_incremental,\n                    incremental=self.incremental.is_incremental,\n                )\n        except Exception as e:\n            get_logger().exception(f\"Failed to get previous review comment, error: {e}\")\n\n    def _remove_previous_review_comment(self, comment):\n        \"\"\"\n        Remove the previous review comment if it exists.\n        \"\"\"\n        try:\n            if comment:\n                self.git_provider.remove_comment(comment)\n        except Exception as e:\n            get_logger().exception(f\"Failed to remove previous review comment, error: {e}\")\n\n    def _can_run_incremental_review(self) -> bool:\n        \"\"\"Checks if we can run incremental review according the various configurations and previous review\"\"\"\n        # checking if running is auto mode but there are no new commits\n        if self.is_auto and not self.incremental.first_new_commit_sha:\n            get_logger().info(f\"Incremental review is enabled for {self.pr_url} but there are no new commits\")\n            return False\n\n        if not hasattr(self.git_provider, \"get_incremental_commits\"):\n            get_logger().info(f\"Incremental review is not supported for {get_settings().config.git_provider}\")\n            return False\n        # checking if there are enough commits to start the review\n        num_new_commits = len(self.incremental.commits_range)\n        num_commits_threshold = get_settings().pr_reviewer.minimal_commits_for_incremental_review\n        not_enough_commits = num_new_commits < num_commits_threshold\n        # checking if the commits are not too recent to start the review\n        recent_commits_threshold = datetime.datetime.now() - datetime.timedelta(\n            minutes=get_settings().pr_reviewer.minimal_minutes_for_incremental_review\n        )\n        last_seen_commit_date = (\n            self.incremental.last_seen_commit.commit.author.date if self.incremental.last_seen_commit else None\n        )\n        all_commits_too_recent = (\n            last_seen_commit_date > recent_commits_threshold if self.incremental.last_seen_commit else False\n        )\n        # check all the thresholds or just one to start the review\n        condition = any if get_settings().pr_reviewer.require_all_thresholds_for_incremental_review else all\n        if condition((not_enough_commits, all_commits_too_recent)):\n            get_logger().info(\n                f\"Incremental review is enabled for {self.pr_url} but didn't pass the threshold check to run:\"\n                f\"\\n* Number of new commits = {num_new_commits} (threshold is {num_commits_threshold})\"\n                f\"\\n* Last seen commit date = {last_seen_commit_date} (threshold is {recent_commits_threshold})\"\n            )\n            return False\n        return True\n\n    def set_review_labels(self, data):\n        if not get_settings().config.publish_output:\n            return\n\n        if not get_settings().pr_reviewer.require_estimate_effort_to_review:\n            get_settings().pr_reviewer.enable_review_labels_effort = False # we did not generate this output\n        if not get_settings().pr_reviewer.require_security_review:\n            get_settings().pr_reviewer.enable_review_labels_security = False # we did not generate this output\n\n        if (get_settings().pr_reviewer.enable_review_labels_security or\n                get_settings().pr_reviewer.enable_review_labels_effort):\n            try:\n                review_labels = []\n                if get_settings().pr_reviewer.enable_review_labels_effort:\n                    estimated_effort = data['review']['estimated_effort_to_review_[1-5]']\n                    estimated_effort_number = 0\n                    if isinstance(estimated_effort, str):\n                        try:\n                            estimated_effort_number = int(estimated_effort.split(',')[0])\n                        except ValueError:\n                            get_logger().warning(f\"Invalid estimated_effort value: {estimated_effort}\")\n                    elif isinstance(estimated_effort, int):\n                        estimated_effort_number = estimated_effort\n                    else:\n                        get_logger().warning(f\"Unexpected type for estimated_effort: {type(estimated_effort)}\")\n                    if 1 <= estimated_effort_number <= 5:  # 1, because ...\n                        review_labels.append(f'Review effort {estimated_effort_number}/5')\n                if get_settings().pr_reviewer.enable_review_labels_security and get_settings().pr_reviewer.require_security_review:\n                    security_concerns = data['review']['security_concerns']  # yes, because ...\n                    security_concerns_bool = 'yes' in security_concerns.lower() or 'true' in security_concerns.lower()\n                    if security_concerns_bool:\n                        review_labels.append('Possible security concern')\n\n                current_labels = self.git_provider.get_pr_labels(update=True)\n                if not current_labels:\n                    current_labels = []\n                get_logger().debug(f\"Current labels:\\n{current_labels}\")\n                if current_labels:\n                    current_labels_filtered = [label for label in current_labels if\n                                               not label.lower().startswith('review effort') and not label.lower().startswith(\n                                                   'possible security concern')]\n                else:\n                    current_labels_filtered = []\n                new_labels = review_labels + current_labels_filtered\n                if (current_labels or review_labels) and sorted(new_labels) != sorted(current_labels):\n                    get_logger().info(f\"Setting review labels:\\n{review_labels + current_labels_filtered}\")\n                    self.git_provider.publish_labels(new_labels)\n                else:\n                    get_logger().info(f\"Review labels are already set:\\n{review_labels + current_labels_filtered}\")\n            except Exception as e:\n                get_logger().error(f\"Failed to set review labels, error: {e}\")\n\n    def auto_approve_logic(self):\n        \"\"\"\n        Auto-approve a pull request if it meets the conditions for auto-approval.\n        \"\"\"\n        if get_settings().config.enable_auto_approval:\n            is_auto_approved = self.git_provider.auto_approve()\n            if is_auto_approved:\n                get_logger().info(\"Auto-approved PR\")\n                self.git_provider.publish_comment(\"Auto-approved PR\")\n        else:\n            get_logger().info(\"Auto-approval option is disabled\")\n            self.git_provider.publish_comment(\"Auto-approval option for PR-Agent is disabled. \"\n                                              \"You can enable it via a [configuration file](https://github.com/Codium-ai/pr-agent/blob/main/docs/REVIEW.md#auto-approval-1)\")",
    "start_line": 30,
    "end_line": 414,
    "has_docstring": true,
    "docstring": "The PRReviewer class is responsible for reviewing a pull request and generating feedback using an AI model.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRReviewer",
    "component_id": "pr_agent.tools.pr_reviewer.PRReviewer"
  },
  "pr_agent.tools.pr_similar_issue.PRSimilarIssue": {
    "id": "pr_agent.tools.pr_similar_issue.PRSimilarIssue",
    "name": "PRSimilarIssue",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_similar_issue.py",
    "relative_path": "pr_agent/tools/pr_similar_issue.py",
    "depends_on": [
      "pr_agent.tools.pr_similar_issue.Record",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.gerrit_provider.fetch",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.tools.pr_similar_issue.Corpus",
      "pr_agent.algo.utils.get_max_tokens",
      "pr_agent.tools.pr_similar_issue.Metadata",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "class PRSimilarIssue:\n    def __init__(self, issue_url: str, ai_handler, args: list = None):\n        if get_settings().config.git_provider != \"github\":\n            raise Exception(\"Only github is supported for similar issue tool\")\n\n        self.cli_mode = get_settings().CONFIG.CLI_MODE\n        self.max_issues_to_scan = get_settings().pr_similar_issue.max_issues_to_scan\n        self.issue_url = issue_url\n        self.git_provider = get_git_provider()()\n        repo_name, issue_number = self.git_provider._parse_issue_url(issue_url.split('=')[-1])\n        self.git_provider.repo = repo_name\n        self.git_provider.repo_obj = self.git_provider.github_client.get_repo(repo_name)\n        self.token_handler = TokenHandler()\n        repo_obj = self.git_provider.repo_obj\n        repo_name_for_index = self.repo_name_for_index = repo_obj.full_name.lower().replace('/', '-').replace('_/', '-')\n        index_name = self.index_name = \"codium-ai-pr-agent-issues\"\n\n        if get_settings().pr_similar_issue.vectordb == \"pinecone\":\n            try:\n                import pandas as pd\n                import pinecone\n                from pinecone_datasets import Dataset, DatasetMetadata\n            except:\n                raise Exception(\"Please install 'pinecone' and 'pinecone_datasets' to use pinecone as vectordb\")\n            # assuming pinecone api key and environment are set in secrets file\n            try:\n                api_key = get_settings().pinecone.api_key\n                environment = get_settings().pinecone.environment\n            except Exception:\n                if not self.cli_mode:\n                    repo_name, original_issue_number = self.git_provider._parse_issue_url(self.issue_url.split('=')[-1])\n                    issue_main = self.git_provider.repo_obj.get_issue(original_issue_number)\n                    issue_main.create_comment(\"Please set pinecone api key and environment in secrets file\")\n                raise Exception(\"Please set pinecone api key and environment in secrets file\")\n\n            # check if index exists, and if repo is already indexed\n            run_from_scratch = False\n            if run_from_scratch:  # for debugging\n                pinecone.init(api_key=api_key, environment=environment)\n                if index_name in pinecone.list_indexes():\n                    get_logger().info('Removing index...')\n                    pinecone.delete_index(index_name)\n                    get_logger().info('Done')\n\n            upsert = True\n            pinecone.init(api_key=api_key, environment=environment)\n            if not index_name in pinecone.list_indexes():\n                run_from_scratch = True\n                upsert = False\n            else:\n                if get_settings().pr_similar_issue.force_update_dataset:\n                    upsert = True\n                else:\n                    pinecone_index = pinecone.Index(index_name=index_name)\n                    res = pinecone_index.fetch([f\"example_issue_{repo_name_for_index}\"]).to_dict()\n                    if res[\"vectors\"]:\n                        upsert = False\n\n            if run_from_scratch or upsert:  # index the entire repo\n                get_logger().info('Indexing the entire repo...')\n\n                get_logger().info('Getting issues...')\n                issues = list(repo_obj.get_issues(state='all'))\n                get_logger().info('Done')\n                self._update_index_with_issues(issues, repo_name_for_index, upsert=upsert)\n            else:  # update index if needed\n                pinecone_index = pinecone.Index(index_name=index_name)\n                issues_to_update = []\n                issues_paginated_list = repo_obj.get_issues(state='all')\n                counter = 1\n                for issue in issues_paginated_list:\n                    if issue.pull_request:\n                        continue\n                    issue_str, comments, number = self._process_issue(issue)\n                    issue_key = f\"issue_{number}\"\n                    id = issue_key + \".\" + \"issue\"\n                    res = pinecone_index.fetch([id]).to_dict()\n                    is_new_issue = True\n                    for vector in res[\"vectors\"].values():\n                        if vector['metadata']['repo'] == repo_name_for_index:\n                            is_new_issue = False\n                            break\n                    if is_new_issue:\n                        counter += 1\n                        issues_to_update.append(issue)\n                    else:\n                        break\n\n                if issues_to_update:\n                    get_logger().info(f'Updating index with {counter} new issues...')\n                    self._update_index_with_issues(issues_to_update, repo_name_for_index, upsert=True)\n                else:\n                    get_logger().info('No new issues to update')\n\n        elif get_settings().pr_similar_issue.vectordb == \"lancedb\":\n            try:\n                import lancedb  # import lancedb only if needed\n            except:\n                raise Exception(\"Please install lancedb to use lancedb as vectordb\")\n            self.db = lancedb.connect(get_settings().lancedb.uri)\n            self.table = None\n\n            run_from_scratch = False\n            if run_from_scratch:  # for debugging\n                if index_name in self.db.table_names():\n                    get_logger().info('Removing Table...')\n                    self.db.drop_table(index_name)\n                    get_logger().info('Done')\n\n            ingest = True\n            if index_name not in self.db.table_names():\n                run_from_scratch = True\n                ingest = False\n            else:\n                if get_settings().pr_similar_issue.force_update_dataset:\n                    ingest = True\n                else:\n                    self.table = self.db[index_name]\n                    res = self.table.search().limit(len(self.table)).where(f\"id='example_issue_{repo_name_for_index}'\").to_list()\n                    get_logger().info(\"result: \", res)\n                    if res[0].get(\"vector\"):\n                        ingest = False\n\n            if run_from_scratch or ingest:  # indexing the entire repo\n                get_logger().info('Indexing the entire repo...')\n\n                get_logger().info('Getting issues...')\n                issues = list(repo_obj.get_issues(state='all'))\n                get_logger().info('Done')\n\n                self._update_table_with_issues(issues, repo_name_for_index, ingest=ingest)\n            else:  # update table if needed\n                issues_to_update = []\n                issues_paginated_list = repo_obj.get_issues(state='all')\n                counter = 1\n                for issue in issues_paginated_list:\n                    if issue.pull_request:\n                        continue\n                    issue_str, comments, number = self._process_issue(issue)\n                    issue_key = f\"issue_{number}\"\n                    issue_id = issue_key + \".\" + \"issue\"\n                    res = self.table.search().limit(len(self.table)).where(f\"id='{issue_id}'\").to_list()\n                    is_new_issue = True\n                    for r in res:\n                        if r['metadata']['repo'] == repo_name_for_index:\n                            is_new_issue = False\n                            break\n                    if is_new_issue:\n                        counter += 1\n                        issues_to_update.append(issue)\n                    else:\n                        break\n\n                if issues_to_update:\n                    get_logger().info(f'Updating index with {counter} new issues...')\n                    self._update_table_with_issues(issues_to_update, repo_name_for_index, ingest=True)\n                else:\n                    get_logger().info('No new issues to update')\n\n\n    async def run(self):\n        get_logger().info('Getting issue...')\n        repo_name, original_issue_number = self.git_provider._parse_issue_url(self.issue_url.split('=')[-1])\n        issue_main = self.git_provider.repo_obj.get_issue(original_issue_number)\n        issue_str, comments, number = self._process_issue(issue_main)\n        openai.api_key = get_settings().openai.key\n        get_logger().info('Done')\n\n        get_logger().info('Querying...')\n        res = openai.Embedding.create(input=[issue_str], engine=MODEL)\n        embeds = [record['embedding'] for record in res['data']]\n\n        relevant_issues_number_list = []\n        relevant_comment_number_list = []\n        score_list = []\n\n        if get_settings().pr_similar_issue.vectordb == \"pinecone\":\n            pinecone_index = pinecone.Index(index_name=self.index_name)\n            res = pinecone_index.query(embeds[0],\n                                    top_k=5,\n                                    filter={\"repo\": self.repo_name_for_index},\n                                    include_metadata=True).to_dict()\n\n            for r in res['matches']:\n                # skip example issue\n                if 'example_issue_' in r[\"id\"]:\n                    continue\n\n                try:\n                    issue_number = int(r[\"id\"].split('.')[0].split('_')[-1])\n                except:\n                    get_logger().debug(f\"Failed to parse issue number from {r['id']}\")\n                    continue\n\n                if original_issue_number == issue_number:\n                    continue\n                if issue_number not in relevant_issues_number_list:\n                    relevant_issues_number_list.append(issue_number)\n                if 'comment' in r[\"id\"]:\n                    relevant_comment_number_list.append(int(r[\"id\"].split('.')[1].split('_')[-1]))\n                else:\n                    relevant_comment_number_list.append(-1)\n                score_list.append(str(\"{:.2f}\".format(r['score'])))\n            get_logger().info('Done')\n\n        elif get_settings().pr_similar_issue.vectordb == \"lancedb\":\n            res = self.table.search(embeds[0]).where(f\"metadata.repo='{self.repo_name_for_index}'\", prefilter=True).to_list()\n\n            for r in res:\n                # skip example issue\n                if 'example_issue_' in r[\"id\"]:\n                    continue\n\n                try:\n                    issue_number = int(r[\"id\"].split('.')[0].split('_')[-1])\n                except:\n                    get_logger().debug(f\"Failed to parse issue number from {r['id']}\")\n                    continue\n\n                if original_issue_number == issue_number:\n                    continue\n                if issue_number not in relevant_issues_number_list:\n                    relevant_issues_number_list.append(issue_number)\n\n                if 'comment' in r[\"id\"]:\n                    relevant_comment_number_list.append(int(r[\"id\"].split('.')[1].split('_')[-1]))\n                else:\n                    relevant_comment_number_list.append(-1)\n                score_list.append(str(\"{:.2f}\".format(1-r['_distance'])))\n            get_logger().info('Done')\n\n        get_logger().info('Publishing response...')\n        similar_issues_str = \"### Similar Issues\\n___\\n\\n\"\n\n        for i, issue_number_similar in enumerate(relevant_issues_number_list):\n            issue = self.git_provider.repo_obj.get_issue(issue_number_similar)\n            title = issue.title\n            url = issue.html_url\n            if relevant_comment_number_list[i] != -1:\n                url = list(issue.get_comments())[relevant_comment_number_list[i]].html_url\n            similar_issues_str += f\"{i + 1}. **[{title}]({url})** (score={score_list[i]})\\n\\n\"\n        if get_settings().config.publish_output:\n            response = issue_main.create_comment(similar_issues_str)\n        get_logger().info(similar_issues_str)\n        get_logger().info('Done')\n\n    def _process_issue(self, issue):\n        header = issue.title\n        body = issue.body\n        number = issue.number\n        if get_settings().pr_similar_issue.skip_comments:\n            comments = []\n        else:\n            comments = list(issue.get_comments())\n        issue_str = f\"Issue Header: \\\"{header}\\\"\\n\\nIssue Body:\\n{body}\"\n        return issue_str, comments, number\n\n    def _update_index_with_issues(self, issues_list, repo_name_for_index, upsert=False):\n        get_logger().info('Processing issues...')\n        corpus = Corpus()\n        example_issue_record = Record(\n            id=f\"example_issue_{repo_name_for_index}\",\n            text=\"example_issue\",\n            metadata=Metadata(repo=repo_name_for_index)\n        )\n        corpus.append(example_issue_record)\n\n        counter = 0\n        for issue in issues_list:\n            if issue.pull_request:\n                continue\n\n            counter += 1\n            if counter % 100 == 0:\n                get_logger().info(f\"Scanned {counter} issues\")\n            if counter >= self.max_issues_to_scan:\n                get_logger().info(f\"Scanned {self.max_issues_to_scan} issues, stopping\")\n                break\n\n            issue_str, comments, number = self._process_issue(issue)\n            issue_key = f\"issue_{number}\"\n            username = issue.user.login\n            created_at = str(issue.created_at)\n            if len(issue_str) < 8000 or \\\n                    self.token_handler.count_tokens(issue_str) < get_max_tokens(MODEL):  # fast reject first\n                issue_record = Record(\n                    id=issue_key + \".\" + \"issue\",\n                    text=issue_str,\n                    metadata=Metadata(repo=repo_name_for_index,\n                                      username=username,\n                                      created_at=created_at,\n                                      level=IssueLevel.ISSUE)\n                )\n                corpus.append(issue_record)\n                if comments:\n                    for j, comment in enumerate(comments):\n                        comment_body = comment.body\n                        num_words_comment = len(comment_body.split())\n                        if num_words_comment < 10 or not isinstance(comment_body, str):\n                            continue\n\n                        if len(comment_body) < 8000 or \\\n                                self.token_handler.count_tokens(comment_body) < MAX_TOKENS[MODEL]:\n                            comment_record = Record(\n                                id=issue_key + \".comment_\" + str(j + 1),\n                                text=comment_body,\n                                metadata=Metadata(repo=repo_name_for_index,\n                                                  username=username,  # use issue username for all comments\n                                                  created_at=created_at,\n                                                  level=IssueLevel.COMMENT)\n                            )\n                            corpus.append(comment_record)\n        df = pd.DataFrame(corpus.dict()[\"documents\"])\n        get_logger().info('Done')\n\n        get_logger().info('Embedding...')\n        openai.api_key = get_settings().openai.key\n        list_to_encode = list(df[\"text\"].values)\n        try:\n            res = openai.Embedding.create(input=list_to_encode, engine=MODEL)\n            embeds = [record['embedding'] for record in res['data']]\n        except:\n            embeds = []\n            get_logger().error('Failed to embed entire list, embedding one by one...')\n            for i, text in enumerate(list_to_encode):\n                try:\n                    res = openai.Embedding.create(input=[text], engine=MODEL)\n                    embeds.append(res['data'][0]['embedding'])\n                except:\n                    embeds.append([0] * 1536)\n        df[\"values\"] = embeds\n        meta = DatasetMetadata.empty()\n        meta.dense_model.dimension = len(embeds[0])\n        ds = Dataset.from_pandas(df, meta)\n        get_logger().info('Done')\n\n        api_key = get_settings().pinecone.api_key\n        environment = get_settings().pinecone.environment\n        if not upsert:\n            get_logger().info('Creating index from scratch...')\n            ds.to_pinecone_index(self.index_name, api_key=api_key, environment=environment)\n            time.sleep(15)  # wait for pinecone to finalize indexing before querying\n        else:\n            get_logger().info('Upserting index...')\n            namespace = \"\"\n            batch_size: int = 100\n            concurrency: int = 10\n            pinecone.init(api_key=api_key, environment=environment)\n            ds._upsert_to_index(self.index_name, namespace, batch_size, concurrency)\n            time.sleep(5)  # wait for pinecone to finalize upserting before querying\n        get_logger().info('Done')\n\n    def _update_table_with_issues(self, issues_list, repo_name_for_index, ingest=False):\n        get_logger().info('Processing issues...')\n\n        corpus = Corpus()\n        example_issue_record = Record(\n            id=f\"example_issue_{repo_name_for_index}\",\n            text=\"example_issue\",\n            metadata=Metadata(repo=repo_name_for_index)\n        )\n        corpus.append(example_issue_record)\n\n        counter = 0\n        for issue in issues_list:\n            if issue.pull_request:\n                continue\n\n            counter += 1\n            if counter % 100 == 0:\n                get_logger().info(f\"Scanned {counter} issues\")\n            if counter >= self.max_issues_to_scan:\n                get_logger().info(f\"Scanned {self.max_issues_to_scan} issues, stopping\")\n                break\n\n            issue_str, comments, number = self._process_issue(issue)\n            issue_key = f\"issue_{number}\"\n            username = issue.user.login\n            created_at = str(issue.created_at)\n            if len(issue_str) < 8000 or \\\n                    self.token_handler.count_tokens(issue_str) < get_max_tokens(MODEL):  # fast reject first\n                issue_record = Record(\n                    id=issue_key + \".\" + \"issue\",\n                    text=issue_str,\n                    metadata=Metadata(repo=repo_name_for_index,\n                                        username=username,\n                                        created_at=created_at,\n                                        level=IssueLevel.ISSUE)\n                )\n                corpus.append(issue_record)\n                if comments:\n                    for j, comment in enumerate(comments):\n                        comment_body = comment.body\n                        num_words_comment = len(comment_body.split())\n                        if num_words_comment < 10 or not isinstance(comment_body, str):\n                            continue\n\n                        if len(comment_body) < 8000 or \\\n                                self.token_handler.count_tokens(comment_body) < MAX_TOKENS[MODEL]:\n                            comment_record = Record(\n                                id=issue_key + \".comment_\" + str(j + 1),\n                                text=comment_body,\n                                metadata=Metadata(repo=repo_name_for_index,\n                                                    username=username,  # use issue username for all comments\n                                                    created_at=created_at,\n                                                    level=IssueLevel.COMMENT)\n                            )\n                            corpus.append(comment_record)\n        df = pd.DataFrame(corpus.dict()[\"documents\"])\n        get_logger().info('Done')\n\n        get_logger().info('Embedding...')\n        openai.api_key = get_settings().openai.key\n        list_to_encode = list(df[\"text\"].values)\n        try:\n            res = openai.Embedding.create(input=list_to_encode, engine=MODEL)\n            embeds = [record['embedding'] for record in res['data']]\n        except:\n            embeds = []\n            get_logger().error('Failed to embed entire list, embedding one by one...')\n            for i, text in enumerate(list_to_encode):\n                try:\n                    res = openai.Embedding.create(input=[text], engine=MODEL)\n                    embeds.append(res['data'][0]['embedding'])\n                except:\n                    embeds.append([0] * 1536)\n        df[\"vector\"] = embeds\n        get_logger().info('Done')\n\n        if not ingest:\n            get_logger().info('Creating table from scratch...')\n            self.table = self.db.create_table(self.index_name, data=df, mode=\"overwrite\")\n            time.sleep(15)\n        else:\n            get_logger().info('Ingesting in Table...')\n            if self.index_name not in self.db.table_names():\n                self.table.add(df)\n            else:\n                get_logger().info(f\"Table {self.index_name} doesn't exists!\")\n            time.sleep(5)\n        get_logger().info('Done')",
    "start_line": 18,
    "end_line": 458,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRSimilarIssue",
    "component_id": "pr_agent.tools.pr_similar_issue.PRSimilarIssue"
  },
  "pr_agent.tools.pr_similar_issue.IssueLevel": {
    "id": "pr_agent.tools.pr_similar_issue.IssueLevel",
    "name": "IssueLevel",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_similar_issue.py",
    "relative_path": "pr_agent/tools/pr_similar_issue.py",
    "depends_on": [],
    "source_code": "class IssueLevel(str, Enum):\n    ISSUE = \"issue\"\n    COMMENT = \"comment\"",
    "start_line": 461,
    "end_line": 463,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "str",
      "Enum"
    ],
    "class_name": null,
    "display_name": "class IssueLevel",
    "component_id": "pr_agent.tools.pr_similar_issue.IssueLevel"
  },
  "pr_agent.tools.pr_similar_issue.Metadata": {
    "id": "pr_agent.tools.pr_similar_issue.Metadata",
    "name": "Metadata",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_similar_issue.py",
    "relative_path": "pr_agent/tools/pr_similar_issue.py",
    "depends_on": [],
    "source_code": "class Metadata(BaseModel):\n    repo: str\n    username: str = Field(default=\"@codium\")\n    created_at: str = Field(default=\"01-01-1970 00:00:00.00000\")\n    level: IssueLevel = Field(default=IssueLevel.ISSUE)\n\n    class Config:\n        use_enum_values = True",
    "start_line": 466,
    "end_line": 473,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class Metadata",
    "component_id": "pr_agent.tools.pr_similar_issue.Metadata"
  },
  "pr_agent.tools.pr_similar_issue.Config": {
    "id": "pr_agent.tools.pr_similar_issue.Config",
    "name": "Config",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_similar_issue.py",
    "relative_path": "pr_agent/tools/pr_similar_issue.py",
    "depends_on": [],
    "source_code": "    class Config:\n        use_enum_values = True",
    "start_line": 472,
    "end_line": 473,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class Config",
    "component_id": "pr_agent.tools.pr_similar_issue.Config"
  },
  "pr_agent.tools.pr_similar_issue.Record": {
    "id": "pr_agent.tools.pr_similar_issue.Record",
    "name": "Record",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_similar_issue.py",
    "relative_path": "pr_agent/tools/pr_similar_issue.py",
    "depends_on": [],
    "source_code": "class Record(BaseModel):\n    id: str\n    text: str\n    metadata: Metadata",
    "start_line": 476,
    "end_line": 479,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class Record",
    "component_id": "pr_agent.tools.pr_similar_issue.Record"
  },
  "pr_agent.tools.pr_similar_issue.Corpus": {
    "id": "pr_agent.tools.pr_similar_issue.Corpus",
    "name": "Corpus",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_similar_issue.py",
    "relative_path": "pr_agent/tools/pr_similar_issue.py",
    "depends_on": [],
    "source_code": "class Corpus(BaseModel):\n    documents: List[Record] = Field(default=[])\n\n    def append(self, r: Record):\n        self.documents.append(r)",
    "start_line": 482,
    "end_line": 486,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class Corpus",
    "component_id": "pr_agent.tools.pr_similar_issue.Corpus"
  },
  "pr_agent.tools.pr_update_changelog.PRUpdateChangelog": {
    "id": "pr_agent.tools.pr_update_changelog.PRUpdateChangelog",
    "name": "PRUpdateChangelog",
    "component_type": "class",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/pr_update_changelog.py",
    "relative_path": "pr_agent/tools/pr_update_changelog.py",
    "depends_on": [
      "pr_agent.git_providers.git_provider.get_commit_messages",
      "pr_agent.git_providers.git_provider.get_languages",
      "pr_agent.git_providers.git_provider.get_files",
      "pr_agent.git_providers.git_provider.publish_comment",
      "pr_agent.git_providers.git_provider.remove_initial_comment",
      "pr_agent.algo.utils.show_relevant_configurations",
      "pr_agent.algo.pr_processing.get_pr_diff",
      "pr_agent.git_providers.git_provider.get_main_pr_language",
      "pr_agent.git_providers.git_provider.get_pr_branch",
      "pr_agent.config_loader.get_settings",
      "pr_agent.git_providers.git_provider.get_pr_description",
      "pr_agent.algo.pr_processing.retry_with_fallback_models",
      "pr_agent.algo.token_handler.TokenHandler",
      "pr_agent.git_providers.git_provider.get_pr_url",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.git_providers.__init__.get_git_provider"
    ],
    "source_code": "class PRUpdateChangelog:\n    def __init__(self, pr_url: str, cli_mode=False, args=None, ai_handler: partial[BaseAiHandler,] = OpenAIHandler):\n\n        self.git_provider = get_git_provider()(pr_url)\n        self.main_language = get_main_pr_language(\n            self.git_provider.get_languages(), self.git_provider.get_files()\n        )\n        self.commit_changelog = get_settings().pr_update_changelog.push_changelog_changes\n        self._get_changelog_file()  # self.changelog_file_str\n\n        self.ai_handler = ai_handler()\n        self.ai_handler.main_pr_language = self.main_language\n\n        self.patches_diff = None\n        self.prediction = None\n        self.cli_mode = cli_mode\n        self.vars = {\n            \"title\": self.git_provider.pr.title,\n            \"branch\": self.git_provider.get_pr_branch(),\n            \"description\": self.git_provider.get_pr_description(),\n            \"language\": self.main_language,\n            \"diff\": \"\",  # empty diff for initial calculation\n            \"pr_link\": \"\",\n            \"changelog_file_str\": self.changelog_file_str,\n            \"today\": date.today(),\n            \"extra_instructions\": get_settings().pr_update_changelog.extra_instructions,\n            \"commit_messages_str\": self.git_provider.get_commit_messages(),\n        }\n        self.token_handler = TokenHandler(self.git_provider.pr,\n                                          self.vars,\n                                          get_settings().pr_update_changelog_prompt.system,\n                                          get_settings().pr_update_changelog_prompt.user)\n\n    async def run(self):\n        get_logger().info('Updating the changelog...')\n        relevant_configs = {'pr_update_changelog': dict(get_settings().pr_update_changelog),\n                            'config': dict(get_settings().config)}\n        get_logger().debug(\"Relevant configs\", artifacts=relevant_configs)\n\n        # currently only GitHub is supported for pushing changelog changes\n        if get_settings().pr_update_changelog.push_changelog_changes and not hasattr(\n            self.git_provider, \"create_or_update_pr_file\"\n        ):\n            get_logger().error(\n                \"Pushing changelog changes is not currently supported for this code platform\"\n            )\n            if get_settings().config.publish_output:\n                self.git_provider.publish_comment(\n                    \"Pushing changelog changes is not currently supported for this code platform\"\n                )\n            return\n\n        if get_settings().config.publish_output:\n            self.git_provider.publish_comment(\"Preparing changelog updates...\", is_temporary=True)\n\n        await retry_with_fallback_models(self._prepare_prediction, model_type=ModelType.WEAK)\n\n        new_file_content, answer = self._prepare_changelog_update()\n\n        # Output the relevant configurations if enabled\n        if get_settings().get('config', {}).get('output_relevant_configurations', False):\n            answer += show_relevant_configurations(relevant_section='pr_update_changelog')\n\n        get_logger().debug(f\"PR output\", artifact=answer)\n\n        if get_settings().config.publish_output:\n            self.git_provider.remove_initial_comment()\n            if self.commit_changelog:\n                self._push_changelog_update(new_file_content, answer)\n            else:\n                self.git_provider.publish_comment(f\"**Changelog updates:** \\n\\n{answer}\")\n\n    async def _prepare_prediction(self, model: str):\n        self.patches_diff = get_pr_diff(self.git_provider, self.token_handler, model)\n        if self.patches_diff:\n            get_logger().debug(f\"PR diff\", artifact=self.patches_diff)\n            self.prediction = await self._get_prediction(model)\n        else:\n            get_logger().error(f\"Error getting PR diff\")\n            self.prediction = \"\"\n\n    async def _get_prediction(self, model: str):\n        variables = copy.deepcopy(self.vars)\n        variables[\"diff\"] = self.patches_diff  # update diff\n        if get_settings().pr_update_changelog.add_pr_link:\n            variables[\"pr_link\"] = self.git_provider.get_pr_url()\n        environment = Environment(undefined=StrictUndefined)\n        system_prompt = environment.from_string(get_settings().pr_update_changelog_prompt.system).render(variables)\n        user_prompt = environment.from_string(get_settings().pr_update_changelog_prompt.user).render(variables)\n        response, finish_reason = await self.ai_handler.chat_completion(\n            model=model, system=system_prompt, user=user_prompt, temperature=get_settings().config.temperature)\n\n        # post-process the response\n        response = response.strip()\n        if not response:\n            return \"\"\n        if response.startswith(\"```\"):\n            response_lines = response.splitlines()\n            response_lines = response_lines[1:]\n            response = \"\\n\".join(response_lines)\n        response = response.strip(\"`\")\n        return response\n\n    def _prepare_changelog_update(self) -> Tuple[str, str]:\n        answer = self.prediction.strip().strip(\"```\").strip()  # noqa B005\n        if hasattr(self, \"changelog_file\"):\n            existing_content = self.changelog_file\n        else:\n            existing_content = \"\"\n        if existing_content:\n            new_file_content = answer + \"\\n\\n\" + self.changelog_file\n        else:\n            new_file_content = answer\n\n        if not self.commit_changelog:\n            answer += \"\\n\\n\\n>to commit the new content to the CHANGELOG.md file, please type:\" \\\n                      \"\\n>'/update_changelog --pr_update_changelog.push_changelog_changes=true'\\n\"\n\n        return new_file_content, answer\n\n    def _push_changelog_update(self, new_file_content, answer):\n        self.git_provider.create_or_update_pr_file(\n            file_path=\"CHANGELOG.md\",\n            branch=self.git_provider.get_pr_branch(),\n            contents=new_file_content,\n            message=\"[skip ci] Update CHANGELOG.md\",\n        )\n\n        sleep(5)  # wait for the file to be updated\n        try:\n            if get_settings().config.git_provider == \"github\":\n                last_commit_id = list(self.git_provider.pr.get_commits())[-1]\n                d = dict(\n                    body=\"CHANGELOG.md update\",\n                    path=\"CHANGELOG.md\",\n                    line=max(2, len(answer.splitlines())),\n                    start_line=1,\n                )\n                self.git_provider.pr.create_review(commit=last_commit_id, comments=[d])\n        except Exception:\n            # we can't create a review for some reason, let's just publish a comment\n            self.git_provider.publish_comment(f\"**Changelog updates: **\\n\\n{answer}\")\n\n    def _get_default_changelog(self):\n        example_changelog = \\\n\"\"\"\nExample:\n## <current_date>\n\n### Added\n...\n### Changed\n...\n### Fixed\n...\n\"\"\"\n        return example_changelog\n\n    def _get_changelog_file(self):\n        try:\n            self.changelog_file = self.git_provider.get_pr_file_content(\n                \"CHANGELOG.md\", self.git_provider.get_pr_branch()\n            )\n            changelog_file_lines = self.changelog_file.splitlines()\n            changelog_file_lines = changelog_file_lines[:CHANGELOG_LINES]\n            self.changelog_file_str = \"\\n\".join(changelog_file_lines)\n        except Exception:\n            self.changelog_file_str = \"\"\n            self.changelog_file = \"\"\n\n        if not self.changelog_file_str:\n            self.changelog_file_str = self._get_default_changelog()",
    "start_line": 22,
    "end_line": 193,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PRUpdateChangelog",
    "component_id": "pr_agent.tools.pr_update_changelog.PRUpdateChangelog"
  },
  "pr_agent.tools.ticket_pr_compliance_check.find_jira_tickets": {
    "id": "pr_agent.tools.ticket_pr_compliance_check.find_jira_tickets",
    "name": "find_jira_tickets",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/ticket_pr_compliance_check.py",
    "relative_path": "pr_agent/tools/ticket_pr_compliance_check.py",
    "depends_on": [],
    "source_code": "def find_jira_tickets(text):\n    # Regular expression patterns for JIRA tickets\n    patterns = [\n        r'\\b[A-Z]{2,10}-\\d{1,7}\\b',  # Standard JIRA ticket format (e.g., PROJ-123)\n        r'(?:https?://[^\\s/]+/browse/)?([A-Z]{2,10}-\\d{1,7})\\b'  # JIRA URL or just the ticket\n    ]\n\n    tickets = set()\n    for pattern in patterns:\n        matches = re.findall(pattern, text)\n        for match in matches:\n            if isinstance(match, tuple):\n                # If it's a tuple (from the URL pattern), take the last non-empty group\n                ticket = next((m for m in reversed(match) if m), None)\n            else:\n                ticket = match\n            if ticket:\n                tickets.add(ticket)\n\n    return list(tickets)",
    "start_line": 13,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function find_jira_tickets",
    "component_id": "pr_agent.tools.ticket_pr_compliance_check.find_jira_tickets"
  },
  "pr_agent.tools.ticket_pr_compliance_check.extract_ticket_links_from_pr_description": {
    "id": "pr_agent.tools.ticket_pr_compliance_check.extract_ticket_links_from_pr_description",
    "name": "extract_ticket_links_from_pr_description",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/ticket_pr_compliance_check.py",
    "relative_path": "pr_agent/tools/ticket_pr_compliance_check.py",
    "depends_on": [
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "def extract_ticket_links_from_pr_description(pr_description, repo_path, base_url_html='https://github.com'):\n    \"\"\"\n    Extract all ticket links from PR description\n    \"\"\"\n    github_tickets = set()\n    try:\n        # Use the updated pattern to find matches\n        matches = GITHUB_TICKET_PATTERN.findall(pr_description)\n\n        for match in matches:\n            if match[0]:  # Full URL match\n                github_tickets.add(match[0])\n            elif match[1]:  # Shorthand notation match: owner/repo#issue_number\n                owner, repo, issue_number = match[2], match[3], match[4]\n                github_tickets.add(f'{base_url_html.strip(\"/\")}/{owner}/{repo}/issues/{issue_number}')\n            else:  # #123 format\n                issue_number = match[5][1:]  # remove #\n                if issue_number.isdigit() and len(issue_number) < 5 and repo_path:\n                    github_tickets.add(f'{base_url_html.strip(\"/\")}/{repo_path}/issues/{issue_number}')\n\n        if len(github_tickets) > 3:\n            get_logger().info(f\"Too many tickets found in PR description: {len(github_tickets)}\")\n            # Limit the number of tickets to 3\n            github_tickets = set(list(github_tickets)[:3])\n    except Exception as e:\n        get_logger().error(f\"Error extracting tickets error= {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})\n\n    return list(github_tickets)",
    "start_line": 35,
    "end_line": 63,
    "has_docstring": true,
    "docstring": "Extract all ticket links from PR description",
    "parameters": [
      "pr_description",
      "repo_path",
      "base_url_html"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_ticket_links_from_pr_description",
    "component_id": "pr_agent.tools.ticket_pr_compliance_check.extract_ticket_links_from_pr_description"
  },
  "pr_agent.tools.ticket_pr_compliance_check.extract_tickets": {
    "id": "pr_agent.tools.ticket_pr_compliance_check.extract_tickets",
    "name": "extract_tickets",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/ticket_pr_compliance_check.py",
    "relative_path": "pr_agent/tools/ticket_pr_compliance_check.py",
    "depends_on": [
      "pr_agent.tools.ticket_pr_compliance_check.extract_ticket_links_from_pr_description",
      "pr_agent.git_providers.git_provider.get_user_description",
      "pr_agent.log.__init__.get_logger"
    ],
    "source_code": "async def extract_tickets(git_provider):\n    MAX_TICKET_CHARACTERS = 10000\n    try:\n        if isinstance(git_provider, GithubProvider):\n            user_description = git_provider.get_user_description()\n            tickets = extract_ticket_links_from_pr_description(user_description, git_provider.repo, git_provider.base_url_html)\n            tickets_content = []\n\n            if tickets:\n\n                for ticket in tickets:\n                    repo_name, original_issue_number = git_provider._parse_issue_url(ticket)\n\n                    try:\n                        issue_main = git_provider.repo_obj.get_issue(original_issue_number)\n                    except Exception as e:\n                        get_logger().error(f\"Error getting main issue: {e}\",\n                                           artifact={\"traceback\": traceback.format_exc()})\n                        continue\n\n                    issue_body_str = issue_main.body or \"\"\n                    if len(issue_body_str) > MAX_TICKET_CHARACTERS:\n                        issue_body_str = issue_body_str[:MAX_TICKET_CHARACTERS] + \"...\"\n\n                    # Extract sub-issues\n                    sub_issues_content = []\n                    try:\n                        sub_issues = git_provider.fetch_sub_issues(ticket)\n                        for sub_issue_url in sub_issues:\n                            try:\n                                sub_repo, sub_issue_number = git_provider._parse_issue_url(sub_issue_url)\n                                sub_issue = git_provider.repo_obj.get_issue(sub_issue_number)\n\n                                sub_body = sub_issue.body or \"\"\n                                if len(sub_body) > MAX_TICKET_CHARACTERS:\n                                    sub_body = sub_body[:MAX_TICKET_CHARACTERS] + \"...\"\n\n                                sub_issues_content.append({\n                                    'ticket_url': sub_issue_url,\n                                    'title': sub_issue.title,\n                                    'body': sub_body\n                                })\n                            except Exception as e:\n                                get_logger().warning(f\"Failed to fetch sub-issue content for {sub_issue_url}: {e}\")\n\n                    except Exception as e:\n                        get_logger().warning(f\"Failed to fetch sub-issues for {ticket}: {e}\")\n\n                    # Extract labels\n                    labels = []\n                    try:\n                        for label in issue_main.labels:\n                            labels.append(label.name if hasattr(label, 'name') else label)\n                    except Exception as e:\n                        get_logger().error(f\"Error extracting labels error= {e}\",\n                                           artifact={\"traceback\": traceback.format_exc()})\n\n                    tickets_content.append({\n                        'ticket_id': issue_main.number,\n                        'ticket_url': ticket,\n                        'title': issue_main.title,\n                        'body': issue_body_str,\n                        'labels': \", \".join(labels),\n                        'sub_issues': sub_issues_content  # Store sub-issues content\n                    })\n\n                return tickets_content\n\n    except Exception as e:\n        get_logger().error(f\"Error extracting tickets error= {e}\",\n                           artifact={\"traceback\": traceback.format_exc()})",
    "start_line": 66,
    "end_line": 136,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "git_provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_tickets",
    "component_id": "pr_agent.tools.ticket_pr_compliance_check.extract_tickets"
  },
  "pr_agent.tools.ticket_pr_compliance_check.extract_and_cache_pr_tickets": {
    "id": "pr_agent.tools.ticket_pr_compliance_check.extract_and_cache_pr_tickets",
    "name": "extract_and_cache_pr_tickets",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/ticket_pr_compliance_check.py",
    "relative_path": "pr_agent/tools/ticket_pr_compliance_check.py",
    "depends_on": [
      "pr_agent.tools.ticket_pr_compliance_check.extract_tickets",
      "pr_agent.log.__init__.get_logger",
      "pr_agent.config_loader.get_settings"
    ],
    "source_code": "async def extract_and_cache_pr_tickets(git_provider, vars):\n    if not get_settings().get('pr_reviewer.require_ticket_analysis_review', False):\n        return\n\n    related_tickets = get_settings().get('related_tickets', [])\n\n    if not related_tickets:\n        tickets_content = await extract_tickets(git_provider)\n\n        if tickets_content:\n            # Store sub-issues along with main issues\n            for ticket in tickets_content:\n                if \"sub_issues\" in ticket and ticket[\"sub_issues\"]:\n                    for sub_issue in ticket[\"sub_issues\"]:\n                        related_tickets.append(sub_issue)  # Add sub-issues content\n\n                related_tickets.append(ticket)\n\n            get_logger().info(\"Extracted tickets and sub-issues from PR description\",\n                              artifact={\"tickets\": related_tickets})\n\n            vars['related_tickets'] = related_tickets\n            get_settings().set('related_tickets', related_tickets)\n    else:\n        get_logger().info(\"Using cached tickets\", artifact={\"tickets\": related_tickets})\n        vars['related_tickets'] = related_tickets",
    "start_line": 139,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "git_provider",
      "vars"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_and_cache_pr_tickets",
    "component_id": "pr_agent.tools.ticket_pr_compliance_check.extract_and_cache_pr_tickets"
  },
  "pr_agent.tools.ticket_pr_compliance_check.check_tickets_relevancy": {
    "id": "pr_agent.tools.ticket_pr_compliance_check.check_tickets_relevancy",
    "name": "check_tickets_relevancy",
    "component_type": "function",
    "file_path": "/home/chien/pr-agentt/pr_agent/tools/ticket_pr_compliance_check.py",
    "relative_path": "pr_agent/tools/ticket_pr_compliance_check.py",
    "depends_on": [],
    "source_code": "def check_tickets_relevancy():\n    return True",
    "start_line": 167,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function check_tickets_relevancy",
    "component_id": "pr_agent.tools.ticket_pr_compliance_check.check_tickets_relevancy"
  }
}